<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xaoxuu</title>
  <icon>https://www.gravatar.com/avatar/adb7d1cd192658a55c0ad22a3309cecf</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xaoxuu.com/"/>
  <updated>2020-09-11T03:23:22.717Z</updated>
  <id>https://xaoxuu.com/</id>
  
  <author>
    <name>Mr. Xu</name>
    <email>me@xaoxuu.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用 Sketch 制作合适的文章插图</title>
    <link href="https://xaoxuu.com/blog/2020-08-24-sketch-usage/"/>
    <id>https://xaoxuu.com/blog/2020-08-24-sketch-usage/</id>
    <published>2020-08-23T16:00:00.000Z</published>
    <updated>2020-09-11T03:23:22.717Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Sketch 是一款易于上手且功能强大的矢量图设计工具。社区有大量的设计素材和模板，B站也有很多详细的使用教程。本文将从文章插图的方面简要分享一下制作流程，没有什么高级教程，旨在让不会制作插图的朋友们能够快速上手。</p><a id="more"></a><video poster="https://gitee.com/xaoxuu/cdn-assets/raw/master/mirror/sketch/v64-app-window-poster.jpg" playsinline="" muted="" loop="" autoplay="" width="100%" height="auto" preload="metadata"><source src="https://gitee.com/xaoxuu/cdn-assets/raw/master/mirror/sketch/v64-app-window.mp4" type="video/mp4"></video><p>由于太懒，博客一直被当作开放性笔记，言简意赅也没有插图，自然也没有读者。在看了 <a href="https://blog.skk.moe/" target="_blank" rel="noopener external nofollow noreferrer">@Sukka</a> 大佬的「<a href="https://blog.skk.moe/post/how-to-write-for-seo/" target="_blank" rel="noopener external nofollow noreferrer">如何写一篇同时面向人和搜索引擎的文章</a>」这篇文章之后，我觉得我应该回归搭建博客的初心，好好打磨内容了。</p><h2 id="插入画板"><a href="#插入画板" class="headerlink" title="插入画板"></a>插入画板</h2><p>点击左上角的「+」号，选择「画板」选项：</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://gitee.com/xaoxuu/cdn-assets/raw/master/tmp/2020-0824-01.jpg" class="lazyload" data-srcset="https://gitee.com/xaoxuu/cdn-assets/raw/master/tmp/2020-0824-01.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></div></div><p>在右侧边栏中修改这个画板的位置和大小：</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://gitee.com/xaoxuu/cdn-assets/raw/master/tmp/2020-0824-02.jpg" class="lazyload" data-srcset="https://gitee.com/xaoxuu/cdn-assets/raw/master/tmp/2020-0824-02.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></div></div><h2 id="图层属性"><a href="#图层属性" class="headerlink" title="图层属性"></a>图层属性</h2><p>然后将背景素材拖入画板，并调整好大小：</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://gitee.com/xaoxuu/cdn-assets/raw/master/tmp/2020-0824-03.jpg" class="lazyload" data-srcset="https://gitee.com/xaoxuu/cdn-assets/raw/master/tmp/2020-0824-03.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></div></div><p>点击左上角的「+」号，新建一个矩形：</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://gitee.com/xaoxuu/cdn-assets/raw/master/tmp/2020-0824-04.jpg" class="lazyload" data-srcset="https://gitee.com/xaoxuu/cdn-assets/raw/master/tmp/2020-0824-04.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></div></div><p>在右侧边栏中修改这个矩形的填充色和模糊效果：</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://gitee.com/xaoxuu/cdn-assets/raw/master/tmp/2020-0824-05.jpg" class="lazyload" data-srcset="https://gitee.com/xaoxuu/cdn-assets/raw/master/tmp/2020-0824-05.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></div></div><p>然后拖入前景素材：</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://gitee.com/xaoxuu/cdn-assets/raw/master/tmp/2020-0824-06.jpg" class="lazyload" data-srcset="https://gitee.com/xaoxuu/cdn-assets/raw/master/tmp/2020-0824-06.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></div></div><h2 id="生成切图"><a href="#生成切图" class="headerlink" title="生成切图"></a>生成切图</h2><p>在左侧边栏点击要导出的画板，然后点击右侧边栏「制作导出项」右边的「+」号：</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://gitee.com/xaoxuu/cdn-assets/raw/master/tmp/2020-0824-07.jpg" class="lazyload" data-srcset="https://gitee.com/xaoxuu/cdn-assets/raw/master/tmp/2020-0824-07.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></div></div><p>可以选择一种格式，以 <code>JPG</code> 为例：</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://gitee.com/xaoxuu/cdn-assets/raw/master/tmp/2020-0824-08.jpg" class="lazyload" data-srcset="https://gitee.com/xaoxuu/cdn-assets/raw/master/tmp/2020-0824-08.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></div></div><p>点击右下角的「已选中导出项...」是导出选中的画板，也可以点击右上角的「导出」进行批量选择：</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://gitee.com/xaoxuu/cdn-assets/raw/master/tmp/2020-0824-09.jpg" class="lazyload" data-srcset="https://gitee.com/xaoxuu/cdn-assets/raw/master/tmp/2020-0824-09.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></div></div><p>忘了给画板改名了，改名之后如图：</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://gitee.com/xaoxuu/cdn-assets/raw/master/tmp/2020-0824-10.jpg" class="lazyload" data-srcset="https://gitee.com/xaoxuu/cdn-assets/raw/master/tmp/2020-0824-10.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></div></div><p>导出的时候可以选择 JPG 质量：</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://gitee.com/xaoxuu/cdn-assets/raw/master/tmp/2020-0824-11.jpg" class="lazyload" data-srcset="https://gitee.com/xaoxuu/cdn-assets/raw/master/tmp/2020-0824-11.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></div></div><h2 id="Sketch-官方网站"><a href="#Sketch-官方网站" class="headerlink" title="Sketch 官方网站"></a>Sketch 官方网站</h2><p>这个是 Sketch 的官方网站，不要从其他网站购买到假冒产品：</p><div class="tag link"><a class="link-card" title="Sketch" href="https://www.sketch.com/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/256/safari.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/256/safari.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></div><div class="right"><p class="text">Sketch</p><p class="url">https://www.sketch.com/</p></div></a></div><h2 id="源文件下载"><a href="#源文件下载" class="headerlink" title="源文件下载"></a>源文件下载</h2><div class="tag link"><a class="link-card" title="demo.sketch" href="https://img.vim-cn.com/be/011367637b795dc765a7ecc7dd0bfe1ec86291.zip"><div class="left"><img src="https://gitee.com/xaoxuu/cdn-assets/raw/master/logo/sketch/sketch-64@2x.png" class="lazyload" data-srcset="https://gitee.com/xaoxuu/cdn-assets/raw/master/logo/sketch/sketch-64@2x.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></div><div class="right"><p class="text">demo.sketch</p><p class="url">https://img.vim-cn.com/be/011367637b795dc765a7ecc7dd0bfe1ec86291.zip</p></div></a></div><br><div class="note message yellow"><p>这篇文章还在编辑中...</p></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Sketch 是一款易于上手且功能强大的矢量图设计工具。社区有大量的设计素材和模板，B站也有很多详细的使用教程。本文将从文章插图的方面简要分享一下制作流程，没有什么高级教程，旨在让不会制作插图的朋友们能够快速上手。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计" scheme="https://xaoxuu.com/blog/categories/%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>静态博客使用 Issues API 发布动态、友链、书签</title>
    <link href="https://xaoxuu.com/blog/2020-08-23-issues-api/"/>
    <id>https://xaoxuu.com/blog/2020-08-23-issues-api/</id>
    <published>2020-08-22T16:00:00.000Z</published>
    <updated>2020-09-09T03:23:04.126Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>由于发布 issue 的成本远远低于发布一次博客更新（即便是使用了持续集成），可以用 issue 来简化每个独立博客都必备的友链系统，也可以通过 issue 来快速发布动态资讯，弥补静态博客必须更新静态文件才能更新内容的缺点。此功能已经集成到了主题中，使用非常方便。</p><a id="more"></a><blockquote><p>支持 GitHub 和 Gitee</p></blockquote><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>如标题所说，例如 Issues API 来实现，把请求到的结果进行解析，然后生成 HTML 标签，添加到页面中。为了获取到需要的信息，创建 Issue 需要遵循一定的格式，例如「网站卡片」就需要截图、网站标题、网站链接、网站描述、头像。可以设置 <a href="https://github.com/volantis-x/examples/issues/new/choose" target="_blank" rel="noopener external nofollow noreferrer">Issues 模版</a> 来简化步骤。</p><h2 id="演示效果"><a href="#演示效果" class="headerlink" title="演示效果"></a>演示效果</h2><div class="tag link"><a class="link-card" title="友链" href="/friends/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/256/safari.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/256/safari.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></div><div class="right"><p class="text">友链</p><p class="url">/friends/</p></div></a></div><div class="tag link"><a class="link-card" title="示例博客" href="https://volantis.js.org/examples/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/256/safari.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/256/safari.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></div><div class="right"><p class="text">示例博客</p><p class="url">https://volantis.js.org/examples/</p></div></a></div><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>通过 issue 方式发布内容可以支持 <code>script</code> 脚本，为了安全起见，最好设置一个限制，例如用标签来激活 <code>labels=active</code> 或者只对自己发布的有效，可以在解析数据的时候过滤掉 <code>script</code> 标签。</p><h2 id="如何在主题中使用？"><a href="#如何在主题中使用？" class="headerlink" title="如何在主题中使用？"></a>如何在主题中使用？</h2><p>在配置文件中开启此功能：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">plugins:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">issues:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>在 GitHub 或者 Gitee 创建仓库，仿照下面的示例，把 api 中的用户名和仓库名改成自己的。</p><h3 id="时间线（用于发布动态）"><a href="#时间线（用于发布动态）" class="headerlink" title="时间线（用于发布动态）"></a>时间线（用于发布动态）</h3><p>此类型的 Issue 标题即为时间，内容不需要什么格式。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% issues timeline | api&#x3D;https:&#x2F;&#x2F;gitee.com&#x2F;api&#x2F;v5&#x2F;repos&#x2F;xaoxuu&#x2F;timeline&#x2F;issues?state&#x3D;open&amp;creator&#x3D;xaoxuu&amp;sort&#x3D;created&amp;direction&#x3D;desc&amp;page&#x3D;1&amp;per_page&#x3D;100 %&#125;</span><br></pre></td></tr></table></figure><details ><summary> 查看效果 </summary>              <div class='content'>              <div class="issues-api timeline"api="https://gitee.com/api/v5/repos/xaoxuu/timeline/issues?state=open&creator=xaoxuu&sort=created&direction=desc&page=1&per_page=50"></div>              </div>            </details><p>上述示例对应的仓库链接：</p><div class="tag link"><a class="link-card" title="Gitee: xaoxuu/timeline" href="https://gitee.com/xaoxuu/timeline/issues"><div class="left"><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/256/safari.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/256/safari.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></div><div class="right"><p class="text">Gitee: xaoxuu/timeline</p><p class="url">https://gitee.com/xaoxuu/timeline/issues</p></div></a></div><h3 id="网站卡片（用于书签、收藏夹、友链）"><a href="#网站卡片（用于书签、收藏夹、友链）" class="headerlink" title="网站卡片（用于书签、收藏夹、友链）"></a>网站卡片（用于书签、收藏夹、友链）</h3><p>此类型的 Issue 内容中需要有一段满足 JSON 格式的代码块：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;screenshot&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;avatar&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;版本：^4.0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% issues sites | api&#x3D;https:&#x2F;&#x2F;api.github.com&#x2F;repos&#x2F;volantis-x&#x2F;examples&#x2F;issues?sort&#x3D;updated&amp;state&#x3D;open&amp;page&#x3D;1&amp;per_page&#x3D;100 | group&#x3D;version:版本：^4.0,版本：^3.0,版本：^2.0 %&#125;</span><br></pre></td></tr></table></figure><p>上述示例对应的仓库链接：</p><div class="tag link"><a class="link-card" title="GitHub: volantis-x/examples" href="https://github.com/volantis-x/examples/issues"><div class="left"><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/256/safari.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/256/safari.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></div><div class="right"><p class="text">GitHub: volantis-x/examples</p><p class="url">https://github.com/volantis-x/examples/issues</p></div></a></div><h3 id="头像卡片（用于友链、成员列表）"><a href="#头像卡片（用于友链、成员列表）" class="headerlink" title="头像卡片（用于友链、成员列表）"></a>头像卡片（用于友链、成员列表）</h3><p>此类型的 Issue 标题即为链接，内容需要满足以下格式：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;screenshot&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;avatar&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% issues sites | api&#x3D;https:&#x2F;&#x2F;api.github.com&#x2F;repos&#x2F;xaoxuu&#x2F;friends&#x2F;issues?sort&#x3D;updated&amp;state&#x3D;open&amp;page&#x3D;1&amp;per_page&#x3D;100&amp;labels&#x3D;active %&#125;</span><br></pre></td></tr></table></figure><p>上述示例对应的仓库链接：</p><div class="tag link"><a class="link-card" title="GitHub: xaoxuu/friends" href="https://github.com/xaoxuu/friends/issues"><div class="left"><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/256/safari.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/256/safari.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></div><div class="right"><p class="text">GitHub: xaoxuu/friends</p><p class="url">https://github.com/xaoxuu/friends/issues</p></div></a></div><div class="note warning"><p>头像卡片目前还未开发，请先使用网站卡片代替。</p></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于发布 issue 的成本远远低于发布一次博客更新（即便是使用了持续集成），可以用 issue 来简化每个独立博客都必备的友链系统，也可以通过 issue 来快速发布动态资讯，弥补静态博客必须更新静态文件才能更新内容的缺点。此功能已经集成到了主题中，使用非常方便。&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发" scheme="https://xaoxuu.com/blog/categories/%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>个人电脑作为办公设备时如何保护隐私？</title>
    <link href="https://xaoxuu.com/blog/2020-06-27-privacy/"/>
    <id>https://xaoxuu.com/blog/2020-06-27-privacy/</id>
    <published>2020-06-26T16:00:00.000Z</published>
    <updated>2020-08-31T01:38:59.528Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>公司一般都会强制安装安防软件，这些软件要求开机自启动，要求有屏幕录制权限、完全的磁盘访问权限包括相册图库。因此如果使用自己的 MacBook 作为办公设备，必须要把生活区和工作区完全独立开，安装在两个磁盘分区，并且对磁盘分区加密。</p><a id="more"></a><h2 id="分区加密"><a href="#分区加密" class="headerlink" title="分区加密"></a>分区加密</h2><p>对 Mac 电脑进行磁盘分区和安装多系统非常简单，打开「磁盘工具」点击标题栏的「分区」按钮进行分区即可，分区的格式一定要选择加密的，这里推荐「APFS（加密）」格式。密码要记下来防止遗忘。这里选择加密分区主要可以防止意外挂载：在启动了工作区的系统之后，由于需要密码才能挂载生活区的数据宗卷，可以有效避免不小心点了挂载或者设置了自动挂载，导致拥有完整的磁盘访问权限的安防软件自动扫描了生活区的文件资料。同样的道理，工作分区加密也可以防止生活区的某些软件扫描到了工作资料导致数据泄露。</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://gitee.com/xaoxuu/cdn-assets/raw/master/blog/2020-0627d@2x.png" class="lazyload" data-srcset="https://gitee.com/xaoxuu/cdn-assets/raw/master/blog/2020-0627d@2x.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></div></div><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://gitee.com/xaoxuu/cdn-assets/raw/master/blog/2020-0627c@2x.png" class="lazyload" data-srcset="https://gitee.com/xaoxuu/cdn-assets/raw/master/blog/2020-0627c@2x.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></div></div><p>分区完成之后，安装系统，目标宗卷选择刚刚新建的工作分区，剩下的系统安装步骤不需要赘述了。</p><h2 id="工作专用账号"><a href="#工作专用账号" class="headerlink" title="工作专用账号"></a>工作专用账号</h2><p>系统安装完成之后，最好登录工作专用的账号，不要使用同一个 AppleID 进行登录，否则仍然存在数据泄露的风险。同样的，浏览器账号也需要使用工作专用。AppleID 和浏览器账号基本上可以满足大部分需要记住账号密码的需求。</p><p>而对于工作日志，我推荐给程序员的做法是创建本地 git 仓库，用 <a href="https://typora.io/" target="_blank" rel="noopener external nofollow noreferrer">Typora</a> 编辑器 markdown 格式书写。它的缺点十分有限，就是新增文件稍微麻烦一点，要在左侧目录树上点击右键，然后选择「新建文件」，然后输入文件名，除此之外几乎没有缺点。对于支持 md 的其它笔记软件来说，它对于 md 的支持比较完整，方便更换和修改主题，导出格式丰富并且样式也比较完整。</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://gitee.com/xaoxuu/cdn-assets/raw/master/blog/2020-0627e@2x.png" class="lazyload" data-srcset="https://gitee.com/xaoxuu/cdn-assets/raw/master/blog/2020-0627e@2x.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Typora 操作界面"/></div><span class="image-caption">Typora 操作界面</span></div><h2 id="用户目录权限"><a href="#用户目录权限" class="headerlink" title="用户目录权限"></a>用户目录权限</h2><p>Mac 自带的一些用户文件目录例如「文稿」「桌面」等默认权限是 700 也就是仅当前用户可以读写和执行，但是自己新建的文件夹默认权限是 755 即全局用户都可以读取和执行。所以如果自己在原生的文件目录之外新建了文件夹，记得更改文件夹的权限：</p><div class="img-wrap"><div class="img-bg" style="background:#ECECEC"><img class="img lazyload" src="https://gitee.com/xaoxuu/cdn-assets/raw/master/blog/2020-0627a@2x.jpg" class="lazyload" data-srcset="https://gitee.com/xaoxuu/cdn-assets/raw/master/blog/2020-0627a@2x.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="把权限由 755 修改为 700" style="width:500px;"/></div><span class="image-caption">把权限由 755 修改为 700</span></div><p>我切换了另一个用户进入这个用户目录时就提示无权限访问了，理论上这个用户上的应用程序也没有权限访问吧。（不太肯定）</p><div class="note warning"><p><strong>一个小坑</strong></p><p>经测试发现，在两个独立的宗卷中如果存在用户名和密码相同的两个用户，那么即使设置了 700 权限，但实际上在另一个宗卷中登录同名同密码的用户，对这个用户的文件夹一样拥有权限，不知道这是苹果有意为之还是设计漏洞。</p></div><h2 id="一个不便之处"><a href="#一个不便之处" class="headerlink" title="一个不便之处"></a>一个不便之处</h2><p>流程是进入系统后自动请求挂载另一个宗卷，由于开启了文件保险箱，所以弹出了密码输入框，不输入密码点击取消，则没有权限访问另一卷的磁盘内容。但是每次开机都会有这个弹窗，挺烦人的。</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://gitee.com/xaoxuu/cdn-assets/raw/master/blog/2020-0627f@2x.png" class="lazyload" data-srcset="https://gitee.com/xaoxuu/cdn-assets/raw/master/blog/2020-0627f@2x.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="width:542px;"/></div></div><p>网上搜索了设置开机不自动挂载的方法，都是修改 <code>fstab</code> 文件的方法：</p><figure class="highlight md"><figcaption><span>/etc/fstab</span></figcaption><table><tr><td class="code"><pre><span class="line">UUID=427478BB-E267-4455-869A-4AAB54F792A1 none auto noauto 0 0</span><br></pre></td></tr></table></figure><p>实测无效，每次登录用户还是会自动尝试挂载，可能这种方式在 APFS 分区中不再支持了。不知道在 2020 年，如何让 APFS 加密分区不自动挂载？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;公司一般都会强制安装安防软件，这些软件要求开机自启动，要求有屏幕录制权限、完全的磁盘访问权限包括相册图库。因此如果使用自己的 MacBook 作为办公设备，必须要把生活区和工作区完全独立开，安装在两个磁盘分区，并且对磁盘分区加密。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Mac" scheme="https://xaoxuu.com/blog/categories/mac/"/>
    
    
  </entry>
  
  <entry>
    <title>苹果设计开发加速器《创建卓越的 Apple Watch 体验》活动体验</title>
    <link href="https://xaoxuu.com/blog/2019-10-06-ios-apple-watch/"/>
    <id>https://xaoxuu.com/blog/2019-10-06-ios-apple-watch/</id>
    <published>2019-10-05T16:00:00.000Z</published>
    <updated>2020-09-11T02:58:53.994Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>9月26号收到了苹果的一活动邀请邮件《创建卓越的 Apple Watch 体验》，活动地点是：Design and Development Accelerator，这是苹果今年7月份在上海设立的设计开发加速器，为开发者提供有关应用设计与开发的专业培训和资源。</p><a id="more"></a><details ><summary> 扩展阅读：什么是「设计开发加速器」？ </summary>              <div class='content'>              <ul><li>苹果官网：<a href="https://developer.apple.com/cn/accelerator/" target="_blank" rel="noopener external nofollow noreferrer">设计开发加速器</a></li><li>视频体验：<a href="https://www.bilibili.com/video/av58500736/?spm_id_from=333.788.videocard.7" target="_blank" rel="noopener external nofollow noreferrer">搞机零距离：中国开发者的大好事？苹果工程师一对一授课，让人开了又开？</a></li><li>媒体资讯：<a href="https://sspai.com/post/55613" target="_blank" rel="noopener external nofollow noreferrer">苹果设计开发加速器正式启动，每年计划为 5000 名国内开发者提供支持</a></li></ul>              </div>            </details><details ><summary> 附：议程安排 </summary>              <div class='content'>              <div class="img-wrap"><div class="img-bg" style="background:#F3F2F7"><img class="img lazyload" src="https://gitee.com/xaoxuu/cdn-assets/raw/master/blog/2019-1006a@2x.jpg" class="lazyload" data-srcset="https://gitee.com/xaoxuu/cdn-assets/raw/master/blog/2019-1006a@2x.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="width:400px;"/></div></div><p>苹果上海设计开发加速器地点在源深体育中心地铁站4出口处，三座非常低调没有任何招牌的建筑，绕着走了一圈才找到A座二楼入口的门。内部环境如媒体图片一样，室内禁止私自拍照，只有这张门票留作纪念喽。</p><div class="img-wrap"><div class="img-bg" style="background:#857E74"><img class="img lazyload" src="https://gitee.com/xaoxuu/cdn-assets/raw/master/blog/2019-1006b@2x.jpg" class="lazyload" data-srcset="https://gitee.com/xaoxuu/cdn-assets/raw/master/blog/2019-1006b@2x.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="width:400px;"/></div></div>              </div>            </details><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://gitee.com/xaoxuu/cdn-assets/raw/master/mirror/apple/documentation/watchkit/f4d1fd37-6548-42ce-bd98-b548ef3e01a2.png" class="lazyload" data-srcset="https://gitee.com/xaoxuu/cdn-assets/raw/master/mirror/apple/documentation/watchkit/f4d1fd37-6548-42ce-bd98-b548ef3e01a2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="width:600px;"/></div></div><h2 id="watchOS-6"><a href="#watchOS-6" class="headerlink" title="watchOS 6"></a>watchOS 6</h2><p>构建面向 watchOS 的 app，让用户随时随地及时掌握信息并轻松完成快速操作。开放了更多种全新的 API，可以构建完全独立的 watchOS app，甚至是不带有 iOS 版的 watchOS app。现在，用户可以直接在 Apple Watch 上的 App Store 中查找并安装 app。</p><h2 id="独立的-App"><a href="#独立的-App" class="headerlink" title="独立的 App"></a>独立的 App</h2><p>在 watchOS 6 中，可以构建完全独立的 Watch App。“Sign in with Apple” 让用户远离手机时也能在 Apple Watch 上登录 app。</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://gitee.com/xaoxuu/cdn-assets/raw/master/mirror/apple/documentation/watchkit/af79db6d-02b1-4df0-9f46-6c3c9db12d76.png" class="lazyload" data-srcset="https://gitee.com/xaoxuu/cdn-assets/raw/master/mirror/apple/documentation/watchkit/af79db6d-02b1-4df0-9f46-6c3c9db12d76.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="选择应用模板" style="width:500px;"/></div><span class="image-caption">选择应用模板</span></div><ul><li><p><strong>Watch-only app</strong><br>创建只有 Apple Watch 且没有相关 iOS 应用程序。</p></li><li><p><strong>watchOS app with an iOS app</strong><br>当您拥有 iOS 应用并想要提供可提供相似或相关体验的 watchOS 应用。</p></li></ul><p>在创建 watchOS Target 时，指定要构建的 watchOS 项目的类型。此外，如果将 watchOS 应用程序与 iOS 应用程序捆绑在一起，则必须指定 watchOS 应用程序如何与其配套的 iOS 应用互动。</p><ul><li><strong>Independent Apps</strong> （独立应用）不需要 iOS 配套应用即可正常运行。用户可以选择安装 iOS 应用、watchOS 应用或同时安装两者。</li><li><strong>Dependent Apps</strong> （从属应用）依靠 iOS 配套应用才能正常运行；仅在 watchOS 应用需要与 iOS 应用互动时才创建从属应用。用户必须使用其 iOS 应用购买并安装从属的 watchOS 应用。</li></ul><blockquote><p>在 watchOS 5 和更低版本中，所有 watchOS 应用程序都是从属应用。</p></blockquote><h2 id="Apple-Watch-上的-App-Store"><a href="#Apple-Watch-上的-App-Store" class="headerlink" title="Apple Watch 上的 App Store"></a>Apple Watch 上的 App Store</h2><p>watchOS 6 上提供适用于 Apple Watch 的 App Store，让用户可以直接在 Apple Watch 上轻松探索、浏览、搜索和安装 watchOS app。使用 Siri、听写或涂写进行搜索，或者通过轻点产品页面链接，直接进入产品页面。</p><div class="img-wrap"><div class="img-bg" style="background:#fff"><img class="img lazyload" src="https://gitee.com/xaoxuu/cdn-assets/raw/master/mirror/apple/documentation/watchkit/06d45110-1dd7-49a4-a413-9f5159ecdd0e.png" class="lazyload" data-srcset="https://gitee.com/xaoxuu/cdn-assets/raw/master/mirror/apple/documentation/watchkit/06d45110-1dd7-49a4-a413-9f5159ecdd0e.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="width:180px;"/></div></div><p>系统会为独立和从属应用直接将 watchOS 应用程序下载并安装到 Apple Watch。</p><h2 id="Apple-Watch-人机界面指南"><a href="#Apple-Watch-人机界面指南" class="headerlink" title="Apple Watch 人机界面指南"></a>Apple Watch 人机界面指南</h2><p>Apple Watch 设计为可穿戴，因此用户界面适合穿戴者使用，并为他们带来轻巧，反应灵敏且高度个性化的体验。人们经常使用 watchOS 应用程序的相关体验（例如复杂功能、通知和 Siri 交互），而不是使用应用程序本身。创造出色的 watchOS 体验意味着既要设计应用程序，又要设计快速，信息丰富的元素，使人们能够以适合自己的方式访问您的内容。最有用的应用通常：</p><ul><li>使用复杂功能可以在表盘上提供少量可能动态的信息，使人们可以一目了然地查看信息</li><li>使用通知传递及时的高价值信息并采取重要行动</li><li>帮助人们使用 Siri 获取信息并执行任务</li><li>如有必要，请在应用程序体验中提供更多详细信息和功能</li></ul><div class="img-wrap"><div class="img-bg" style="background:#fff"><img class="img lazyload" src="https://gitee.com/xaoxuu/cdn-assets/raw/master/mirror/apple/design/human-interface-guidelines/watchos/watchOS-hero.svg" class="lazyload" data-srcset="https://gitee.com/xaoxuu/cdn-assets/raw/master/mirror/apple/design/human-interface-guidelines/watchos/watchOS-hero.svg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="width:320px;"/></div></div><br><div class="note warning"><p><strong>图片来源声明</strong></p><p>本文挖了坑但是许久没有填上，直到 watchOS 7 都要发布了，最后决定放弃填坑，文章封面和文中的部分插图来源于苹果官方文档。</p></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;9月26号收到了苹果的一活动邀请邮件《创建卓越的 Apple Watch 体验》，活动地点是：Design and Development Accelerator，这是苹果今年7月份在上海设立的设计开发加速器，为开发者提供有关应用设计与开发的专业培训和资源。&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发" scheme="https://xaoxuu.com/blog/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="https://xaoxuu.com/blog/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>使用链式语法打造一个对象类型转换库</title>
    <link href="https://xaoxuu.com/blog/2019-08-29-valuex/"/>
    <id>https://xaoxuu.com/blog/2019-08-29-valuex/</id>
    <published>2019-08-28T16:00:00.000Z</published>
    <updated>2019-08-28T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>我就职过的公司，都出现过不止一次因为后台实际数据类型和文档不一致导致的程序线上崩溃问题。原则上即使服务器离线了，app 都不应该直接闪退，所以 app 应当具有对服务器异常情况进行处理的能力。使用 <a href="https://github.com/xaoxuu/ValueX/" target="_blank" rel="noopener external nofollow noreferrer">ValueX</a> 可以有效避免后台返回数据类型异常导致的程序崩溃。</p><a id="more"></a><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/xaoxuu/ValueX"><img src="https://github-readme-stats.vercel.app/api/pin/?username=xaoxuu&repo=ValueX&show_owner=true" class="lazyload" data-srcset="https://github-readme-stats.vercel.app/api/pin/?username=xaoxuu&repo=ValueX&show_owner=true" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></a><h2 id="异常场景"><a href="#异常场景" class="headerlink" title="异常场景"></a>异常场景</h2><ul><li>场景1： NSString 类型变成 NSNull</li><li>场景2： nil 变成 <code>@&quot;&lt;null&gt;&quot;</code> 值</li><li>场景3： userId 不确定是 NSString 还是 NSNumber</li><li>场景4： NSDictionary 中嵌套的容器变成了 Json 字符串格式</li></ul><h2 id="问题抽象"><a href="#问题抽象" class="headerlink" title="问题抽象"></a>问题抽象</h2><ul><li>实际类型与定义类型不符</li><li>实际类型与期望类型不一致</li></ul><h2 id="设计接口"><a href="#设计接口" class="headerlink" title="设计接口"></a>设计接口</h2><p>假如我得到一个值 <code>NSString *obj</code>，实际上可能是 NSNull ，可能是 NSNumber ，可能是空数据的 <code>@&quot;&lt;null&gt;&quot;</code> 或者 <code>@&quot;(null)&quot;</code> 等各种表述。那么我需要确保 <code>NSSafeString(obj)</code> 的结果一定是 NSString 类型的值，如果是空数据，就应该是 nil。如果是 <code>@123</code> 这样的数字，那么应该得到 <code>@&quot;123&quot;</code> 这样的字符串。</p><p>如果是 json 数据，它可能以 NSData 类型存在，可能以 Json 字符串 NSString 类型存在，可能以 NSArray 或者 NSDictionary 对象形式存在。我需要的是我要什么类型就能直接获取。例如 <code>ValueX(obj).stringValue</code> 就得到这个数据的 Json 字符串，<code>ValueX(obj).dictionaryValue</code> 就得到这个数据的字典对象。</p><p>所以这个库就分为两部份工作，一部分是将实际类型与定义类型一致化；第二部分是将已知类型转换成它能够转换的其他类型。</p><h3 id="类型安全"><a href="#类型安全" class="headerlink" title="类型安全"></a>类型安全</h3><p>针对 ObjC 中常用的 6 种数据类型 NSString、NSNumber、NSData、NSArray、NSSet、NSDictionary 一一进行判断，写出6个函数：</p><figure class="highlight objc"><figcaption><span>得到安全类型：</span></figcaption><table><tr><td class="code"><pre><span class="line">FOUNDATION_EXTERN <span class="built_in">NSString</span> * __<span class="keyword">nullable</span> <span class="built_in">NSSafeString</span>(<span class="keyword">id</span> obj);</span><br><span class="line">FOUNDATION_EXTERN <span class="built_in">NSNumber</span> * __<span class="keyword">nullable</span> <span class="built_in">NSSafeNumber</span>(<span class="keyword">id</span> obj);</span><br><span class="line">FOUNDATION_EXTERN <span class="built_in">NSData</span> * __<span class="keyword">nullable</span> <span class="built_in">NSSafeData</span>(<span class="keyword">id</span> obj);</span><br><span class="line">FOUNDATION_EXTERN <span class="built_in">NSArray</span> * __<span class="keyword">nullable</span> <span class="built_in">NSSafeArray</span>(<span class="keyword">id</span> obj);</span><br><span class="line">FOUNDATION_EXTERN <span class="built_in">NSSet</span> * __<span class="keyword">nullable</span> <span class="built_in">NSSafeSet</span>(<span class="keyword">id</span> obj);</span><br><span class="line">FOUNDATION_EXTERN <span class="built_in">NSDictionary</span> * __<span class="keyword">nullable</span> <span class="built_in">NSSafeDictionary</span>(<span class="keyword">id</span> obj);</span><br></pre></td></tr></table></figure><p>确保从这些函数出来的值是与定义类型一致的值。</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>即使拿到的值与定义类型一致，有时候我们要用的可能又是其他类型。</p><figure class="highlight objc"><figcaption><span>数据类型转换函数：</span></figcaption><table><tr><td class="code"><pre><span class="line">FOUNDATION_EXTERN VXObject *ValueX(<span class="keyword">id</span> &lt;VXConvertable&gt;obj);</span><br></pre></td></tr></table></figure><p>确保 VXObject 类型可以通过点语法直接得到原数据所能够转换的其他类型。VXObject 是一种中间类型，针对上述 6 种数据类型，每一种可以转换成其他哪些类型进行一一判断。</p><p>其中，NSNumber 只可以转换为 NSString、NSData，遵循 VXConvertable 协议。表示数字的 NSString，可以转换成 NSNumber，表示 Json 的字符串可以转换成对应的 NSArray 或者 NSDictionary，遵守 VXConvertableData 协议。反过来 NSArray、NSSet 或者 NSDictionary 则遵守 VXConvertableObject 协议。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSString</span> (<span class="title">VXObject</span>) &lt;<span class="title">VXConvertableData</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSNumber</span> (<span class="title">VXObject</span>) &lt;<span class="title">VXConvertable</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSData</span> (<span class="title">VXObject</span>) &lt;<span class="title">VXConvertableData</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSArray</span> (<span class="title">VXObject</span>) &lt;<span class="title">VXConvertableObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSSet</span> (<span class="title">VCObject</span>) &lt;<span class="title">VXConvertableObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSDictionary</span> (<span class="title">VXObject</span>) &lt;<span class="title">VXConvertableObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>它们的协议内容是：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">VXConvertable</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line">- (VXObject *)vx;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">VXConvertableObject</span> &lt;<span class="title">VXConvertable</span>&gt;</span></span><br><span class="line">- (VXObject *)vxWithOptions:(<span class="built_in">NSJSONWritingOptions</span>)opt;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">VXConvertableData</span> &lt;<span class="title">VXConvertable</span>&gt;</span></span><br><span class="line">- (VXObject *)vxWithOptions:(<span class="built_in">NSJSONReadingOptions</span>)opt;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>就按照这个思路进行开发，实现的代码就不再赘述了。</p><div class="tag link"><a class="link-card" title="文档" href="/wiki/valuex/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/256/safari.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/256/safari.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></div><div class="right"><p class="text">文档</p><p class="url">/wiki/valuex/</p></div></a></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我就职过的公司，都出现过不止一次因为后台实际数据类型和文档不一致导致的程序线上崩溃问题。原则上即使服务器离线了，app 都不应该直接闪退，所以 app 应当具有对服务器异常情况进行处理的能力。使用 &lt;a href=&quot;https://github.com/xaoxuu/ValueX/&quot; target=&quot;_blank&quot; rel=&quot;noopener external nofollow noreferrer&quot;&gt;ValueX&lt;/a&gt; 可以有效避免后台返回数据类型异常导致的程序崩溃。&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发" scheme="https://xaoxuu.com/blog/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="https://xaoxuu.com/blog/tags/ios/"/>
    
      <category term="开源库" scheme="https://xaoxuu.com/blog/tags/%E5%BC%80%E6%BA%90%E5%BA%93/"/>
    
      <category term="ObjC" scheme="https://xaoxuu.com/blog/tags/objc/"/>
    
  </entry>
  
  <entry>
    <title>如何设计一个样式和逻辑分离的组件</title>
    <link href="https://xaoxuu.com/blog/2019-08-27-prohud/"/>
    <id>https://xaoxuu.com/blog/2019-08-27-prohud/</id>
    <published>2019-08-26T16:00:00.000Z</published>
    <updated>2019-08-26T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong>简单易用，完全可定制化的 HUD</strong><br>ProHUD = Toast（通知横幅） + Alert（ProgressHUD、弹窗） + ActionSheet（操作表）</p><p>在写「ProHUD」之前我已经在「AXKit」中实现了原生控件快速构造方法、为公司写了 ObjC 版的可定制化 HUD、Swift 版的开源的 NoticeBoard（通知横幅）。ProHUD 诞生的意义就在于取代这些不那么完善的 HUD。</p><a id="more"></a><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/xaoxuu/ProHUD"><img src="https://github-readme-stats.vercel.app/api/pin/?username=xaoxuu&repo=ProHUD&show_owner=true" class="lazyload" data-srcset="https://github-readme-stats.vercel.app/api/pin/?username=xaoxuu&repo=ProHUD&show_owner=true" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></a><details ><summary> 大量截图预览 </summary>              <div class='content'>              <div class="gallery ">              <img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/proj/prohud/screenshot01.png'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/proj/prohud/screenshot02.png'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/proj/prohud/screenshot03.png'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/proj/prohud/screenshot04.png'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/proj/prohud/screenshot05.png'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/proj/prohud/screenshot06.png'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/proj/prohud/screenshot07.png'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/proj/prohud/screenshot08.png'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/proj/prohud/screenshot09.png'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/proj/prohud/screenshot10.png'>            </div><div class="gallery ">              <img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/proj/prohud/screenshot11.png'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/proj/prohud/screenshot12.png'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/proj/prohud/screenshot13.png'>            </div>              </div>            </details><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol><li>用相似的接口调用 <strong>Toast</strong>、<strong>Alert</strong>、<strong>Guard</strong> 组件。</li><li>程序初始化时配置自定义 UI 样式，快速调用。</li><li>用简便的方法拿到已发布的实例，避免重复发布实例。</li><li>可对已发布的实例进行数据更新。</li><li>横竖屏和 iPad 布局优化。</li><li>易于扩展，可以很方便的添加任意控件，并处理好布局。</li><li>可对所有实例监听消失事件。</li></ol><div class="tabs" id="install"><ul class="nav-tabs"><li class="tab active"><a href="#install-1">Toast</a></li><li class="tab"><a href="#install-2">Alert</a></li><li class="tab"><a href="#install-3">Guard</a></li></ul><div class="tab-content"><div class="tab-pane active" id="install-1"><p><strong>顶部浮动通知条</strong></p><ol><li>多个 Toast 并存策略（平铺）。</li><li>只接收一个点击事件。</li><li>可以预先对不同的场景配置不同的默认值（图标、持续时间）。</li></ol></div><div class="tab-pane" id="install-2"><p><strong>页面中心弹窗</strong></p><ol><li>多个 Alert 并存策略（具有景深效果的堆叠）。</li><li>可以预先对不同的场景配置不同的默认值（图标、持续时间）。</li><li>可快速创建具有预先配置的默认样式（Default、Destructive、Cancel）的按钮。</li><li>对已发布的实例进行文本和按钮的更新，包括新增、修改、删除文本和按钮。</li><li>强制退出按钮（防止超时导致页面卡死）。</li></ol></div><div class="tab-pane" id="install-3"><p><strong>页面底部操作表</strong></p><ol><li>快速创建具有预先配置的默认样式的文本元素（标题、副标题、正文）。</li><li>可快速创建具有预先配置的默认样式（Default、Destructive、Cancel）的按钮。</li></ol></div></div></div><h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><h3 id="UI与逻辑分离"><a href="#UI与逻辑分离" class="headerlink" title="UI与逻辑分离"></a>UI与逻辑分离</h3><p>这个库采用配置 UI 和调用接口分离的设计，这种思路借鉴了和而泰公共库，我认为这是一种调用比传统 UI 库方便的同时可定制化能力也比传统 UI 库强大的设计思路。</p><p>简单来说，就是你在 AppDelegate 中告诉 ProHUD，你要的横幅、弹窗、操作表分别是什么样的，如果参数是什么什么，就怎么展示 UI。然后调用的地方就不需要设置 UI 了，只需要专注于数据。</p><figure class="highlight swift"><figcaption><span>例如弹出一个正在加载的提示框：</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">Alert</span>.push(scene: .loading, title: <span class="string">&quot;正在加载&quot;</span>, message: <span class="string">&quot;请稍等片刻&quot;</span>)</span><br></pre></td></tr></table></figure><p>这样就发出了一个弹窗，而弹窗的样式，则在 AppDelegate 中以及预先配置好了。我使用了 <code>scene</code> 这个灵活的参数，你可以自己扩展场景。</p><figure class="highlight swift"><figcaption><span>为程序的弹窗场景设置模板，实现快速调用：</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ProHUD</span>.<span class="title">Scene</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> confirm: <span class="type">ProHUD</span>.<span class="type">Scene</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> scene = <span class="type">ProHUD</span>.<span class="type">Scene</span>(identifier: <span class="string">&quot;confirm&quot;</span>)</span><br><span class="line">        scene.image = <span class="type">UIImage</span>(named: <span class="string">&quot;ProHUDMessage&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> scene</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> delete: <span class="type">ProHUD</span>.<span class="type">Scene</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> scene = <span class="type">ProHUD</span>.<span class="type">Scene</span>(identifier: <span class="string">&quot;delete&quot;</span>)</span><br><span class="line">        scene.image = <span class="type">UIImage</span>(named: <span class="string">&quot;ProHUDTrash&quot;</span>)</span><br><span class="line">        scene.title = <span class="string">&quot;确认删除&quot;</span></span><br><span class="line">        scene.message = <span class="string">&quot;此操作不可撤销&quot;</span></span><br><span class="line">        <span class="keyword">return</span> scene</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> buy: <span class="type">ProHUD</span>.<span class="type">Scene</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> scene = <span class="type">ProHUD</span>.<span class="type">Scene</span>(identifier: <span class="string">&quot;buy&quot;</span>)</span><br><span class="line">        scene.image = <span class="type">UIImage</span>(named: <span class="string">&quot;ProHUDBuy&quot;</span>)</span><br><span class="line">        scene.title = <span class="string">&quot;确认付款&quot;</span></span><br><span class="line">        scene.message = <span class="string">&quot;一旦购买拒不退款&quot;</span></span><br><span class="line">        <span class="keyword">return</span> scene</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个 scene 就可以理解成一套模板。</p><h3 id="动态更新"><a href="#动态更新" class="headerlink" title="动态更新"></a>动态更新</h3><p>ProHUD 另一个优势就是动态更新，对于已经发布的实例，你可以方便的去更新内容。</p><figure class="highlight swift"><figcaption><span>示例1：获取刚才弹出的Loading，把它更新为加载成功。</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">Alert</span>.<span class="built_in">find</span>(<span class="string">&quot;loading&quot;</span>, last: &#123; (a) <span class="keyword">in</span></span><br><span class="line">    a.update &#123; (vm) <span class="keyword">in</span></span><br><span class="line">        vm.scene = .success</span><br><span class="line">        vm.title = <span class="string">&quot;同步成功&quot;</span></span><br><span class="line">        vm.message = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight swift"><figcaption><span>示例2：获取刚才弹出的Loading，把它更新为加载失败，并增加重试按钮。</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">Alert</span>.<span class="built_in">find</span>(<span class="string">&quot;loading&quot;</span>, last: &#123; (a) <span class="keyword">in</span></span><br><span class="line">    a.update &#123; (vm) <span class="keyword">in</span></span><br><span class="line">        vm.scene = .error</span><br><span class="line">        vm.title = <span class="string">&quot;同步失败&quot;</span></span><br><span class="line">        vm.message = <span class="string">&quot;请检查网络是否连接&quot;</span></span><br><span class="line">        vm.add(action: .<span class="keyword">default</span>, title: <span class="string">&quot;重试&quot;</span>) &#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">        vm.add(action: .cancel, title: <span class="string">&quot;取消&quot;</span>, handler: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="极端场景"><a href="#极端场景" class="headerlink" title="极端场景"></a>极端场景</h3><p>很多库没有多实例管理，很容易出现简单粗暴的视图重叠现象，ProHUD 针对不同场景做了不同的优化，对于横幅来说，可以平铺显示，像系统的通知中心一样，你可以拖拽向上移除。对于弹窗来说，我给底层的弹窗做了景深效果处理，使得看起来不像是 BUG。</p><div class="tag link"><a class="link-card" title="文档" href="/wiki/prohud/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/256/safari.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/256/safari.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></div><div class="right"><p class="text">文档</p><p class="url">/wiki/prohud/</p></div></a></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;简单易用，完全可定制化的 HUD&lt;/strong&gt;&lt;br&gt;ProHUD = Toast（通知横幅） + Alert（ProgressHUD、弹窗） + ActionSheet（操作表）&lt;/p&gt;
&lt;p&gt;在写「ProHUD」之前我已经在「AXKit」中实现了原生控件快速构造方法、为公司写了 ObjC 版的可定制化 HUD、Swift 版的开源的 NoticeBoard（通知横幅）。ProHUD 诞生的意义就在于取代这些不那么完善的 HUD。&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发" scheme="https://xaoxuu.com/blog/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="https://xaoxuu.com/blog/tags/ios/"/>
    
      <category term="开源库" scheme="https://xaoxuu.com/blog/tags/%E5%BC%80%E6%BA%90%E5%BA%93/"/>
    
      <category term="Swift" scheme="https://xaoxuu.com/blog/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>心率管家 App 的设计与开发流程</title>
    <link href="https://xaoxuu.com/blog/2019-07-23-heartmate/"/>
    <id>https://xaoxuu.com/blog/2019-07-23-heartmate/</id>
    <published>2019-07-22T16:00:00.000Z</published>
    <updated>2020-08-31T01:38:59.527Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>近期开发并上架了新版心率管家 App（仅 iOS 端），专业版不定期限免，欢迎下载体验。本文将从设计、开发、上架等每个步骤和细节进行分享，也包含部分模块源码。</p><div class="btns circle center grid5">            <a href='https://apps.apple.com/cn/app/heart-mate-pro-hrm-utility/id1463348922?ls=1'>  <i class='fab fa-apple'></i>  <b>心率管家</b>  <p class='p red'>专业版</p>  <img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/heartmate_pro.png'></a><a href='https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1'>  <i class='fab fa-apple'></i>  <b>心率管家</b>  <p class='p green'>免费版</p>  <img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/heartmate_lite.png'></a>          </div><a id="more"></a><h2 id="立项"><a href="#立项" class="headerlink" title="立项"></a>立项</h2><h3 id="确定需求"><a href="#确定需求" class="headerlink" title="确定需求"></a>确定需求</h3><p>立项的初衷是满足随时测心率的需求（没有智能手环手表的人群），App 核心功能就是测量心率，围绕这个功能展开的是测量时更多细节的记录、对已有数据的筛选。再往深度挖掘的是数据分析、健康预测。</p><h3 id="市场考察"><a href="#市场考察" class="headerlink" title="市场考察"></a>市场考察</h3><p>虽然 AppStore 已有，但是无一例外都特别丑，要么收费要么有广告，所以不如自己做一个。</p><h3 id="测量原理"><a href="#测量原理" class="headerlink" title="测量原理"></a>测量原理</h3><p><strong>光电容积脉搏波描记法（PPG）</strong></p><p>是追踪可见光（通常为绿光）在人体组织中的反射。它具备一个可见光光源来照射皮肤，再使用光电传感器采集被皮肤反射回来的光线。PPG 有两种模式，透射式和反射式，像一般的手环手表这样，光源和传感器在同一侧的，就是反射式；而医院中常见的夹在指尖上的通常是透射式的，即光源和传感器在不同侧。 皮肤本身对光线的反射能力是相对稳定的，但是心脏泵血使得血管容积周期性地变化，导致反射光也呈现出周期性的波动值，特别是在指尖这种毛细血管非常丰富的部位，这种周期性的波动很容易被观察到。</p><p>Wikipedia: <a href="https://en.wikipedia.org/wiki/Photoplethysmogram" target="_blank" rel="noopener external nofollow noreferrer">#Photoplethysmogram</a></p><p>对应到 App 上就是通过分析摄像头每一帧画面的色值，计算出颜色波动的频率，即为近似心率。</p><h3 id="定价策略"><a href="#定价策略" class="headerlink" title="定价策略"></a>定价策略</h3><ul><li>付费版：价格波动，通过降价和限免吸引爬虫收录。</li><li>免费版：限制了部分个性化功能，核心功能不受影响，没有任何广告。</li></ul><h3 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h3><p>语言：Swift5<br>设计模式：MVC<br>路由方案：JLRoutes<br>主题和UI管理：Inspire<br>缓存方案：SQLite<br>数据同步方案：暂定AppleHealth</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>初期使用 Sketch 制作效果图，在后期直接在项目中进行调整，没有再更新到 Sketch 中。下面这是最终发布到 AppStore 的应用截图：</p><div class="gallery ">              <img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/proj/heartmate/screenshot01.jpg'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/proj/heartmate/screenshot02.jpg'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/proj/heartmate/screenshot03.jpg'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/proj/heartmate/screenshot04.jpg'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/proj/heartmate/screenshot05.jpg'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/proj/heartmate/screenshot06.jpg'>            </div><h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><h3 id="心率测量组件"><a href="#心率测量组件" class="headerlink" title="心率测量组件"></a>心率测量组件</h3><p>心率测量功能开发为一个私有库，具体实现稍后补充。。。</p><h3 id="可定制UI"><a href="#可定制UI" class="headerlink" title="可定制UI"></a>可定制UI</h3><p>使用 <span class='btn'><a class="button" href='https://xaoxuu.com/wiki/inspire/' title='Inspire'>Inspire</a></span> 作为主题管理器，目前暂未支持主题切换，后续更新会加入。</p><h3 id="快捷指令"><a href="#快捷指令" class="headerlink" title="快捷指令"></a>快捷指令</h3><p>使用 JLRoutes 路由方案，目前支持 URLSchemes 启动并开始测量，可接受两个参数：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接启动</span></span><br><span class="line">heartmatepro:<span class="comment">//record</span></span><br><span class="line"><span class="comment">// 自定义补光灯亮度（亮度值 l 为浮点数，取值范围是0~1）</span></span><br><span class="line">heartmatepro:<span class="comment">//record?l=0.3</span></span><br><span class="line"><span class="comment">// 自定义补光灯亮度和测量样本容器大小（样本容器大小 c 为正整数，取值范围是1~20）</span></span><br><span class="line">heartmatepro:<span class="comment">//record?l=0.1&amp;c=10</span></span><br></pre></td></tr></table></figure><p>免费版限制了自定义亮度，但是你依然可以通过这种方式来自定义。</p><h3 id="ProHUD"><a href="#ProHUD" class="headerlink" title="ProHUD"></a>ProHUD</h3><p>使用 <span class='btn'><a class="button" href='https://xaoxuu.com/wiki/prohud/' title='ProHUD'>ProHUD</a></span> 来负责弹窗和操作表，包括隐私政策页面。</p><div class="gallery ">              <img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/proj/heartmate/screenshot21.png'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/proj/heartmate/screenshot22.png'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/proj/heartmate/screenshot23.png'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/proj/heartmate/screenshot24.png'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/proj/heartmate/screenshot25.png'>            </div><h2 id="上架"><a href="#上架" class="headerlink" title="上架"></a>上架</h2><p>新建应用，填写名称、BundleId 等资料，然后在 App 页面填写描述、网址、隐私政策链接、上传截图、确定分级……</p><p>待应用通过 testflight 测试无误后，打包上传。然后过几分钟 appstoreconnect 页面就可以选中刚才上传的包了，然后提交审核，第二天就审核通过。（现在 AppStore 新应用审核也太快了）</p><div class="tag link"><a class="link-card" title="App Store Connect" href="https://appstoreconnect.apple.com"><div class="left"><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets@master/logo/256/safari.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets@master/logo/256/safari.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></div><div class="right"><p class="text">App Store Connect</p><p class="url">https://appstoreconnect.apple.com</p></div></a></div><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><h3 id="数据价值"><a href="#数据价值" class="headerlink" title="数据价值"></a>数据价值</h3><p>后续迭代中会在测量详情页面下方的留白处加上【标签】、【备注】、【数据分析】模块，前两者利于检索数据，数据分析目前没有能力独自完成，计划使用第三方服务。</p><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><p><strong>图标</strong><br>这是一次彻底重做，所以也可以算是初版。很多细节还比较粗糙，例如图标没有经过打磨，设置列表连图标都没有。</p><p><strong>占位图</strong><br>很多页面在没有数据的时候也没有占位的图片，这个也会慢慢完善。</p><p><strong>心率区间</strong><br>心率卡片的颜色、心率卡片右上角以及归档页面心率的底部的彩色长条代表的是当前所处的心率区间，App 中并没有说明，后续迭代中也会完善这里。并且心率区间的划分需要年龄和性别，这个也会在后期进行完善。</p><h2 id="附：开源库"><a href="#附：开源库" class="headerlink" title="附：开源库"></a>附：开源库</h2><p>App 不开源，但是 App 使用的很多模块是开源的，自己开发的模块也上传至 GitHub 了。（App 的关于页面可以看到）</p><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/xaoxuu/ProHUD"><img src="https://github-readme-stats.vercel.app/api/pin/?username=xaoxuu&repo=ProHUD&show_owner=true" class="lazyload" data-srcset="https://github-readme-stats.vercel.app/api/pin/?username=xaoxuu&repo=ProHUD&show_owner=true" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></a> <a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/xaoxuu/Inspire"><img src="https://github-readme-stats.vercel.app/api/pin/?username=xaoxuu&repo=Inspire&show_owner=true" class="lazyload" data-srcset="https://github-readme-stats.vercel.app/api/pin/?username=xaoxuu&repo=Inspire&show_owner=true" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></a><p><strong>第三方库：</strong></p><div class="table"><table><thead><tr><th align="left">第三方库</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">RxSwift</td><td align="left">响应式编程框架</td></tr><tr><td align="left">JLRoutes</td><td align="left">路由</td></tr><tr><td align="left">SnapKit</td><td align="left">自动布局</td></tr><tr><td align="left">SQLite.swift</td><td align="left">SQLite数据库管理</td></tr><tr><td align="left">STDPickerView</td><td align="left">选择器控件</td></tr><tr><td align="left">Bugly</td><td align="left">BUG追踪</td></tr></tbody></table></div><p><strong>第三方服务：</strong></p><div class="table"><table><thead><tr><th align="left">第三方服务</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left"><a href="https://unsplash.com/" target="_blank" rel="noopener external nofollow noreferrer">Unsplash</a></td><td align="left">免费图片</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期开发并上架了新版心率管家 App（仅 iOS 端），专业版不定期限免，欢迎下载体验。本文将从设计、开发、上架等每个步骤和细节进行分享，也包含部分模块源码。&lt;/p&gt;
&lt;div class=&quot;btns circle center grid5&quot;&gt;
            &lt;a href=&#39;https://apps.apple.com/cn/app/heart-mate-pro-hrm-utility/id1463348922?ls=1&#39;&gt;
  &lt;i class=&#39;fab fa-apple&#39;&gt;&lt;/i&gt;
  &lt;b&gt;心率管家&lt;/b&gt;
  &lt;p class=&#39;p red&#39;&gt;专业版&lt;/p&gt;
  &lt;img src=&#39;https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/heartmate_pro.png&#39;&gt;
&lt;/a&gt;
&lt;a href=&#39;https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1&#39;&gt;
  &lt;i class=&#39;fab fa-apple&#39;&gt;&lt;/i&gt;
  &lt;b&gt;心率管家&lt;/b&gt;
  &lt;p class=&#39;p green&#39;&gt;免费版&lt;/p&gt;
  &lt;img src=&#39;https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/heartmate_lite.png&#39;&gt;
&lt;/a&gt;
          &lt;/div&gt;
    
    </summary>
    
    
      <category term="开发" scheme="https://xaoxuu.com/blog/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="https://xaoxuu.com/blog/tags/ios/"/>
    
      <category term="Swift" scheme="https://xaoxuu.com/blog/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>Inspire：Swift 语言的 UI 开发工具包</title>
    <link href="https://xaoxuu.com/blog/2019-03-26-inspire/"/>
    <id>https://xaoxuu.com/blog/2019-03-26-inspire/</id>
    <published>2019-03-25T16:00:00.000Z</published>
    <updated>2019-03-25T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>包含颜色、字体、布局等，可配置可缓存，非常适合独立开发者。</p><a id="more"></a><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/xaoxuu/Inspire"><img src="https://github-readme-stats.vercel.app/api/pin/?username=xaoxuu&repo=Inspire&show_owner=true" class="lazyload" data-srcset="https://github-readme-stats.vercel.app/api/pin/?username=xaoxuu&repo=Inspire&show_owner=true" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></a><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="可缓存的"><a href="#可缓存的" class="headerlink" title="可缓存的"></a>可缓存的</h3><ul><li>App的样式参数（颜色、字体、布局）存储于json文件中。</li></ul><h3 id="可配置的"><a href="#可配置的" class="headerlink" title="可配置的"></a>可配置的</h3><ul><li>可由用户修改主题参数并保存或者分享。</li></ul><h3 id="提供便利"><a href="#提供便利" class="headerlink" title="提供便利"></a>提供便利</h3><ul><li>便捷的方式获取屏幕布局参数、如各边安全区域尺寸，便于机型适配。</li></ul><h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod &#39;Inspire&#39;</span><br></pre></td></tr></table></figure><h2 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h2><h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">view.backgroundColor = .background</span><br><span class="line">view.tintColor = .accent</span><br></pre></td></tr></table></figure><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> lb = <span class="type">UILabel</span>()</span><br><span class="line">lb.font = .regular(<span class="number">15</span>)</span><br><span class="line">lb.font = .bold(<span class="number">20</span>, <span class="keyword">for</span>: .title)</span><br><span class="line">lb.font = .regular(<span class="number">14</span>, <span class="keyword">for</span>: .code)</span><br></pre></td></tr></table></figure><h3 id="边距"><a href="#边距" class="headerlink" title="边距"></a>边距</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> topMargin = layout.topBarHeight(<span class="keyword">for</span>: <span class="keyword">self</span>)</span><br><span class="line"><span class="keyword">let</span> bottomMargin = layout.bottomBarHeight(<span class="keyword">for</span>: <span class="keyword">self</span>)</span><br><span class="line"><span class="keyword">let</span> safeArea = layout.safeAreaInsets(<span class="keyword">for</span>: <span class="keyword">self</span>)</span><br><span class="line"><span class="keyword">let</span> safeArea2 = <span class="type">Inspire</span>.shared.screen.safeAreaInsets</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> layout = <span class="type">Inspire</span>.shared.layout</span><br><span class="line">view.frame.size.height = layout.rowHeight</span><br><span class="line">view.layer.cornerRadius = layout.cornerRadius.large</span><br></pre></td></tr></table></figure><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存</span></span><br><span class="line"><span class="type">Inspire</span>.shared.cache()</span><br><span class="line"><span class="type">Inspire</span>.shared.cache(named: <span class="string">&quot;myTheme&quot;</span>)</span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line"><span class="keyword">let</span> ipr = <span class="type">Inspire</span>.<span class="keyword">init</span>(<span class="string">&quot;myTheme&quot;</span>)</span><br></pre></td></tr></table></figure><div class="tag link"><a class="link-card" title="文档" href="/wiki/inspire/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/256/safari.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/256/safari.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></div><div class="right"><p class="text">文档</p><p class="url">/wiki/inspire/</p></div></a></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;包含颜色、字体、布局等，可配置可缓存，非常适合独立开发者。&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发" scheme="https://xaoxuu.com/blog/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="https://xaoxuu.com/blog/tags/ios/"/>
    
      <category term="开源库" scheme="https://xaoxuu.com/blog/tags/%E5%BC%80%E6%BA%90%E5%BA%93/"/>
    
      <category term="Swift" scheme="https://xaoxuu.com/blog/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>iOS 组件化、模块化与路由方案探索</title>
    <link href="https://xaoxuu.com/blog/2018-11-19-ios-uncoupling/"/>
    <id>https://xaoxuu.com/blog/2018-11-19-ios-uncoupling/</id>
    <published>2018-11-18T16:00:00.000Z</published>
    <updated>2018-11-18T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>我们公司养老业务线使用的组件化方案是 CTMediator ，而我在此之前没有了解过相关方案，借此机会学习 CTMediator 以及相关解耦措施。</p><a id="more"></a><h2 id="组件与模块"><a href="#组件与模块" class="headerlink" title="组件与模块"></a>组件与模块</h2><p>“组件”强调的是复用，它被各个模块或组件直接依赖，是基础设施，它一般不包含业务或者包含弱业务，属于纵向分层（比如网络请求组件、图片下载组件）。</p><p>“模块”强调的是封装，它更多的是指功能独立的业务模块，属于横向分层（比如购物车模块、个人中心模块）。</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://gitee.com/xaoxuu/cdn-assets/raw/master/blog/2018-1119a@2x.svg" class="lazyload" data-srcset="https://gitee.com/xaoxuu/cdn-assets/raw/master/blog/2018-1119a@2x.svg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="width:200px;"/></div></div><p>模块化需要提供多个库之间的服务调用并保持库与库之间的独立、非强依赖。</p><p>总的来说，模块化的重点还是如何去除多个模块之间的耦合，让每个模块在不强依赖的情况下可以调用其他模块的服务。现在在开源的方案中有以下三种方案被广泛使用。</p><ul><li>利用 <code>URL—Scheme</code> 注册</li><li>利用 <code>Protocol-Class</code> 注册</li><li>利用 Runtime 实现的 <code>Target-Action</code> 方法</li></ul><p>并各自有比较成熟的第三方库可供使用。</p><div class="tabs" id="about"><ul class="nav-tabs"><li class="tab active"><a href="#about-1">URL—Scheme 库</a></li><li class="tab"><a href="#about-2">Target-Action 库</a></li></ul><div class="tab-content"><div class="tab-pane active" id="about-1"><ul><li>JLRoutes</li><li>routable-ios</li><li>HHRouter</li><li>MGJRouter</li></ul></div><div class="tab-pane" id="about-2"><ul><li>CTMediator</li></ul></div></div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们公司养老业务线使用的组件化方案是 CTMediator ，而我在此之前没有了解过相关方案，借此机会学习 CTMediator 以及相关解耦措施。&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发" scheme="https://xaoxuu.com/blog/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="https://xaoxuu.com/blog/tags/ios/"/>
    
      <category term="解耦" scheme="https://xaoxuu.com/blog/tags/%E8%A7%A3%E8%80%A6/"/>
    
  </entry>
  
  <entry>
    <title>iOS 常见内存泄漏及解决方案</title>
    <link href="https://xaoxuu.com/blog/2018-10-15-ios-memory-leak/"/>
    <id>https://xaoxuu.com/blog/2018-10-15-ios-memory-leak/</id>
    <published>2018-10-14T16:00:00.000Z</published>
    <updated>2018-10-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>内存泄漏是开发中经常会遇到和需要处理的问题，如：循环引用、僵尸对象和野指针、大循环内存峰值。</p><a id="more"></a><h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><p>即对象A强引用对象B，对象B强引用对象A，或者多个对象强引用形成一个闭环。block会对内部使用的对象进行强引用，因此在使用的时候应该确定不会引起循环引用。</p><p><strong>解决方案：</strong></p><p>使用弱引用或主动断开循环。</p><h3 id="示例1：block"><a href="#示例1：block" class="headerlink" title="示例1：block"></a>示例1：block</h3><p>导致内存泄漏的代码（action block中的self）：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.block = ^&#123;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, <span class="keyword">self</span>.name);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">self</span>.block();</span><br></pre></td></tr></table></figure><p>改成这样可以正常dealloc：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line"><span class="keyword">self</span>.block = ^&#123;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) strongSelf = weakSelf;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, strongSelf.name);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">self</span>.block();</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__block <span class="built_in">UIViewController</span> *vc = <span class="keyword">self</span>;</span><br><span class="line"><span class="keyword">self</span>.block = ^&#123;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, vc.name);</span><br><span class="line">        vc = <span class="literal">nil</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">self</span>.block();</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.block = ^(<span class="built_in">UIViewController</span> *vc)&#123;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, vc.name);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">self</span>.block(<span class="keyword">self</span>);</span><br></pre></td></tr></table></figure><h3 id="示例2：NSTimer"><a href="#示例2：NSTimer" class="headerlink" title="示例2：NSTimer"></a>示例2：NSTimer</h3><p>NSTimer会造成循环引用，timer会强引用target即self，一般self又会持有timer作为属性，这样就造成了循环引用。<br>那么，如果timer只作为局部变量，不把timer作为属性呢？同样释放不了，因为在加入runloop的操作中，timer被强引用。而timer作为局部变量，是无法执行invalidate的，所以在timer被invalidate之前，self也就不会被释放。<br>所以我们要注意，不仅仅是把timer当作实例变量的时候会造成循环引用，只要申请了timer，加入了runloop，并且target是self，虽然不是循环引用，但是self却没有释放的时机。如下方式申请的定时器，self已经无法释放了。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">5</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(commentAnimation) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br></pre></td></tr></table></figure><p>解决这种问题有几个实现方式，大家可以根据具体场景去选择：</p><ul><li>增加startTimer和stopTimer方法，在合适的时机去调用，比如可以在viewDidDisappear时stopTimer，或者由这个类的调用者去设置。</li><li>每次任务结束时使用dispatch_after方法做延时操作。注意使用weakself，否则也会强引用self。<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)startAnimation</span><br><span class="line">&#123;</span><br><span class="line">    WS(weakSelf);</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">5</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [weakSelf commentAnimation];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>使用GCD的定时器，同样注意使用weakself。<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">WS(weakSelf);</span><br><span class="line">timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, dispatch_get_main_queue());</span><br><span class="line">dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, <span class="number">5</span> * <span class="built_in">NSEC_PER_SEC</span>, <span class="number">1</span> * <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line">dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">    [weakSelf commentAnimation];</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_resume(timer);</span><br></pre></td></tr></table></figure></li></ul><h3 id="示例3：NSNotification"><a href="#示例3：NSNotification" class="headerlink" title="示例3：NSNotification"></a>示例3：NSNotification</h3><p>使用block的方式增加notification，引用了self，在删除notification之前，self不会被释放，与timer的场景类似，其实这段代码已经声明了weakself，但是调用_eventManger方法还是引起了循环引用。<br>也就是说，即使我们没有调用self方法，_xxx也会造成循环引用。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserverForName:kUserSubscribeNotification object:<span class="literal">nil</span> queue:<span class="literal">nil</span> usingBlock:^(<span class="built_in">NSNotification</span> *note) &#123;</span><br><span class="line">    <span class="keyword">if</span> (note) &#123;</span><br><span class="line">        Model *model=(Model *)note.object;</span><br><span class="line">        <span class="keyword">if</span> ([model.subId integerValue] == [weakSelf.subId integerValue]) &#123;</span><br><span class="line">            [_eventManger playerSubsciption:<span class="literal">NO</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="僵尸对象和野指针"><a href="#僵尸对象和野指针" class="headerlink" title="僵尸对象和野指针"></a>僵尸对象和野指针</h2><p>僵尸对象是指内存已经被回收的对象，指向僵尸对象的指针就是野指针，向野指针发送消息会导致崩溃：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EXC_BAD_ACCESS</span><br></pre></td></tr></table></figure><p><strong>解决方案：</strong></p><p>当对象释放后，应该将其置为nil。</p><h2 id="大循环内存峰值"><a href="#大循环内存峰值" class="headerlink" title="大循环内存峰值"></a>大循环内存峰值</h2><p>循环内产生大量的临时对象，直至循环结束才释放，可能导致内存泄漏。</p><p><strong>解决方案：</strong></p><p>在循环中创建自己的autoreleasepool，及时释放占用内存大的临时变量，减少内存占用峰值。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSNumber</span> *num = [<span class="built_in">NSNumber</span> numberWithInt:i];</span><br><span class="line">        [num performOperationOnNumber];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用Instruments工具检查内存泄漏"><a href="#使用Instruments工具检查内存泄漏" class="headerlink" title="使用Instruments工具检查内存泄漏"></a>使用Instruments工具检查内存泄漏</h2><p>打开Instruments：</p><div class="gallery ">              <img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/2018/827fb4fa7c3203ca4690109766ae23754c1f0c.jpg'>            </div><p>内存泄漏时：</p><div class="gallery ">              <img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/2018/88e108233106f8172dc603758739887ec29925.jpg'>            </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;内存泄漏是开发中经常会遇到和需要处理的问题，如：循环引用、僵尸对象和野指针、大循环内存峰值。&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发" scheme="https://xaoxuu.com/blog/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="https://xaoxuu.com/blog/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>使用 NoticeBoard 迅捷而优雅地发布通知</title>
    <link href="https://xaoxuu.com/blog/2018-07-30-noticeboard/"/>
    <id>https://xaoxuu.com/blog/2018-07-30-noticeboard/</id>
    <published>2018-07-29T16:00:00.000Z</published>
    <updated>2019-08-26T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>此项目已经停止维护，请使用功能更强大的 <a href="https://xaoxuu.com/wiki/prohud">ProHUD</a> 。</p><a id="more"></a><br><p>Android 有原生的 <a href="https://wiki.jikexueyuan.com/project/material-design/components/snackbars-and-toasts.html" target="_blank" rel="noopener external nofollow noreferrer">SnackBar</a> ，iOS 没有与之相似的原生控件，GitHub 上好像也没有找到特别好用的开源库。</p><p>既然在 Android 平台上能够作为原生控件存在，足以说明这种需求不算太不小众，在 iOS 端，类似的需求可能被 UIAlertController、MBProgressHUD 来替代，但是他们都需要打断用户当前正在进行的事情，体验很不好。GitHub 上有一个开源库 NoticeBar ，模仿QQ的实现效果，虽然有200+的Star，个人感觉 UI 和可定制性都不够理想，于是自己写了一个模仿系统原生通知样式的易于定制的 <a href="https://github.com/xaoxuu/NoticeBoard" target="_blank" rel="noopener external nofollow noreferrer">NoticeBoard</a>，下面请看截图和演示效果：</p><p>NoticeBoard 的功能定位是应用内消息控件，相对于系统通知，它显而易见的优点是：<strong>简单易用</strong>、<strong>可定制性强</strong>，相对于原生的 UIAlertController 和开源的 MBProgressHUD ，它的优点是专为这种特定场景而生：<strong>只需要告诉用户发生了什么，不必立即处理</strong>，或者可以 <strong>稍后再处理</strong>。</p><h2 id="演示如何使用"><a href="#演示如何使用" class="headerlink" title="演示如何使用"></a>演示如何使用</h2><p>强烈建议感兴趣的朋友亲自下载 <a href="https://github.com/xaoxuu/NoticeBoard" target="_blank" rel="noopener external nofollow noreferrer">源码</a> 运行 <code>Example</code> 项目，因为项目中提供了大量的演示程序，通过这些演示你可以清楚地了解到使用方法及其效果。</p><h2 id="导入-NoticeBoard"><a href="#导入-NoticeBoard" class="headerlink" title="导入 NoticeBoard"></a>导入 NoticeBoard</h2><p>如果要在工程项目中使用NoticeBoard，需要在 <code>Podfile</code> 中添加这一行：</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">pod <span class="string">&#x27;NoticeBoard&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="快速-post-示例"><a href="#快速-post-示例" class="headerlink" title="快速 post 示例"></a>快速 post 示例</h2><p>最简单的，你可以直接发送一条 &quot;Hello World!&quot; ：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NoticeBoard</span>.post(<span class="string">&quot;Hello World!&quot;</span>)</span><br></pre></td></tr></table></figure><p>用户可以像移除系统原生通知那样拖拽一条通知往上方移动丢出屏幕外，如果你希望消息自动消失，需要传入消息的持续时间：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NoticeBoard</span>.post(<span class="string">&quot;Hello World!&quot;</span>, duration: <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>或者直接发出一条警告消息：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NoticeBoard</span>.post(.warning, title: <span class="string">&quot;电量过低&quot;</span>, message: <span class="string">&quot;电量不足10%，请及时给设备充电。&quot;</span>, duration: <span class="number">10</span>)</span><br></pre></td></tr></table></figure><h2 id="标准-post-步骤"><a href="#标准-post-步骤" class="headerlink" title="标准 post 步骤"></a>标准 post 步骤</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建notice</span></span><br><span class="line"><span class="keyword">let</span> notice = <span class="type">Notice</span>.<span class="keyword">init</span>(title: <span class="string">&quot;标题&quot;</span>, icon: <span class="type">UIImage</span>.<span class="keyword">init</span>(named: <span class="string">&quot;alert-&quot;</span>), body: <span class="string">&quot;正文&quot;</span>)</span><br><span class="line"><span class="comment">// 设置notice</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 发布notice       </span></span><br><span class="line"><span class="type">NoticeBoard</span>.shared.post(notice, duration: <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>设置notice</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按钮事件</span></span><br><span class="line">notice.actionButtonDidTapped &#123; (notice, btn) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;点击了&#x27;→&#x27;按钮&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置颜色主题</span></span><br><span class="line">notice.themeColor = .<span class="keyword">init</span>(red: <span class="number">0.2</span>, green: <span class="number">0.3</span>, blue: <span class="number">0.4</span>, alpha: <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 模糊背景（暂时只支持iOS11，在之前的系统会自动改为纯色背景），和纯色背景可以同时使用</span></span><br><span class="line">notice.blurEffectStyle = .light</span><br></pre></td></tr></table></figure><p>还有更多设置，例如：警示（alert）、禁止被用户通过手势移除、设置正文最大高度等。</p><p>移除通知</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 移除某个通知</span></span><br><span class="line"><span class="type">NoticeBoard</span>.shared.remove(notice)</span><br><span class="line"><span class="comment">// 清空</span></span><br><span class="line"><span class="type">NoticeBoard</span>.shared.clean()</span><br></pre></td></tr></table></figure><h2 id="post-进度"><a href="#post-进度" class="headerlink" title="post 进度"></a>post 进度</h2><p>设置任意一条 <code>notice</code> 实例的 <code>progress</code> 属性，即时生效。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 进度为0</span></span><br><span class="line">notice.progress = <span class="number">0</span></span><br><span class="line"><span class="comment">// 进度为50%</span></span><br><span class="line">notice.progress = <span class="number">0.5</span></span><br><span class="line"><span class="comment">// 进度为100%</span></span><br><span class="line">notice.progress = <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="post-自定义-view"><a href="#post-自定义-view" class="headerlink" title="post 自定义 view"></a>post 自定义 view</h2><p>NoticeBoard 开源库提供了极大的自由度，你可以只享受 NoticeBoard 提供的对 Notice 管理策略（post、remove、手势、过渡动画），而不使用现有的 Notice 的默认 UI，做法就是创建一个空白的 Notice 实例，添加自定义的视图。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> notice = <span class="type">Notice</span>()</span><br><span class="line">notice.rootViewController?.view.addSubview(myView)</span><br><span class="line"><span class="type">NoticeBoard</span>.post(notice)</span><br></pre></td></tr></table></figure><blockquote><p>根据这一特性，你可以继承 Notice ，重写初始化方法， 从而创建符合公司内部 UI 要求的 Notice 。</p></blockquote><h2 id="多个通知的布局"><a href="#多个通知的布局" class="headerlink" title="多个通知的布局"></a>多个通知的布局</h2><p>如果同一时间需要存在多个通知，可以根据使用场景选择不同的布局方式：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 平铺，默认（所有通知都可见，但是通知过多会超出屏幕）</span></span><br><span class="line"><span class="type">NoticeBoard</span>.shared.layoutStyle = .tile</span><br><span class="line"><span class="type">NoticeBoard</span>.shared.post(notice, duration: <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取代旧的通知（旧的采用fade动画淡出）</span></span><br><span class="line"><span class="type">NoticeBoard</span>.shared.layoutStyle = .replace</span><br><span class="line"><span class="type">NoticeBoard</span>.shared.post(notice, duration: <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除旧的通知（旧的采用moveout动画移出屏幕）</span></span><br><span class="line"><span class="type">NoticeBoard</span>.shared.layoutStyle = .remove</span><br><span class="line"><span class="type">NoticeBoard</span>.shared.post(notice, duration: <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆盖在旧的通知上层（切勿堆积过多）</span></span><br><span class="line"><span class="type">NoticeBoard</span>.shared.layoutStyle = .overlay</span><br><span class="line"><span class="type">NoticeBoard</span>.shared.post(notice, duration: <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆叠（最新的通知会遮挡旧的通知）</span></span><br><span class="line"><span class="type">NoticeBoard</span>.shared.layoutStyle = .stack</span><br><span class="line"><span class="type">NoticeBoard</span>.shared.post(notice, duration: <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="设置Level"><a href="#设置Level" class="headerlink" title="设置Level"></a>设置Level</h2><p>默认提供了四种level：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// case low = 4000</span></span><br><span class="line"><span class="comment">// case normal = 4100</span></span><br><span class="line"><span class="comment">// case high = 4200</span></span><br><span class="line"><span class="comment">// case veryHigh = 4300</span></span><br><span class="line">notice.level = .normal</span><br></pre></td></tr></table></figure><p>也可以直接设置任意数值：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">notice.windowLevel = <span class="number">1000</span></span><br></pre></td></tr></table></figure><h2 id="在Swift和Objective-C中使用"><a href="#在Swift和Objective-C中使用" class="headerlink" title="在Swift和Objective-C中使用"></a>在Swift和Objective-C中使用</h2><p>NoticeBoard使用 <code>Swift4.1</code> 语言编写，如需在 <code>Objective-C</code> 项目中使用，可以采用 <code>Objective-C</code> 和 <code>Swift</code> 混编的方式。</p><h2 id="源码和文档链接"><a href="#源码和文档链接" class="headerlink" title="源码和文档链接"></a>源码和文档链接</h2><p>此项目已经停止维护，请使用功能更强大的<a href="https://xaoxuu.com/wiki/prohud">ProHUD</a>。</p><blockquote><p>项目源码：<a href="https://github.com/xaoxuu/NoticeBoard" target="_blank" rel="noopener external nofollow noreferrer">https://github.com/xaoxuu/NoticeBoard</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此项目已经停止维护，请使用功能更强大的 &lt;a href=&quot;https://xaoxuu.com/wiki/prohud&quot;&gt;ProHUD&lt;/a&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发" scheme="https://xaoxuu.com/blog/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="https://xaoxuu.com/blog/tags/ios/"/>
    
      <category term="开源库" scheme="https://xaoxuu.com/blog/tags/%E5%BC%80%E6%BA%90%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>iOS 使用 CocoaAsyncSocket 进行通信</title>
    <link href="https://xaoxuu.com/blog/2018-07-05-ios-socket/"/>
    <id>https://xaoxuu.com/blog/2018-07-05-ios-socket/</id>
    <published>2018-07-14T16:00:00.000Z</published>
    <updated>2018-08-05T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>网络由下往上分为：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。</p><p>IP协议对应于网络层，TCP协议对应于传输层，HTTP协议对应于应用层，三者从本质上来说没有可比性，Socket则是对TCP/IP协议的封装和应用。也可以说，TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。</p><p>CocoaAsyncSocket是一个十分好用的异步Socket库，本文将以CocoaAsyncSocket作为工具进行网络通信的操作，Demo源码链接在文章末尾。</p><a id="more"></a><h2 id="TCP的三次握手与四次挥手"><a href="#TCP的三次握手与四次挥手" class="headerlink" title="TCP的三次握手与四次挥手"></a>TCP的三次握手与四次挥手</h2><h3 id="连接过程：三次握手"><a href="#连接过程：三次握手" class="headerlink" title="连接过程：三次握手"></a>连接过程：三次握手</h3><ol><li>客户端发送SYN包(SYN=j)到服务器，并进入SYN_SEND状态，等待服务器确认;</li><li>服务器收到SYN包，必须确认客户的SYN(ACK=j+1)，同时自己也发送一个SYN包(SYN=k)，即SYN+ACK包，此时服务器进入SYN_RECV状态;</li><li>客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ACK=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</li></ol><p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p><h3 id="关闭过程：四次挥手"><a href="#关闭过程：四次挥手" class="headerlink" title="关闭过程：四次挥手"></a>关闭过程：四次挥手</h3><ol><li>客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送(报文段4)。</li><li>服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1(报文段5)。和SYN一样，一个FIN将占用一个序号。</li><li>服务器B关闭与客户端A的连接，发送一个FIN给客户端A(报文段6)。</li><li>客户端A发回ACK报文确认，并将确认序号设置为收到序号加1(报文段7)。</li></ol><h2 id="HTTP连接的特点"><a href="#HTTP连接的特点" class="headerlink" title="HTTP连接的特点"></a>HTTP连接的特点</h2><p>HTTP协议即超文本传送协议(Hypertext Transfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。<br>HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。</p><h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><ul><li>TCP协议是有连接而UDP是无连接的。有连接的意思是开始传输实际数据之前TCP的客户端和服务器端必须通过三次握手建立连接，会话结束之后也要结束连接。</li><li>TCP协议保证数据按序发送，按序到达，提供超时重传来保证可靠性，但是UDP不保证按序到达，甚至不保证到达，只是努力交付，即便是按序发送的序列，也不保证按序送到。</li><li>TCP协议所需资源多，TCP首部需20个字节（不算可选项），UDP首部字段只需8个字节。</li><li>TCP有流量控制和拥塞控制，UDP没有，网络拥堵不会影响发送端的发送速率。</li><li>TCP是一对一的连接，而UDP则可以支持一对一，多对多，一对多的通信。</li><li>TCP面向的是字节流的服务，UDP面向的是报文的服务。</li></ul><p><strong>各自的应用场景</strong></p><ul><li>简短信息适合用UDP实现，因为UDP是基于报文段的，它直接对上层应用对数据封装成报文段，然后丢在网络中，如果信息量太大，会在链路层中被分片，影响传输效率。</li><li>注重性能高于完整性和安全性，适合用UDP，例如多媒体应用，缺一两帧不影响用户体验，但是需要流媒体到达的速度快。</li><li>要求快速响应的场景，如即时通讯聊天。</li><li>TCP适合于注重安全性的场景。</li></ul><h2 id="Demo实战"><a href="#Demo实战" class="headerlink" title="Demo实战"></a>Demo实战</h2><h3 id="UDPSocket"><a href="#UDPSocket" class="headerlink" title="UDPSocket"></a>UDPSocket</h3><p>创建一个 UDPSocket 用于管理 UDP 连接。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UDPSocket</span>: <span class="title">NSObject</span>, <span class="title">GCDAsyncUdpSocketDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> shared = <span class="type">UDPSocket</span>()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> asyncUdpSocket: <span class="type">GCDAsyncUdpSocket</span> = &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">GCDAsyncUdpSocket</span>(delegate: <span class="keyword">self</span>, delegateQueue: <span class="type">DispatchQueue</span>(label: <span class="string">&quot;com.xaoxuu.socket&quot;</span>))</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始或者关闭广播</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> broadcasting = <span class="literal">false</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">broadcast</span><span class="params">(<span class="number">_</span> flag: Bool?)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> f = flag &#123;</span><br><span class="line">        broadcasting = f</span><br><span class="line">        broadcast(<span class="literal">nil</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> broadcasting == <span class="literal">true</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> host = broadcastHost() &#123;</span><br><span class="line">            asyncUdpSocket.send(broadcastData, toHost: host, port: kPort, withTimeout: <span class="number">1000</span>, tag: <span class="number">1</span>)</span><br><span class="line">            <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now()+<span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">self</span>.broadcast(<span class="literal">nil</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>监听收到的数据</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">udpSocket</span><span class="params">(<span class="number">_</span> sock: GCDAsyncUdpSocket, didReceive data: Data, fromAddress address: Data, withFilterContext filterContext: <span class="keyword">Any</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> data == broadcastData &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> host = <span class="type">GCDAsyncUdpSocket</span>.host(fromAddress: address) &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> h = safeHost(host) &#123;</span><br><span class="line">                <span class="keyword">if</span> hosts.<span class="built_in">contains</span>(h) == <span class="literal">false</span> &#123;</span><br><span class="line">                    hosts.append(h)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.post(name: didUpdate, object: hosts)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TCPSocket"><a href="#TCPSocket" class="headerlink" title="TCPSocket"></a>TCPSocket</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> kPort = <span class="type">UInt16</span>(<span class="number">5528</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TCPSocket</span>: <span class="title">NSObject</span>, <span class="title">GCDAsyncSocketDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> shared = <span class="type">TCPSocket</span>()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> asyncSocket: <span class="type">GCDAsyncSocket</span> = &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">GCDAsyncSocket</span>(delegate: <span class="keyword">self</span>, delegateQueue: <span class="type">DispatchQueue</span>(label: <span class="string">&quot;com.xaoxuu.socket&quot;</span>))</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> clientSockets = [<span class="type">GCDAsyncSocket</span>]()</span><br><span class="line">    <span class="keyword">var</span> host = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> port = kPort</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> connectedHosts = [<span class="type">String</span>:<span class="type">String</span>]()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">ConnectCallback</span> = (<span class="type">SocketCharacter</span>, <span class="type">String</span>, <span class="type">Error?</span>) -&gt; <span class="type">Void</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">DisconnectCallback</span> = (<span class="type">SocketCharacter</span>, <span class="type">String?</span>) -&gt; <span class="type">Void</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">ReceiveMessageCallback</span> = (<span class="type">String?</span>, <span class="type">String?</span>) -&gt; <span class="type">Void</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> character = <span class="type">SocketCharacter</span>.server</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> block_onConnect: <span class="type">ConnectCallback?</span></span><br><span class="line">    <span class="keyword">var</span> block_onDisconnect: <span class="type">DisconnectCallback?</span></span><br><span class="line">    <span class="keyword">var</span> block_onReceiveMessage: <span class="type">ReceiveMessageCallback?</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onConnect</span><span class="params">(<span class="number">_</span> callback: @escaping ConnectCallback)</span></span> &#123;</span><br><span class="line">        block_onConnect = callback</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onDisconnect</span><span class="params">(<span class="number">_</span> callback: @escaping DisconnectCallback)</span></span> &#123;</span><br><span class="line">        block_onDisconnect = callback</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onReceiveMessage</span><span class="params">(<span class="number">_</span> callback: @escaping ReceiveMessageCallback)</span></span> &#123;</span><br><span class="line">        block_onReceiveMessage = callback</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">startServer</span><span class="params">(host: String)</span></span> &#123;</span><br><span class="line">        character = <span class="type">SocketCharacter</span>.server</span><br><span class="line">        <span class="keyword">self</span>.host = host</span><br><span class="line">        <span class="keyword">if</span> asyncSocket.isConnected &#123;</span><br><span class="line">            asyncSocket.disconnect()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> asyncSocket.accept(onPort: port)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> f = <span class="keyword">self</span>.block_onConnect &#123;</span><br><span class="line">                f(<span class="keyword">self</span>.character, host, <span class="literal">nil</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">UDPSocket</span>.shared.broadcast(<span class="literal">true</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="built_in">debugPrint</span>(error)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> f = <span class="keyword">self</span>.block_onConnect &#123;</span><br><span class="line">                f(<span class="keyword">self</span>.character, host, error)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">endServer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">let</span> h = <span class="keyword">self</span>.host</span><br><span class="line">        <span class="type">TCPSocket</span>.shared.asyncSocket.disconnect()</span><br><span class="line">        <span class="type">UDPSocket</span>.shared.broadcast(<span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> idx = <span class="type">UDPSocket</span>.shared.hosts.index(of: h) &#123;</span><br><span class="line">            <span class="type">UDPSocket</span>.shared.hosts.remove(at: idx)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">connectServer</span><span class="params">(host: String)</span></span> &#123;</span><br><span class="line">        character = <span class="type">SocketCharacter</span>.client</span><br><span class="line">        <span class="keyword">self</span>.host = host</span><br><span class="line">        <span class="keyword">if</span> asyncSocket.isConnected &#123;</span><br><span class="line">            asyncSocket.disconnect()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> asyncSocket.connect(toHost: host, onPort: port)</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="built_in">debugPrint</span>(error)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> f = <span class="keyword">self</span>.block_onConnect &#123;</span><br><span class="line">                f(<span class="keyword">self</span>.character, host, error)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sendData</span><span class="params">(data: Data)</span></span> &#123;</span><br><span class="line">        asyncSocket.write(data, withTimeout: -<span class="number">1</span>, tag: <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: - delegate</span></span><br><span class="line">    <span class="comment">// 在读取数据之前 服务端还需要监听 客户端有没有写入数据</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">socket</span><span class="params">(<span class="number">_</span> sock: GCDAsyncSocket, didAcceptNewSocket newSocket: GCDAsyncSocket)</span></span> &#123;</span><br><span class="line">        <span class="built_in">debugPrint</span>(<span class="string">&quot;sock: \(sock), newSocket: \(newSocket)&quot;</span>)</span><br><span class="line">        clientSockets.append(newSocket)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> h = newSocket.connectedHost &#123;</span><br><span class="line">            connectedHosts[<span class="type">NSString</span>.pointerDescription()(newSocket)] = h</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        let key = NSString.pointerDescription()(newSocket)</span></span><br><span class="line"><span class="comment">//        if let ip = newSocket.connectedHost &#123;</span></span><br><span class="line"><span class="comment">//            ips[key] = ip</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> f = <span class="keyword">self</span>.block_onConnect &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> ip = newSocket.connectedHost &#123;</span><br><span class="line">                    f(<span class="keyword">self</span>.character, ip, <span class="literal">nil</span>)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    f(<span class="keyword">self</span>.character, <span class="string">&quot;&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 监听客户端是否写入数据</span></span><br><span class="line">        <span class="comment">// timeOut: -1 暂时不需要 超时时间  tag暂时不需要 传0</span></span><br><span class="line">        newSocket.readData(withTimeout: -<span class="number">1</span>, tag: <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务器读取客户端发送数据</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">socket</span><span class="params">(<span class="number">_</span> sock: GCDAsyncSocket, didRead data: Data, withTag tag: Int)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> dataStr = <span class="type">String</span>.<span class="keyword">init</span>(data: data, encoding: <span class="type">String</span>.<span class="type">Encoding</span>.utf8)</span><br><span class="line">        <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> f = <span class="keyword">self</span>.block_onReceiveMessage &#123;</span><br><span class="line">                f(sock.connectedHost, dataStr)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sock.readData(withTimeout: -<span class="number">1</span>, tag: <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">socket</span><span class="params">(<span class="number">_</span> sock: GCDAsyncSocket, didConnectToHost host: String, port: UInt16)</span></span> &#123;</span><br><span class="line">        <span class="built_in">debugPrint</span>(<span class="string">&quot;sock: \(sock) connect to: \(host) port: \(port)&quot;</span>)</span><br><span class="line">        <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> f = <span class="keyword">self</span>.block_onConnect &#123;</span><br><span class="line">                f(<span class="keyword">self</span>.character, host, <span class="literal">nil</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sock.readData(withTimeout: -<span class="number">1</span>, tag: <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">socketDidDisconnect</span><span class="params">(<span class="number">_</span> sock: GCDAsyncSocket, withError err: Error?)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> host = connectedHosts[<span class="type">NSString</span>.pointerDescription()(sock)]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> h = host &#123;</span><br><span class="line">            connectedHosts.removeValue(forKey: h)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> idx = clientSockets.index(of: sock) &#123;</span><br><span class="line">            clientSockets.remove(at: idx)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> f = <span class="keyword">self</span>.block_onDisconnect &#123;</span><br><span class="line">                f(<span class="keyword">self</span>.character, host)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 服务器关闭</span></span><br><span class="line">        <span class="keyword">if</span> sock == asyncSocket &#123;</span><br><span class="line">            <span class="keyword">for</span> sock <span class="keyword">in</span> clientSockets &#123;</span><br><span class="line">                sock.disconnect()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网络由下往上分为：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。&lt;/p&gt;
&lt;p&gt;IP协议对应于网络层，TCP协议对应于传输层，HTTP协议对应于应用层，三者从本质上来说没有可比性，Socket则是对TCP/IP协议的封装和应用。也可以说，TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。&lt;/p&gt;
&lt;p&gt;CocoaAsyncSocket是一个十分好用的异步Socket库，本文将以CocoaAsyncSocket作为工具进行网络通信的操作，Demo源码链接在文章末尾。&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发" scheme="https://xaoxuu.com/blog/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="https://xaoxuu.com/blog/tags/ios/"/>
    
      <category term="Socket" scheme="https://xaoxuu.com/blog/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>Runtime 知识点和应用梳理归纳</title>
    <link href="https://xaoxuu.com/blog/2018-03-06-ios-runtime/"/>
    <id>https://xaoxuu.com/blog/2018-03-06-ios-runtime/</id>
    <published>2018-03-05T16:00:00.000Z</published>
    <updated>2018-04-15T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>ObjC是一门运行时语言，了解Runtime机制对于ObjC开发者来说至关重要。ObjC方法调用的本质，就是让对象发送消息：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">id <span class="title">objc_msgSend</span> <span class="params">( id self, SEL op, ... )</span></span>;</span><br></pre></td></tr></table></figure><p>具体的流程为：</p><ol><li>通过isa指针找到所属类</li><li>查找类的cache列表, 如果没有则下一步</li><li>查找类的”方法列表”</li><li>如果能找到与选择子名称相符的方法, 就跳至其实现代码</li><li>找不到, 就沿着继承体系继续向上查找</li><li>如果能找到与选择子名称相符的方法, 就跳至其实现代码</li><li>找不到, 执行”消息转发”。</li></ol><p>了解了这个流程，我们就可以实现但不止以下几种应用：关联对象、给分类增加属性、动态添加方法、Method Swizzling 交换方法、拦截系统方法的调用、自动归档解档、字典转模型、万能控制器跳转、KVO的底层实现、JSPatch热更新。</p><h2 id="关联对象，给分类增加属性"><a href="#关联对象，给分类增加属性" class="headerlink" title="关联对象，给分类增加属性"></a>关联对象，给分类增加属性</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关联对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_setAssociatedObject</span><span class="params">(id object, <span class="keyword">const</span> <span class="keyword">void</span> *key, id value, objc_AssociationPolicy policy)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取关联的对象</span></span></span><br><span class="line"><span class="function">id <span class="title">objc_getAssociatedObject</span><span class="params">(id object, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 移除关联的对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_removeAssociatedObjects</span><span class="params">(id object)</span></span></span><br></pre></td></tr></table></figure><p>例如给一个名为Person的类的分类添加一个books属性：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">void</span> *KEY_BOOKS = &amp;KEY_BOOKS;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span> (<span class="title">Books</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)setBooks:(<span class="built_in">NSArray</span> *)books&#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, KEY_BOOKS, books, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">NSArray</span> *)books&#123;</span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, KEY_BOOKS);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h2 id="动态添加方法（performSelector）"><a href="#动态添加方法（performSelector）" class="headerlink" title="动态添加方法（performSelector）"></a>动态添加方法（performSelector）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">class_addMethod</span><span class="params">(Class _Nullable cls, SEL _Nonnull name, IMP _Nonnull imp, <span class="keyword">const</span> <span class="keyword">char</span> * _Nullable types)</span></span>;</span><br></pre></td></tr></table></figure><p>通过 <code>performSelector</code> 调用某个方法，如果在运行时找不到 <code>Selector</code> 对应的实现，会执行消息转发，在 <code>resolveInstanceMethod</code> 或 <code>resolveClassMethod</code> 中将函数与对象的 <code>Selector</code> 关联起来。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> eat(<span class="keyword">id</span> <span class="keyword">self</span>, SEL sel) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ %@&quot;</span>,<span class="keyword">self</span>, <span class="built_in">NSStringFromSelector</span>(sel));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(eat)) &#123;</span><br><span class="line">        class_addMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(eat), eat, <span class="string">&quot;v@:&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h2 id="Method-Swizzling-交换方法、拦截系统方法的调用"><a href="#Method-Swizzling-交换方法、拦截系统方法的调用" class="headerlink" title="Method Swizzling 交换方法、拦截系统方法的调用"></a>Method Swizzling 交换方法、拦截系统方法的调用</h2><p>每个类都维护一个方法列表，Method则包含SEL和其对应IMP的信息，方法交换做的事情就是把SEL和IMP的对应关系断开，并和新的IMP生成对应关系。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)exchangeClassMethodImplementations:(Class)cls selector1:(SEL)selector1 selector2:(SEL)selector2&#123;</span><br><span class="line">    Method m1 = class_getClassMethod(cls, selector1);</span><br><span class="line">    Method m2 = class_getClassMethod(cls, selector2);</span><br><span class="line">    method_exchangeImplementations(m1, m2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)exchangeInstanceMethodImplementations:(Class)cls selector1:(SEL)selector1 selector2:(SEL)selector2&#123;</span><br><span class="line">    Method m1 = class_getInstanceMethod(cls, selector1);</span><br><span class="line">    Method m2 = class_getInstanceMethod(cls, selector2);</span><br><span class="line">    method_exchangeImplementations(m1, m2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自动归档解档"><a href="#自动归档解档" class="headerlink" title="自动归档解档"></a>自动归档解档</h2><p>遍历Model自身所有属性，并对属性进行encode和decode操作。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount;</span><br><span class="line">        Ivar * ivars = class_copyIvarList([<span class="keyword">self</span> <span class="keyword">class</span>], &amp;outCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i ++) &#123;</span><br><span class="line">            Ivar ivar = ivars[i];</span><br><span class="line">            <span class="built_in">NSString</span> * key = [<span class="built_in">NSString</span> stringWithUTF8String:ivar_getName(ivar)];</span><br><span class="line">            [<span class="keyword">self</span> setValue:[aDecoder decodeObjectForKey:key] forKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)encodeWithCoder:(<span class="built_in">NSCoder</span> *)aCoder &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount;</span><br><span class="line">    Ivar * ivars = class_copyIvarList([<span class="keyword">self</span> <span class="keyword">class</span>], &amp;outCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i ++) &#123;</span><br><span class="line">        Ivar ivar = ivars[i];</span><br><span class="line">        <span class="built_in">NSString</span> * key = [<span class="built_in">NSString</span> stringWithUTF8String:ivar_getName(ivar)];</span><br><span class="line">        [aCoder encodeObject:[<span class="keyword">self</span> valueForKey:key] forKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="访问私有变量"><a href="#访问私有变量" class="headerlink" title="访问私有变量"></a>访问私有变量</h2><p>通过 <code>getIvar</code> 可以获取到任意已知name的成员变量的值。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ivar ivar &#x3D; class_getInstanceVariable([Model class], &quot;_str1&quot;);</span><br><span class="line">NSString * str1 &#x3D; object_getIvar(model, ivar);</span><br></pre></td></tr></table></figure><h2 id="字典转模型的KVC实现"><a href="#字典转模型的KVC实现" class="headerlink" title="字典转模型的KVC实现"></a>字典转模型的KVC实现</h2><p>遍历Model自身所有属性，从json中找到与属性对应的值，通过KVC将其赋值。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Ivar:成员变量 以下划线开头</span></span><br><span class="line"><span class="comment">// Property:属性</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)modelWithDict:(<span class="built_in">NSDictionary</span> *)dict &#123;</span><br><span class="line">    <span class="keyword">id</span> objc = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 获取成员变量数组</span></span><br><span class="line">    Ivar *ivarList = class_copyIvarList(<span class="keyword">self</span>, &amp;count);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有成员变量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// 获取成员变量</span></span><br><span class="line">        Ivar ivar = ivarList[i];</span><br><span class="line">        <span class="comment">// 获取成员变量名字</span></span><br><span class="line">        <span class="built_in">NSString</span> *ivarName = [<span class="built_in">NSString</span> stringWithUTF8String:ivar_getName(ivar)];</span><br><span class="line">        <span class="comment">// 获取成员变量类型</span></span><br><span class="line">        <span class="built_in">NSString</span> *ivarType = [<span class="built_in">NSString</span> stringWithUTF8String:ivar_getTypeEncoding(ivar)];</span><br><span class="line">        <span class="comment">// @\&quot;User\&quot; -&gt; User</span></span><br><span class="line">        ivarType = [ivarType stringByReplacingOccurrencesOfString:<span class="string">@&quot;\&quot;&quot;</span> withString:<span class="string">@&quot;&quot;</span>];</span><br><span class="line">        ivarType = [ivarType stringByReplacingOccurrencesOfString:<span class="string">@&quot;@&quot;</span> withString:<span class="string">@&quot;&quot;</span>];</span><br><span class="line">        <span class="comment">// 获取key</span></span><br><span class="line">        <span class="built_in">NSString</span> *key = [ivarName substringFromIndex:<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去字典中查找对应value</span></span><br><span class="line">        <span class="comment">// key:user  value:NSDictionary</span></span><br><span class="line">        <span class="keyword">id</span> value = dict[key];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 二级转换:判断下value是否是字典,如果是,字典转换层对应的模型</span></span><br><span class="line">        <span class="comment">// 并且是自定义对象才需要转换</span></span><br><span class="line">        <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]] &amp;&amp; ![ivarType hasPrefix:<span class="string">@&quot;NS&quot;</span>]) &#123;</span><br><span class="line">            <span class="comment">// 字典转换成模型 userDict =&gt; User模型</span></span><br><span class="line">            Class modelClass = <span class="built_in">NSClassFromString</span>(ivarType);</span><br><span class="line">            value = [modelClass modelWithDict:value];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 给模型中属性赋值</span></span><br><span class="line">        <span class="keyword">if</span> (value) &#123;</span><br><span class="line">            [objc setValue:value forKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考资料：<a href="http://www.cnblogs.com/jys509/p/5207159.html#autoid-3-4-0" target="_blank" rel="noopener external nofollow noreferrer">http://www.cnblogs.com/jys509/p/5207159.html#autoid-3-4-0</a></p><h2 id="实现万能控制器跳转"><a href="#实现万能控制器跳转" class="headerlink" title="实现万能控制器跳转"></a>实现万能控制器跳转</h2><p>利用runtime动态生成对象、属性、方法这特性，我们可以先跟服务端商量好，定义跳转规则，比如要跳转到A控制器，需要传属性id、type，那么服务端返回字典给我，里面有控制器名，两个属性名跟属性值，客户端就可以根据控制器名生成对象，再用kvc给对象赋值。</p><p>参考资料：<a href="http://www.cocoachina.com/articles/13104" target="_blank" rel="noopener external nofollow noreferrer">http://www.cocoachina.com/articles/13104</a></p><h2 id="KVO的底层实现"><a href="#KVO的底层实现" class="headerlink" title="KVO的底层实现"></a>KVO的底层实现</h2><p>KVO是基于runtime机制实现的，当某个类的对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的setter方法。</p>]]></content>
    
    <summary type="html">
    
      ObjC是一门运行时语言，了解Runtime机制对于ObjC开发者来说至关重要。
    
    </summary>
    
    
      <category term="开发" scheme="https://xaoxuu.com/blog/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="https://xaoxuu.com/blog/tags/ios/"/>
    
      <category term="Runtime" scheme="https://xaoxuu.com/blog/tags/runtime/"/>
    
      <category term="ObjC" scheme="https://xaoxuu.com/blog/tags/objc/"/>
    
  </entry>
  
  <entry>
    <title>RunLoop 知识点和应用梳理归纳</title>
    <link href="https://xaoxuu.com/blog/2018-03-05-ios-runloop/"/>
    <id>https://xaoxuu.com/blog/2018-03-05-ios-runloop/</id>
    <published>2018-03-04T16:00:00.000Z</published>
    <updated>2018-04-15T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="RunLoop的作用"><a href="#RunLoop的作用" class="headerlink" title="RunLoop的作用"></a>RunLoop的作用</h2><ol><li>等待事件发生：使程序一直运行接受用户输入</li><li>计划事件：决定程序在何时应该处理哪些Event</li><li>调用解耦：事件产生方不需要等待事件处理结束再产生下一个事件</li><li>节省CPU时间：等待事件发生时不需要耗费CPU</li></ol><p>参考资料：<a href="https://segmentfault.com/a/1190000004938638?from=singlemessage&isappinstalled=1" target="_blank" rel="noopener external nofollow noreferrer">RunLoop知识树</a></p><h2 id="RunLoop的几种mode"><a href="#RunLoop的几种mode" class="headerlink" title="RunLoop的几种mode"></a>RunLoop的几种mode</h2><ul><li><p><strong>NSDefaultRunLoopMode/kCFRunLoopDefaultMode</strong></p><p>default模式，可以用于大多数操作。在大多数时间，应该使用这种模式来启动和设置输入源。</p></li><li><p><strong>NSEventTrackingRunLoopMode</strong></p><p>Cocoa使用这种模式来约束鼠标拖拽或其它用户界面追踪循环的事件。</p></li><li><p><strong>NSRunLoopCommonModes/kCFRunLoopCommonModes</strong></p><p>这是一个通用的模式组，使用这种模式关联输入源，同样会关联这个模式组里面的每一种模式。对于Cocoa应用来说，这个集合包含了 default、modal以及event tracking模式。</p></li><li><p><strong>NSConnectionReplyMode</strong></p></li><li><p><strong>NSModalPanelRunLoopMode</strong></p></li></ul><h2 id="RunLoop和线程的关系"><a href="#RunLoop和线程的关系" class="headerlink" title="RunLoop和线程的关系"></a>RunLoop和线程的关系</h2><p>一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要让线程随时处理事件但并不退出，就需要给线程开启RunLoop。</p><p>程序不自动退出是因为主线程自动开启了RunLoop。</p><p>开启RunLoop的方法：<code>[NSRunLoop currentRunLoop]</code> 获取当前线程的runloop，若不存在系统会创建一个。</p><h2 id="RunLoop的应用"><a href="#RunLoop的应用" class="headerlink" title="RunLoop的应用"></a>RunLoop的应用</h2><h3 id="scrollView滑动（mode切换保证滑动不卡顿）"><a href="#scrollView滑动（mode切换保证滑动不卡顿）" class="headerlink" title="scrollView滑动（mode切换保证滑动不卡顿）"></a>scrollView滑动（mode切换保证滑动不卡顿）</h3><p>当tableview的cell上有需要从网络获取的图片的时候，滚动tableView，异步线程会去加载图片，加载完成后主线程就会设置cell的图片，但是会造成卡顿。可以让设置图片的任务在CFRunLoopDefaultMode下进行，当滚动tableView的时候，RunLoop是在 UITrackingRunLoopMode 下进行，不去设置图片，而是当停止的时候，再去设置图片。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIImage</span> *downloadedImage = ...;</span><br><span class="line">[<span class="keyword">self</span>.avatarImageView performSelector:<span class="keyword">@selector</span>(setImage:) withObject:downloadedImage afterDelay:<span class="number">0</span> inModes:@[<span class="built_in">NSDefaultRunLoopMode</span>]];</span><br></pre></td></tr></table></figure><h3 id="RunLoop监听：AFNetworking中监听网络请求"><a href="#RunLoop监听：AFNetworking中监听网络请求" class="headerlink" title="RunLoop监听：AFNetworking中监听网络请求"></a>RunLoop监听：AFNetworking中监听网络请求</h3><p>使用NSOperation+NSURLConnection并发模型都会面临NSURLConnection下载完成前线程退出导致NSOperation对象接收不到回调的问题。NSURLConnection的delegate方法需要在connection发起的线程runloop中调用，于是AFNetWorking单独起一个global thread，内置一个runloop，所有的connection都由这个runloop发起，回调也是它接收，不占用主线程，也不耗CPU资源。</p><h3 id="NSTimer-timer触发"><a href="#NSTimer-timer触发" class="headerlink" title="NSTimer(timer触发)"></a>NSTimer(timer触发)</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">60</span> block:^(<span class="built_in">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class="line"></span><br><span class="line">&#125; repeats:<span class="literal">YES</span>];</span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br></pre></td></tr></table></figure><ul><li>UIEvent事件响应和手势识别(source0事件处理 &amp; source1底层硬件触发)</li><li>AutoRelease(observer，runloop一次循环结束或autorelease pool满了的时候释放)</li><li>NSObject（NSDelayPerforming(timer)，NSThreadPerformAddition(source0)）</li><li>dispatch_get_main_queue()（serve for dispatch main）</li><li>UI界面刷新、CATransition、CAAnimation(observer) CADisplayLink(source1)</li><li>NSURLConnection(source0处理回调 &amp; source1接收Socket消息) AFNetworking(内置全局线程和runloop管理网络请求)</li><li>AsyncDisplayKit</li></ul>]]></content>
    
    <summary type="html">
    
      本文将从RunLoop的作用、几种Mode、和线程的关系、应用方面进行梳理归纳。
    
    </summary>
    
    
      <category term="开发" scheme="https://xaoxuu.com/blog/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="https://xaoxuu.com/blog/tags/ios/"/>
    
      <category term="ObjC" scheme="https://xaoxuu.com/blog/tags/objc/"/>
    
  </entry>
  
  <entry>
    <title>整理混乱不堪的各国语言翻译</title>
    <link href="https://xaoxuu.com/blog/2017-12-25-merge-localizable-strings/"/>
    <id>https://xaoxuu.com/blog/2017-12-25-merge-localizable-strings/</id>
    <published>2017-12-24T16:00:00.000Z</published>
    <updated>2017-12-24T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>linksmart项目截止目前已经支持了17个国家的语言，从诞生到现在也已经经历了很多程序员的修改和维护，代码已经变得十分混乱。因为公司一直在接新的定制项目，所以也没有时间进行一次彻底的重构，只能在维护某方面的BUG的时候，对相关代码进行局部重构。</p><a id="more"></a><p>现在的情况是：</p><ul><li>同一个文本有些语言有翻译，有些语言没有翻译。</li><li>有些需要使用缩进的地方，由于某种原因，并没有使用 <code>UIEdgeInsets</code> 进行缩进，而是在文本前后加空格。(⊙﹏⊙)b</li></ul><h2 id="整理思路"><a href="#整理思路" class="headerlink" title="整理思路"></a>整理思路</h2><p>首先必须得找出一种合适的方法维护这些Localizable.strings，在Excel里做一个总表，增加语言的时候，可以直接把英文的一列发给客户进行翻译。最大的优势是：随时可以用脚本把Excel里的所有语言导出成项目支持的Localizable.strings文件，极大提高效率。</p><h2 id="1-补全"><a href="#1-补全" class="headerlink" title="1. 补全"></a>1. 补全</h2><p>使用 <code>genstrings</code> 命令将所有.m文件中的LocalizedString文本生成Localizable.strings。<br>打开终端，进入需要检测的文件夹，执行以下命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find .&#x2F; -name &quot;*.m&quot; -print0 | xargs -0 genstrings -o .&#x2F;</span><br></pre></td></tr></table></figure><p>生成的这一份文件只包含所有.m文件中的国际化字符串，并不包含plist和xib中的字符串。接下来只要把这一份和原来的所有翻译合并起来去重，就得到一份最全的key。</p><p>如果也需要检测xib、.h文件，则执行以下命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find . -name &#39;*.xib&#39; -o -name &#39;*.[mh]&#39; -print0 | xargs -0 genstrings -o .&#x2F;</span><br></pre></td></tr></table></figure><p>生成的文件会存在当前目录。</p><h2 id="2-合并去重"><a href="#2-合并去重" class="headerlink" title="2. 合并去重"></a>2. 合并去重</h2><p>我尝试过直接读取Localizable.strings文件，但提示编码错误，就暂时copy到txt文件中进行处理。</p><blockquote><p>合并的Demo：<a href="https://github.com/xaoxuu/LocalizedTool-iOS" target="_blank" rel="noopener external nofollow noreferrer">https://github.com/xaoxuu/LocalizedTool-iOS</a></p></blockquote><h2 id="3-导入Excel"><a href="#3-导入Excel" class="headerlink" title="3. 导入Excel"></a>3. 导入Excel</h2><p>接下来的步骤工作量有点大，就是重新把那些翻译导入Excel中，补全缺少的那些翻译。</p><blockquote><p>导入Excel和从Excel导出为Localizable.strings的方法在这里：<a href="https://xaoxuu.com/blog/2017-03-08-ios-localizable-string">https://xaoxuu.com/blog/2017-03-08-ios-localizable-string</a></p></blockquote><h2 id="附：检测中文字符串"><a href="#附：检测中文字符串" class="headerlink" title="附：检测中文字符串"></a>附：检测中文字符串</h2><p>如果项目的默认语言是中文，而且前期没有用多语言写法，可以使用xcode的替换功能，将中文字符串替换成多语言的写法：</p><p>搜索：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(@&quot;[^&quot;]*[\u4E00-\u9FA5]+[^&quot;\n]*?&quot;)</span><br></pre></td></tr></table></figure><p>替换为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSLocalizedStringFromTable($0, @&quot;Localizable&quot;, nil)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;linksmart项目截止目前已经支持了17个国家的语言，从诞生到现在也已经经历了很多程序员的修改和维护，代码已经变得十分混乱。因为公司一直在接新的定制项目，所以也没有时间进行一次彻底的重构，只能在维护某方面的BUG的时候，对相关代码进行局部重构。&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发" scheme="https://xaoxuu.com/blog/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="https://xaoxuu.com/blog/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>iOS 推迟而不重复执行函数</title>
    <link href="https://xaoxuu.com/blog/2017-11-09-gcd-delay/"/>
    <id>https://xaoxuu.com/blog/2017-11-09-gcd-delay/</id>
    <published>2017-11-08T16:00:00.000Z</published>
    <updated>2017-11-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>如果你想推迟执行一段代码，使用 <code>dispatch_after</code> 函数可以轻易实现，但有时候我们想在它delay的期间再次delay，直到最终不再delay的时候，才真正的被调用一次。这就需要每次先将旧的事件取消，然后重新设置delay。</p><a id="more"></a><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p><strong>自动消失的视图</strong></p><p>例如当用户的某种操作点击一下屏幕就发出一条状态栏消息，消息在2秒后消失，在消失前如果用户又触发了这个条件，理应是在这次触发的2秒后消失，如果简单的使用 <code>dispatch_after</code> 函数进行延迟，结果会是在第一次点击的2秒后消失，可能你在1.5秒的时候又点击了一下，但是只过了0.5秒就消失了。</p><p><strong>降低服务器访问次数</strong></p><p>例如：用户修改了信息的30秒后上传至服务器。那么如果用户修改了姓名，然后30秒内又修改了头像，在修改了头像后的30秒内又修改了性别等等。我们希望的并不是每次修改就上传一次，而是在用户最后修改完所有信息之后，看起来似乎不准备继续修改了的时候，再上传至服务器。使用推迟而不重复执行的方法可以在避免多次访问服务器的同时及时地上传用户修改后的信息。</p><p><strong>AXKitDemo</strong></p><p>为了方便大家理解，我在Demo中做了这样一个页面，点击屏幕的时候计数器会增加，意味着收到某种需要处理的用户交互信息，2秒后作出回应（发出状态栏消息）。如果2秒内用户重复点击屏幕，那么这个回应会继续被推迟，直到某个连续的2秒没有收到任何输入，这时候才作出一次响应。</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/2017/32600845-db7e9798-c57b-11e7-9111-81f7a4925e4d.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/2017/32600845-db7e9798-c57b-11e7-9111-81f7a4925e4d.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="width:400px;"/></div></div><p>实现的方法很简单，步骤如下：</p><ol><li>获取到函数</li><li>取消函数</li><li>重新赋值或启动</li></ol><h2 id="使用Objective-C"><a href="#使用Objective-C" class="headerlink" title="使用Objective-C"></a>使用Objective-C</h2><p>在Objective-C中，将要执行的代码保存成 <code>dispatch_block_t</code> 的静态类型变量，取出这个静态变量，然后使用 <code>dispatch_block_cancel()</code> 取消，然后重新设置它的值，然后调用 <code>dispatch_after</code>。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)delayTest&#123;</span><br><span class="line">    <span class="keyword">static</span> dispatch_block_t task;</span><br><span class="line">    <span class="keyword">if</span> (task) &#123;</span><br><span class="line">        dispatch_block_cancel(task);</span><br><span class="line">    &#125;</span><br><span class="line">    task = dispatch_block_create(DISPATCH_BLOCK_BARRIER, ^&#123;</span><br><span class="line">        <span class="comment">// 被推迟执行的代码</span></span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(duration * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="也可以使用AXKit实现"><a href="#也可以使用AXKit实现" class="headerlink" title="也可以使用AXKit实现"></a>也可以使用AXKit实现</h3><p>也可以使用 <a href="https://github.com/xaoxuu/AXKit/" target="_blank" rel="noopener external nofollow noreferrer">AXKit</a> 封装好的方法，将要执行的代码保存成 <code>ax_dispatch_operation_t</code> 的静态类型变量，使用 <code>ax_dispatch_cancel_operation()</code> 取消之前的任务，然后使用 <code>ax_dispatch_cancellable()</code> 再次赋值。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)delayTest2&#123;</span><br><span class="line">    <span class="keyword">static</span> ax_dispatch_operation_t animationToken;</span><br><span class="line">    ax_dispatch_cancel_operation(animationToken);</span><br><span class="line">    animationToken = ax_dispatch_cancellable(duration, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="comment">// 被推迟执行的代码</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="使用Swift"><a href="#使用Swift" class="headerlink" title="使用Swift"></a>使用Swift</h2><p>创建静态变量 <code>static var task = DispatchWorkItem.init&#123;&#125;</code>，先取消 <code>task.cancel()</code>，再赋值 <code>DispatchWorkItem</code>，然后使用 <code>DispatchQueue.main.asyncAfter(deadline: .now() + duration, execute: task)</code> 延迟调用。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> task = <span class="type">DispatchWorkItem</span>.<span class="keyword">init</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">hide</span><span class="params">(duration: TimeInterval)</span></span> &#123;</span><br><span class="line">    task.cancel()</span><br><span class="line">    task = <span class="type">DispatchWorkItem</span>.<span class="keyword">init</span>(block: &#123;</span><br><span class="line">        <span class="comment">// 被推迟执行的代码</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + duration, execute: task)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你想推迟执行一段代码，使用 &lt;code&gt;dispatch_after&lt;/code&gt; 函数可以轻易实现，但有时候我们想在它delay的期间再次delay，直到最终不再delay的时候，才真正的被调用一次。这就需要每次先将旧的事件取消，然后重新设置delay。&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发" scheme="https://xaoxuu.com/blog/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Swift" scheme="https://xaoxuu.com/blog/tags/swift/"/>
    
      <category term="GCD" scheme="https://xaoxuu.com/blog/tags/gcd/"/>
    
      <category term="ObjC" scheme="https://xaoxuu.com/blog/tags/objc/"/>
    
  </entry>
  
  <entry>
    <title>AXChartView：一个简单而漂亮的图表工具类</title>
    <link href="https://xaoxuu.com/blog/2017-09-14-chartview/"/>
    <id>https://xaoxuu.com/blog/2017-09-14-chartview/</id>
    <published>2017-09-13T16:00:00.000Z</published>
    <updated>2017-09-13T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>项目源码： <a href="https://github.com/xaoxuu/AXChartView/" target="_blank" rel="noopener external nofollow noreferrer">https://github.com/xaoxuu/AXChartView/</a></p><a id="more"></a><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">AXChartView *v1 = [[AXChartView alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">16</span>, <span class="number">28</span>, <span class="keyword">self</span>.view.frame.size.width - <span class="number">32</span>, <span class="number">200</span>)];</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:v1];</span><br><span class="line"><span class="keyword">self</span>.v1 = v1;</span><br><span class="line">v1.dataSource = <span class="keyword">self</span>;</span><br><span class="line">v1.delegate = <span class="keyword">self</span>;</span><br><span class="line"><span class="comment">// 标题</span></span><br><span class="line">v1.title = <span class="string">@&quot;AXChartView&quot;</span>;</span><br><span class="line"><span class="comment">// 线条粗细，默认为1</span></span><br><span class="line">v1.lineWidth = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 平滑指数，默认为0，折线图</span></span><br><span class="line">v1.smoothFactor = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 强调色，默认为灰色</span></span><br><span class="line">v1.accentColor = [<span class="built_in">UIColor</span> orangeColor];</span><br></pre></td></tr></table></figure><h2 id="设置数据源"><a href="#设置数据源" class="headerlink" title="设置数据源"></a>设置数据源</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 总列数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @return 总列数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)chartViewItemsCount&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 第index列的值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param index 列索引</span></span><br><span class="line"><span class="comment"> @return 第index列的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">NSNumber</span> *)chartViewValueForIndex:(<span class="built_in">NSUInteger</span>)index&#123;</span><br><span class="line">    <span class="keyword">return</span> @(arc4random_uniform(<span class="number">20000</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 第index列的标题</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param index 列索引</span></span><br><span class="line"><span class="comment"> @return 第index列的标题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)chartViewTitleForIndex:(<span class="built_in">NSUInteger</span>)index&#123;</span><br><span class="line">    <span class="keyword">return</span> @(index+<span class="number">1</span>).stringValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每多少天显示一个列标题(当列数很多的时候用)</span></span><br><span class="line">- (<span class="built_in">NSInteger</span>)chartViewShowTitleForIndexWithSteps&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右上角的摘要文字</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)chartViewSummaryText:(<span class="built_in">UILabel</span> *)label&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">@&quot;haha&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渐变的背景色</span></span><br><span class="line">- (<span class="keyword">void</span>)chartViewWillSetGradientLayer:(<span class="built_in">CAGradientLayer</span> *)gradientLayer&#123;</span><br><span class="line">    [gradientLayer setColors:@[(<span class="keyword">id</span>)[<span class="built_in">UIColor</span> colorWithRed:<span class="number">248</span>/<span class="number">255.0</span> green:<span class="number">207</span>/<span class="number">255.0</span> blue:<span class="number">54</span>/<span class="number">255.0</span> alpha:<span class="number">1.00</span>].CGColor, (<span class="keyword">id</span>)[<span class="built_in">UIColor</span> colorWithRed:<span class="number">253</span>/<span class="number">255.0</span> green:<span class="number">166</span>/<span class="number">255.0</span> blue:<span class="number">65</span>/<span class="number">255.0</span> alpha:<span class="number">1.00</span>].CGColor]];</span><br><span class="line">    [gradientLayer setStartPoint:<span class="built_in">CGPointMake</span>(<span class="number">0</span>, <span class="number">0</span>)];</span><br><span class="line">    [gradientLayer setEndPoint:<span class="built_in">CGPointMake</span>(<span class="number">1</span>, <span class="number">1</span>)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目源码： &lt;a href=&quot;https://github.com/xaoxuu/AXChartView/&quot; target=&quot;_blank&quot; rel=&quot;noopener external nofollow noreferrer&quot;&gt;https://github.com/xaoxuu/AXChartView/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发" scheme="https://xaoxuu.com/blog/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="https://xaoxuu.com/blog/tags/ios/"/>
    
      <category term="开源库" scheme="https://xaoxuu.com/blog/tags/%E5%BC%80%E6%BA%90%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>使用 appledoc 生成 API 文档</title>
    <link href="https://xaoxuu.com/blog/2017-09-09-appledoc/"/>
    <id>https://xaoxuu.com/blog/2017-09-09-appledoc/</id>
    <published>2017-09-08T16:00:00.000Z</published>
    <updated>2020-08-24T09:48:05.081Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>appledoc 是个十分强大的工具，能生成和 Apple 一个风格的文档，功能齐全，使用方便，还可以直接编译成 docset 安装进 Xcode。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://github.com/tomaz/appledoc.git</span><br><span class="line"><span class="built_in">cd</span> ./appledoc</span><br><span class="line">sudo sh install-appledoc.sh</span><br></pre></td></tr></table></figure><p>验证</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">appledoc --version</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>你可以直接通过终端命令去生成，不过我更喜欢做成 Xcode 编译脚本，步骤如下：</p><ol><li>选中你的工程，点击 <code>Add Target</code> 按钮，选择 <code>Other -&gt; Aggregate</code> 模板新建</li><li>点击 <code>Add Build Phase</code> 按钮，添加一个 <code>Run Script</code></li><li>把下面的模板代码复制进去，把前几行参数改成你自己的</li><li>在 Xcode 左上角选择这个新建的 Target，然后点击 <code>build</code></li><li>文档就会编译好并且自动安装进 Xcode 了（重启 Xcode 生效）</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#appledoc Xcode script</span></span><br><span class="line"><span class="comment"># Start constants</span></span><br><span class="line">company=<span class="string">&quot;xaoxuu&quot;</span>;</span><br><span class="line">companyID=<span class="string">&quot;com.xaoxuu&quot;</span>;</span><br><span class="line">companyURL=<span class="string">&quot;http://xaoxuu.com&quot;</span>;</span><br><span class="line">target=<span class="string">&quot;iphoneos&quot;</span>;</span><br><span class="line"><span class="comment">#target=&quot;macosx&quot;;</span></span><br><span class="line">outputPath=<span class="string">&quot;<span class="variable">$&#123;SRCROOT&#125;</span>/docs/appledoc&quot;</span>;</span><br><span class="line"><span class="comment"># End constants</span></span><br><span class="line">/usr/<span class="built_in">local</span>/bin/appledoc --project-name <span class="string">&quot;<span class="variable">$&#123;PROJECT_NAME&#125;</span>&quot;</span> --project-company <span class="string">&quot;<span class="variable">$&#123;company&#125;</span>&quot;</span> --company-id <span class="string">&quot;<span class="variable">$&#123;companyID&#125;</span>&quot;</span> --docset-atom-filename <span class="string">&quot;<span class="variable">$&#123;company&#125;</span>.atom&quot;</span> --docset-feed-url <span class="string">&quot;<span class="variable">$&#123;companyURL&#125;</span>/<span class="variable">$&#123;company&#125;</span>/%DOCSETATOMFILENAME&quot;</span> --docset-package-url <span class="string">&quot;<span class="variable">$&#123;companyURL&#125;</span>/<span class="variable">$&#123;company&#125;</span>/%DOCSETPACKAGEFILENAME&quot;</span> --docset-fallback-url <span class="string">&quot;<span class="variable">$&#123;companyURL&#125;</span>/<span class="variable">$&#123;company&#125;</span>&quot;</span> --output <span class="string">&quot;<span class="variable">$&#123;outputPath&#125;</span>&quot;</span> --publish-docset --docset-platform-family <span class="string">&quot;<span class="variable">$&#123;target&#125;</span>&quot;</span> --logformat xcode --keep-intermediate-files --no-repeat-first-par --no-warn-invalid-crossref --<span class="built_in">exit</span>-threshold 2 <span class="string">&quot;<span class="variable">$&#123;PROJECT_DIR&#125;</span>/AXKit&quot;</span></span><br><span class="line"></span><br><span class="line">open <span class="string">&quot;<span class="variable">$&#123;SRCROOT&#125;</span>/docs/appledoc/html/index.html&quot;</span></span><br></pre></td></tr></table></figure><div class="note warning"><p>注意：我把输出路径设置为 <code>${SRCROOT}/docs/appledoc</code> 的目的在于当前项目工程的 page 页面在 <code>/docs</code> 里，在 page 页面可以方便访问生成的文档的 html 页面。</p></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;appledoc 是个十分强大的工具，能生成和 Apple 一个风格的文档，功能齐全，使用方便，还可以直接编译成 docset 安装进 Xcode。&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发" scheme="https://xaoxuu.com/blog/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="appledoc" scheme="https://xaoxuu.com/blog/tags/appledoc/"/>
    
  </entry>
  
  <entry>
    <title>一次特别的直播：iOS 项目框架的搭建</title>
    <link href="https://xaoxuu.com/blog/2017-09-07-ios-architecture/"/>
    <id>https://xaoxuu.com/blog/2017-09-07-ios-architecture/</id>
    <published>2017-09-06T16:00:00.000Z</published>
    <updated>2020-08-24T09:48:05.069Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>公司开展了一个新的活动，每周四下午的技术直播，就是传说中的直播敲代码，刚好又准备开始做新项目，所以第一个周四直播主题就是搭建项目框架。</p><a id="more"></a><div class="img-wrap"><div class="img-bg" style="background:#fff"><img class="img lazyload" src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/2017/R8t2LKAF4nEpHNJ.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/2017/R8t2LKAF4nEpHNJ.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="项目结构" style="width:400px;"/></div><span class="image-caption">项目结构</span></div><p>项目框架我已经提前准备好了思维导图 <span class='btn'><a class="button" href='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/2017/ios-architecture.xmind.zip' title='ios-architecture.xmind.zip'>ios-architecture.xmind.zip</a></span> 刚好几个月前我在 AXKit 的 Demo 中尝试搭建模块化框架，虽然没有做完被搁置了，但是整体项目结构都差不多，所以可以当做成一个项目模板使用。</p><p>所以这次直播的过程是这样的：我打开提前准备好的思维导图和 AXKit，新建项目工程，对照着思维导图创建需要的文件夹，将 AXKitDemo 中有的部分拖拽过来，解决依赖问题。</p><p>在直播结束的时候，进行一个简要的总结，并就现在工作效率问题做了一些讨论，包括：<strong>需求的规范化</strong>、<strong>UI的规范化</strong>，由于具体内容涉及公司机密就不再详细说明了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;公司开展了一个新的活动，每周四下午的技术直播，就是传说中的直播敲代码，刚好又准备开始做新项目，所以第一个周四直播主题就是搭建项目框架。&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发" scheme="https://xaoxuu.com/blog/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="直播" scheme="https://xaoxuu.com/blog/tags/%E7%9B%B4%E6%92%AD/"/>
    
      <category term="项目框架" scheme="https://xaoxuu.com/blog/tags/%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>iOS 接入 Strava 分享模块（下篇：StravaSDK）</title>
    <link href="https://xaoxuu.com/blog/2017-06-28-ios-strava/"/>
    <id>https://xaoxuu.com/blog/2017-06-28-ios-strava/</id>
    <published>2017-06-27T16:00:00.000Z</published>
    <updated>2017-06-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a href="https://github.com/StravaKit/StravaKit" target="_blank" rel="noopener external nofollow noreferrer">StravaKit</a> 是一个比较新而且代码比较规范的第三方SDK，但是目前还没有上传功能（详见 <a href="https://github.com/StravaKit/StravaKit/blob/master/TODO.md" target="_blank" rel="noopener external nofollow noreferrer">todo</a>） 。所以我不得已对 <code>StravaKit 0.9.5</code> 增加上传功能，并进行一些简单封装和改编，使之能够植入到公司项目中。由于时间有限，我只增加了上传fit文件的功能，并且使用了第三方框架 <code>Alamofire</code>，所以需要在项目中导入 <code>Alamofire</code>。</p><a id="more"></a><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><p>StravaSDK 下载：<a href="https://github.com/xaoxuu/StravaSDK" target="_blank" rel="noopener external nofollow noreferrer">StravaSDK.zip</a></p><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><p>需要三个参数：<code>ClientId</code>、<code>ClientSecret</code> 和app的 <code>URLSchemes</code>。其中前两个是在 <a href="https://labs.strava.com/developers/" target="_blank" rel="noopener external nofollow noreferrer">Strava平台</a> 注册一个app的时候会给出。<br>示例代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">StravaSDK</span>.config(clientId: <span class="string">&quot;18583&quot;</span>, clientSecret: <span class="string">&quot;a05fde98a830effde2e0f84cc39d76b040d4d67e&quot;</span>, appSchemes: <span class="string">&quot;hitfit&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><p>获取授权</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">StravaSDK</span>.authorize()</span><br></pre></td></tr></table></figure><p>取消授权</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">StravaSDK</span>.deauthorize()</span><br></pre></td></tr></table></figure><p>查询是否已授权</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">StravaSDK</span>.isAuthorized</span><br></pre></td></tr></table></figure><h2 id="上传活动数据（-fit）"><a href="#上传活动数据（-fit）" class="headerlink" title="上传活动数据（.fit）"></a>上传活动数据（.fit）</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">StravaSDK</span>.uploadActivity(path: <span class="string">&quot;.../test.fit&quot;</span>, type: <span class="string">&quot;run&quot;</span>, name: <span class="string">&quot;Afternoon Run&quot;</span>) &#123; (response, error) <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/StravaKit/StravaKit&quot; target=&quot;_blank&quot; rel=&quot;noopener external nofollow noreferrer&quot;&gt;StravaKit&lt;/a&gt; 是一个比较新而且代码比较规范的第三方SDK，但是目前还没有上传功能（详见 &lt;a href=&quot;https://github.com/StravaKit/StravaKit/blob/master/TODO.md&quot; target=&quot;_blank&quot; rel=&quot;noopener external nofollow noreferrer&quot;&gt;todo&lt;/a&gt;） 。所以我不得已对 &lt;code&gt;StravaKit 0.9.5&lt;/code&gt; 增加上传功能，并进行一些简单封装和改编，使之能够植入到公司项目中。由于时间有限，我只增加了上传fit文件的功能，并且使用了第三方框架 &lt;code&gt;Alamofire&lt;/code&gt;，所以需要在项目中导入 &lt;code&gt;Alamofire&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发" scheme="https://xaoxuu.com/blog/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="https://xaoxuu.com/blog/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>使用 Alamofire 框架上传文件</title>
    <link href="https://xaoxuu.com/blog/2017-06-26-swift-alamofire/"/>
    <id>https://xaoxuu.com/blog/2017-06-26-swift-alamofire/</id>
    <published>2017-06-25T16:00:00.000Z</published>
    <updated>2017-06-25T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a href="https://github.com/Alamofire/Alamofire" target="_blank" rel="noopener external nofollow noreferrer">Alamofire</a> 是一个在GitHub上star数已超过24k的网络库。</p><a id="more"></a><p>先贴出一段代码，这是我在StravaKit中增加的上传fit文件功能：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Requestor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">uploadFitFile</span><span class="params">(url: String, params: [String : String]?, file: URL, completionHandler: <span class="params">(<span class="params">(<span class="number">_</span> response: <span class="keyword">Any</span>?, <span class="number">_</span> error: NSError?)</span></span></span></span> -&gt; ())?) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> accessToken = <span class="type">Strava</span>.sharedInstance.accessToken</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> error = <span class="type">Strava</span>.error(.noAccessToken, reason: <span class="string">&quot;No Access Token&quot;</span>)</span><br><span class="line">                completionHandler?(<span class="literal">nil</span>, error)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">debugPrint</span>(accessToken)</span><br><span class="line">        <span class="keyword">let</span> au = <span class="string">&quot;Bearer \(accessToken)&quot;</span></span><br><span class="line">        <span class="keyword">let</span> headers = [<span class="string">&quot;Authorization&quot;</span>: au]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Alamofire</span>.upload(multipartFormData: &#123; (multipartFormData) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> params = params &#123;</span><br><span class="line">                <span class="keyword">for</span> (key, value) <span class="keyword">in</span> params &#123;</span><br><span class="line">                    multipartFormData.append(value.data(using: .utf8)!, withName: key)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            multipartFormData.append(file, withName: <span class="string">&quot;file&quot;</span>, fileName: file.lastPathComponent, mimeType: <span class="string">&quot;multipart/form-data&quot;</span>)</span><br><span class="line">        &#125;, usingThreshold: <span class="type">SessionManager</span>.multipartFormDataEncodingMemoryThreshold, to: baseUrl + url, method: .post, headers: headers) &#123; (encodingResult) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">switch</span> encodingResult &#123;</span><br><span class="line">            <span class="keyword">case</span> .success(<span class="keyword">let</span> upload, <span class="number">_</span>, <span class="number">_</span>):</span><br><span class="line">                upload.responseJSON(completionHandler: &#123; (response) <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> value = response.result.value &#123;</span><br><span class="line">                        <span class="keyword">let</span> dict = value <span class="keyword">as</span>! <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">Any</span>&gt;;</span><br><span class="line">                        <span class="keyword">var</span> error = response.result.error <span class="keyword">as</span> <span class="type">NSError?</span></span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">let</span> err = dict[<span class="string">&quot;error&quot;</span>] &#123;</span><br><span class="line">                            <span class="keyword">if</span> (err <span class="keyword">as</span> <span class="type">AnyObject</span>).isKind(of: <span class="type">NSNull</span>.<span class="keyword">self</span>) &#123;</span><br><span class="line">                                <span class="comment">// 成功</span></span><br><span class="line">                                <span class="built_in">debugPrint</span>(<span class="string">&quot;成功&quot;</span>)</span><br><span class="line"></span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">// 失败</span></span><br><span class="line">                                <span class="built_in">debugPrint</span>(<span class="string">&quot;失败&quot;</span>,err)</span><br><span class="line">                                error = <span class="type">NSError</span>.<span class="keyword">init</span>(domain: <span class="string">&quot;strava&quot;</span>, code: <span class="number">0</span>, userInfo: [<span class="type">NSLocalizedDescriptionKey</span>:err])</span><br><span class="line"></span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">let</span> completionHandler = completionHandler &#123;</span><br><span class="line">                            completionHandler(response.result,error)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">let</span> completionHandler = completionHandler &#123;</span><br><span class="line">                            <span class="keyword">if</span> <span class="keyword">let</span> error = response.result.error &#123;</span><br><span class="line">                                completionHandler(response.result,error <span class="keyword">as</span> <span class="type">NSError</span>)</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;)</span><br><span class="line">            <span class="keyword">case</span> .failure(<span class="keyword">let</span> error):</span><br><span class="line">                <span class="built_in">print</span>(error)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/Alamofire/Alamofire&quot; target=&quot;_blank&quot; rel=&quot;noopener external nofollow noreferrer&quot;&gt;Alamofire&lt;/a&gt; 是一个在GitHub上star数已超过24k的网络库。&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发" scheme="https://xaoxuu.com/blog/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="https://xaoxuu.com/blog/tags/ios/"/>
    
      <category term="Swift" scheme="https://xaoxuu.com/blog/tags/swift/"/>
    
      <category term="Alamofire" scheme="https://xaoxuu.com/blog/tags/alamofire/"/>
    
  </entry>
  
  <entry>
    <title>iOS 接入 Strava 分享模块（上篇：FitSDK）</title>
    <link href="https://xaoxuu.com/blog/2017-06-22-ios-fitsdk/"/>
    <id>https://xaoxuu.com/blog/2017-06-22-ios-fitsdk/</id>
    <published>2017-06-21T16:00:00.000Z</published>
    <updated>2017-06-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a href="https://www.thisisant.com/resources/fit/" target="_blank" rel="noopener external nofollow noreferrer">fit</a> 是一种文件协议，体积小巧，多用于可穿戴设备记录、传输运动与健康数据。官方提供了 C、C++、Java 语言的 SDK 和非常详细的使用文档。因此在 iOS 端接入 fit 就需要在 C 或 C++ 的 SDK 基础上进行一点面向对象的封装。</p><a id="more"></a><h2 id="认识-Fit"><a href="#认识-Fit" class="headerlink" title="认识 Fit"></a>认识 Fit</h2><p>我使用的 C 语言的 SDK，官方有示例 demo，在 <code>fit_mgr</code> 文件中提供了一些示例，这些代码未必全部都要用到。创建一个最简单的 <code>.fit</code> 文件的流程是：</p><h3 id="写-fileid"><a href="#写-fileid" class="headerlink" title="写 fileid"></a>写 fileid</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fit_transaction_file</span><span class="params">(FIT_FILE type, FIT_MANUFACTURER manufacturer, FIT_UINT16 product, FIT_UINT32Z serial_number)</span></span>&#123;</span><br><span class="line">    <span class="comment">// Write file id message.</span></span><br><span class="line">    FIT_UINT8 local_mesg_number = <span class="number">0</span>;</span><br><span class="line">    FIT_FILE_ID_MESG file_id;</span><br><span class="line">    Fit_InitMesg(fit_mesg_defs[FIT_MESG_FILE_ID], &amp;file_id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @xaoxuu: type FIT_FILE_ACTIVITY = 4 活动数据</span></span><br><span class="line">    file_id.type = type;</span><br><span class="line">    <span class="comment">// @xaoxuu: 厂商</span></span><br><span class="line">    file_id.manufacturer = manufacturer;</span><br><span class="line">    <span class="comment">// @xaoxuu: 产品</span></span><br><span class="line">    <span class="comment">//        file_id.product_name</span></span><br><span class="line">    file_id.product = product;</span><br><span class="line">    <span class="comment">// @xaoxuu: 序列号</span></span><br><span class="line">    file_id.serial_number = serial_number;</span><br><span class="line">    <span class="comment">// @xaoxuu: 生产日期</span></span><br><span class="line">    <span class="comment">//        time_t now;</span></span><br><span class="line">    <span class="comment">//        time(&amp;now);</span></span><br><span class="line">    <span class="comment">//        file_id.time_created = now;</span></span><br><span class="line"></span><br><span class="line">    WriteMessageDefinition(local_mesg_number, fit_mesg_defs[FIT_MESG_FILE_ID], FIT_FILE_ID_MESG_DEF_SIZE, static_fp);</span><br><span class="line">    WriteMessage(local_mesg_number, &amp;file_id, FIT_FILE_ID_MESG_SIZE, static_fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fit_transaction_field_desc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Write a Field Description</span></span><br><span class="line">    FIT_UINT8 local_mesg_number = <span class="number">1</span>;</span><br><span class="line">    FIT_FIELD_DESCRIPTION_MESG field_description_mesg;</span><br><span class="line"></span><br><span class="line">    Fit_InitMesg(fit_mesg_defs[FIT_MESG_FIELD_DESCRIPTION], &amp;field_description_mesg);</span><br><span class="line">    field_description_mesg.developer_data_index = <span class="number">0</span>;</span><br><span class="line">    field_description_mesg.field_definition_number = <span class="number">0</span>;</span><br><span class="line">    field_description_mesg.fit_base_type_id = FIT_BASE_TYPE_UINT16;</span><br><span class="line">    WriteMessageDefinition(local_mesg_number, fit_mesg_defs[FIT_MESG_FIELD_DESCRIPTION], FIT_FIELD_DESCRIPTION_MESG_DEF_SIZE, static_fp);</span><br><span class="line">    WriteMessage(local_mesg_number, &amp;field_description_mesg, FIT_FIELD_DESCRIPTION_MESG_SIZE, static_fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="写-record"><a href="#写-record" class="headerlink" title="写 record"></a>写 record</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写入Record Defenition</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fit_transaction_record_def</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FIT_UINT8 local_mesg_number = <span class="number">2</span>;</span><br><span class="line">    WriteMessageDefinition(local_mesg_number, fit_mesg_defs[FIT_MESG_RECORD], FIT_RECORD_MESG_DEF_SIZE, static_fp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 循环写入record数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fit_transaction_record_msg</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> timestamp, <span class="keyword">int</span> position_lat, <span class="keyword">int</span> position_long, <span class="keyword">unsigned</span> <span class="keyword">int</span> distance, <span class="keyword">unsigned</span> <span class="keyword">short</span> altitude, <span class="keyword">unsigned</span> <span class="keyword">short</span> speed, <span class="keyword">unsigned</span> <span class="keyword">char</span> heart_rate)</span></span>&#123;</span><br><span class="line">    <span class="comment">//Record message</span></span><br><span class="line">    FIT_UINT8 local_mesg_number = <span class="number">2</span>;</span><br><span class="line">    FIT_RECORD_MESG record;</span><br><span class="line"></span><br><span class="line">    Fit_InitMesg(fit_mesg_defs[FIT_MESG_RECORD], &amp;record);</span><br><span class="line">    record.timestamp = timestamp;</span><br><span class="line">    record.position_lat = position_lat;</span><br><span class="line">    record.position_long = position_long;</span><br><span class="line">    record.distance = distance;</span><br><span class="line">    record.altitude = altitude;</span><br><span class="line">    record.speed = speed;</span><br><span class="line">    record.heart_rate = heart_rate;</span><br><span class="line">    WriteMessage(local_mesg_number,&amp;record,FIT_RECORD_MESG_SIZE,static_fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="开始封装"><a href="#开始封装" class="headerlink" title="开始封装"></a>开始封装</h2><h3 id="设计模型"><a href="#设计模型" class="headerlink" title="设计模型"></a>设计模型</h3><p>FitActivity.h</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  FitAcitvity.h</span></span><br><span class="line"><span class="comment">//  FitSDK</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by xaoxuu on 04/07/2017.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017 xaoxuu. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">FitActivityRecord</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, FitActivityType) &#123;</span><br><span class="line">    FitActivityTypeWalk = <span class="number">11</span>, <span class="comment">// 枚举值等于FIT_SPORT值</span></span><br><span class="line">    FitActivityTypeRun = <span class="number">1</span>,</span><br><span class="line">    FitActivityTypeRide = <span class="number">2</span>,</span><br><span class="line">    FitActivityTypeSwim = <span class="number">5</span>,</span><br><span class="line">    FitActivityTypeHike = <span class="number">17</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">FitActivity</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @xaoxuu: fit 文件路径</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *path;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @xaoxuu: 活动名</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @xaoxuu: 活动类型</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) FitActivityType type;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @xaoxuu: 活动类型</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *typeString;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @xaoxuu: records</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSMutableArray</span>&lt;FitActivityRecord *&gt; *records;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 添加一条record</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param record record</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)addRecord:(<span class="keyword">void</span> (^)(FitActivityRecord *aRecord))record;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">FitActivityRecord</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @xaoxuu: timestamp</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="keyword">unsigned</span> <span class="keyword">int</span> timestamp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @xaoxuu: position_lat</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="keyword">int</span> position_lat;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @xaoxuu: position_long</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="keyword">int</span> position_long;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @xaoxuu: distance</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="keyword">unsigned</span> <span class="keyword">int</span> distance;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @xaoxuu: altitude</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="keyword">unsigned</span> <span class="keyword">short</span> altitude;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @xaoxuu: speed</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="keyword">unsigned</span> <span class="keyword">short</span> speed;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @xaoxuu: heart_rate</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="keyword">unsigned</span> <span class="keyword">char</span> heart_rate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>FitActivity.m</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  FitAcitvity.m</span></span><br><span class="line"><span class="comment">//  FitSDK</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by xaoxuu on 04/07/2017.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017 xaoxuu. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;FitAcitvity.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">FitActivity</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        _records = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">        <span class="keyword">self</span>.type = FitActivityTypeWalk;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setType:(FitActivityType)type&#123;</span><br><span class="line">    _type = type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> FitActivityTypeWalk:</span><br><span class="line">            _typeString = <span class="string">@&quot;walk&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FitActivityTypeRun:</span><br><span class="line">            _typeString = <span class="string">@&quot;run&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FitActivityTypeRide:</span><br><span class="line">            _typeString = <span class="string">@&quot;ride&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FitActivityTypeSwim:</span><br><span class="line">            _typeString = <span class="string">@&quot;swim&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FitActivityTypeHike:</span><br><span class="line">            _typeString = <span class="string">@&quot;hike&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name&#123;</span><br><span class="line">    _name = name;</span><br><span class="line">    _path = [<span class="keyword">self</span> pathWithName:name];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addRecord:(<span class="keyword">void</span> (^)(FitActivityRecord *aRecord))record&#123;</span><br><span class="line">    <span class="keyword">if</span> (record) &#123;</span><br><span class="line">        FitActivityRecord *rec = [FitActivityRecord new];</span><br><span class="line">        record(rec);</span><br><span class="line">        [<span class="keyword">self</span>.records addObject:rec];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)pathWithName:(<span class="built_in">NSString</span> *)name&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *path = [[<span class="built_in">NSTemporaryDirectory</span>() stringByAppendingPathComponent:<span class="string">@&quot;com.xaoxuu.fitsdk&quot;</span>] stringByAppendingPathComponent:name];</span><br><span class="line">    path = [path stringByAppendingPathExtension:<span class="string">@&quot;fit&quot;</span>];</span><br><span class="line">    <span class="comment">// create dir if not exist</span></span><br><span class="line">    <span class="built_in">NSFileManager</span> *fm = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">    <span class="built_in">NSString</span> *dir = path.stringByDeletingLastPathComponent;</span><br><span class="line">    <span class="built_in">BOOL</span> result = [fm createDirectoryAtPath:dir withIntermediateDirectories:<span class="literal">YES</span> attributes:<span class="literal">nil</span> error:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;can not create the directory at path %@&quot;</span>,dir);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">FitActivityRecord</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        _timestamp = <span class="number">702940946</span>;</span><br><span class="line">        _position_lat = <span class="number">0</span>;</span><br><span class="line">        _position_long = <span class="number">0</span>;</span><br><span class="line">        _distance = <span class="number">0</span>;</span><br><span class="line">        _altitude = <span class="number">0</span>;</span><br><span class="line">        _speed = <span class="number">0</span>;</span><br><span class="line">        _heart_rate = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="封装接口"><a href="#封装接口" class="headerlink" title="封装接口"></a>封装接口</h3><p>FitSDK.h</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  FitSDK.h</span></span><br><span class="line"><span class="comment">//  FitSDK</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by xaoxuu on 04/07/2017.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017 xaoxuu. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;FitAcitvity.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">FitSDK</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 创建一个活动数据fit文件</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param activity 活动数据</span></span><br><span class="line"><span class="comment"> @return 活动数据模型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (FitActivity *)createActivity:(<span class="keyword">void</span> (^)(FitActivity *activity))activity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>FitSDK.m</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  FitSDK.m</span></span><br><span class="line"><span class="comment">//  FitSDK</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by xaoxuu on 04/07/2017.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017 xaoxuu. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;FitSDK.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;fit_mgr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">FitSDK</span></span></span><br><span class="line"></span><br><span class="line">+ (FitActivity *)createActivity:(<span class="keyword">void</span> (^)(FitActivity *activity))activity&#123;</span><br><span class="line">    FitActivity *act = [FitActivity new];</span><br><span class="line">    <span class="keyword">if</span> (activity) &#123;</span><br><span class="line">        activity(act);</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> createActivityWithModel:act];</span><br><span class="line">    <span class="keyword">return</span> act;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)createActivityWithModel:(FitActivity *)activity&#123;</span><br><span class="line">    <span class="comment">// @xaoxuu: fit file</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *fp = [activity.path cStringUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    fit_transaction(fp, activity.type, ^&#123;</span><br><span class="line">        [activity.records enumerateObjectsUsingBlock:^(FitActivityRecord * _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">            fit_transaction_record_msg(obj.timestamp, obj.position_lat, obj.position_long, obj.distance, obj.altitude, obj.speed, obj.heart_rate);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">FitActivity *activity = [FitSDK createActivity:^(FitActivity *activity) &#123;</span><br><span class="line">    activity.name = <span class="string">@&quot;test&quot;</span>;</span><br><span class="line">    activity.type = FitActivityTypeRun;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">        [activity addRecord:^(FitActivityRecord *aRecord) &#123;</span><br><span class="line">            aRecord.timestamp = [[<span class="built_in">NSDate</span> date] timeIntervalSince1970] - <span class="number">631065600</span>;</span><br><span class="line">            aRecord.position_lat = <span class="number">495280430</span>+i*<span class="number">1000</span>;</span><br><span class="line">            aRecord.position_long = <span class="number">-872696681</span>-i*<span class="number">1500</span>;</span><br><span class="line">            aRecord.distance = <span class="number">2</span>+i/<span class="number">100</span>;</span><br><span class="line">            aRecord.altitude = <span class="number">287.2</span>+i;</span><br><span class="line">            aRecord.speed = <span class="number">0.29</span>+i/<span class="number">50</span>;</span><br><span class="line">            aRecord.heart_rate = <span class="number">68</span>+i/<span class="number">4</span>;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// activity.path就是生成的fit文件路径</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, activity.path);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.thisisant.com/resources/fit/&quot; target=&quot;_blank&quot; rel=&quot;noopener external nofollow noreferrer&quot;&gt;fit&lt;/a&gt; 是一种文件协议，体积小巧，多用于可穿戴设备记录、传输运动与健康数据。官方提供了 C、C++、Java 语言的 SDK 和非常详细的使用文档。因此在 iOS 端接入 fit 就需要在 C 或 C++ 的 SDK 基础上进行一点面向对象的封装。&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发" scheme="https://xaoxuu.com/blog/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="https://xaoxuu.com/blog/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>iOS 让代码实现“冷却”机制</title>
    <link href="https://xaoxuu.com/blog/2017-05-07-code-cooldown/"/>
    <id>https://xaoxuu.com/blog/2017-05-07-code-cooldown/</id>
    <published>2017-05-06T16:00:00.000Z</published>
    <updated>2017-05-06T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>首先我个人认为设计合理、逻辑严谨的代码是不需要强行冷却的，但是我们不能保证我们面对的代码永远都是完美的，所以我在 <a href="https://github.com/xaoxuu/AXKit" target="_blank" rel="noopener external nofollow noreferrer">AXKit</a> 中就提供了这个冷却机制以延长那些癌症晚期的代码的寿命。</p><a id="more"></a><ul><li><strong>优点：</strong>执行代码像放技能一样，可以强行打破死循环、避免死循环、避免过高频率访问某一资源。</li><li><strong>缺点：</strong>治标不治本，最好的解决办法是找出会产生问题的代码进行重构，从根源上解决问题。</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="场景1"><a href="#场景1" class="headerlink" title="场景1"></a>场景1</h3><p>某种耗时耗能的操作，希望在某种条件下触发，但又担心用户频繁触发，例如进入某个页面的时候同步一下设备电量、或者同步一下运动数据；进入某个页面预加载一下子页面的网络数据……就可以这样：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @xaoxuu: 重新获取数据源并刷新tableView</span></span><br><span class="line">- (<span class="keyword">void</span>)reloadDataAndRefreshTableView&#123;</span><br><span class="line">    <span class="comment">// 无论如何，2秒内最多只会执行一次此方法。</span></span><br><span class="line">    ax_dispatch_cooldown(<span class="number">0</span>, <span class="number">2</span>, @<span class="string">&quot;reload data and refresh table view&quot;</span>, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [self.dataList removeAllObjects];</span><br><span class="line">        [self reloadTableView];</span><br><span class="line">    &#125;, ^&#123;</span><br><span class="line">        AXLogFailure(@<span class="string">&quot;操作过于频繁&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">- (IBAction)btn1:(UIButton *)sender &#123;</span><br><span class="line">    <span class="comment">// @xaoxuu: 立即在主线程施放大招，冷却时间是60秒。</span></span><br><span class="line">    ax_dispatch_cooldown(<span class="number">0</span>, <span class="number">60</span>, self, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        AXLogSuccess(@<span class="string">&quot;技能施放成功！&quot;</span>);</span><br><span class="line">    &#125;, ^&#123;</span><br><span class="line">        AXLogFailure(@<span class="string">&quot;抱歉，技能在冷却中&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (IBAction)btn2:(UIButton *)sender &#123;</span><br><span class="line">    <span class="comment">// @xaoxuu: 延迟2秒后在后台默默施放大招，冷却时间是120秒。</span></span><br><span class="line">    ax_dispatch_cooldown(<span class="number">2</span>, <span class="number">120</span>, self, dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        AXLogSuccess(@<span class="string">&quot;技能施放成功！&quot;</span>);</span><br><span class="line">    &#125;, ^&#123;</span><br><span class="line">        AXLogFailure(@<span class="string">&quot;抱歉，技能在冷却中&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// @xaoxuu: 两者的token相同则共享冷却时间。</span></span><br></pre></td></tr></table></figure><h3 id="场景2"><a href="#场景2" class="headerlink" title="场景2"></a>场景2</h3><p>如何强行打破死循环？说实话我是没有遇到这种需求，仅仅是这个机制有这种能力，觉得挺有趣，就尝试一下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @xaoxuu: 自己调用自己，无限循环</span></span><br><span class="line">- (<span class="keyword">void</span>)loop&#123;</span><br><span class="line">    AXLogFunc();</span><br><span class="line">    [self loop];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @xaoxuu: 自己调用自己，但是发现代码在冷却，所以就失效了，一个环节被中断，死循环就被打破了</span></span><br><span class="line">- (<span class="keyword">void</span>)loop&#123;</span><br><span class="line">    AXLogFunc();</span><br><span class="line">    ax_dispatch_cooldown(<span class="number">0</span>, <span class="number">0.0001</span>, @<span class="string">&quot;loop&quot;</span>, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [self loop];</span><br><span class="line">    &#125;, nil);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>简单地说，就是给每一个代码块分配一个 <code>dispatch_after</code> 的函数，执行的时候开始计时，并且函数标记为 <code>disable</code>，计时结束后重新 <code>enable</code>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 拥有冷却机制的dispatch</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param delay 延迟时间</span></span><br><span class="line"><span class="comment"> @param cooldown 冷却时间</span></span><br><span class="line"><span class="comment"> @param token 冷却计时的token，如果相同，则共享冷却时间</span></span><br><span class="line"><span class="comment"> @param queue 指定线程</span></span><br><span class="line"><span class="comment"> @param block 要执行的block</span></span><br><span class="line"><span class="comment"> @param block_cooling 如果在冷却中要执行的block</span></span><br><span class="line"><span class="comment"> @return 操作口令（用于取消此操作）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">ax_dispatch_operation_t</span> <span class="title">ax_dispatch_cooldown</span><span class="params">(NSTimeInterval delay, NSTimeInterval cooldown,id token, <span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span>, <span class="keyword">void</span> (^block)(<span class="keyword">void</span>), <span class="keyword">void</span> (^ __nullable block_cooling)(<span class="keyword">void</span>))</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!token) &#123;</span><br><span class="line">        token = @<span class="string">&quot;default token&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">queue</span>) &#123;</span><br><span class="line">        <span class="built_in">queue</span> = dispatch_get_main_queue();</span><br><span class="line">    &#125;</span><br><span class="line">    BOOL cooling = is_cooling(token);</span><br><span class="line">    <span class="keyword">if</span> (cooling) &#123;</span><br><span class="line">        <span class="keyword">if</span> (block_cooling) &#123;</span><br><span class="line">            block_cooling();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        set_is_cooling(YES, token);</span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (<span class="keyword">int64_t</span>)(cooldown * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            set_is_cooling(NO, token);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> ax_dispatch_cancellable(delay, <span class="built_in">queue</span>, block);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，对于代码是否正在冷却的判断利于了runtime机制，相当于新增了一个属性，用来保存是否正在冷却的状态：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">void</span> *AXBlockWrapperKey = &amp;AXBlockWrapperKey;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> BOOL <span class="title">is_cooling</span><span class="params">(id token)</span></span>&#123;</span><br><span class="line">    NSNumber *cooling = objc_getAssociatedObject(token, AXBlockWrapperKey);</span><br><span class="line">    <span class="keyword">return</span> cooling.boolValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set_is_cooling</span><span class="params">(BOOL cooling, id token)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!token) &#123;</span><br><span class="line">        token = @<span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    objc_setAssociatedObject(token, AXBlockWrapperKey, @(cooling), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先我个人认为设计合理、逻辑严谨的代码是不需要强行冷却的，但是我们不能保证我们面对的代码永远都是完美的，所以我在 &lt;a href=&quot;https://github.com/xaoxuu/AXKit&quot; target=&quot;_blank&quot; rel=&quot;noopener external nofollow noreferrer&quot;&gt;AXKit&lt;/a&gt; 中就提供了这个冷却机制以延长那些癌症晚期的代码的寿命。&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发" scheme="https://xaoxuu.com/blog/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="https://xaoxuu.com/blog/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>Runtime 简单应用：AXKit 手势分类实现原理</title>
    <link href="https://xaoxuu.com/blog/2017-04-07-gesture/"/>
    <id>https://xaoxuu.com/blog/2017-04-07-gesture/</id>
    <published>2017-04-06T16:00:00.000Z</published>
    <updated>2017-05-06T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>手势的应用场景很多，如果你觉得系统给我们提供的方法使用起来并不那么方便，那么本文可能对你有帮助，因为我用block对其进行了封装。</p><a id="more"></a><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>场景1：为了调试某个功能，快速给一个视图添加手势，要求轻触的时候执行某段代码。</li><li>场景2：tabbar按钮双击刷新列表，要求双击的速度在一秒内，执行某段代码。</li><li>场景3：给某个图片添加捏合手势以及旋转手势。</li><li>......</li></ul><p>使用AXKit，可以轻易实现上述几种场景中的需求：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span>.view ax_addTapGestureHandler:^(<span class="built_in">UITapGestureRecognizer</span> * _Nonnull sender) &#123;</span><br><span class="line">    <span class="comment">// 轻触的时候要执行的代码</span></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.view ax_addDoubleTapGesture:<span class="literal">nil</span> duration:<span class="number">1</span> handler:^(<span class="built_in">UITapGestureRecognizer</span> * _Nonnull sender) &#123;</span><br><span class="line">    <span class="comment">// 双击的时候要执行的代码</span></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 捏合手势</span></span><br><span class="line">[<span class="keyword">self</span>.view ax_addPinchGesture:^(<span class="built_in">UIPinchGestureRecognizer</span> * _Nonnull sender) &#123;</span><br><span class="line">    <span class="comment">// 对手势对象（sender）的配置</span></span><br><span class="line">    sender.view.transform = <span class="built_in">CGAffineTransformScale</span>(sender.view.transform, sender.scale, sender.scale);</span><br><span class="line">    sender.scale = <span class="number">1</span>;</span><br><span class="line">&#125; handler:^(<span class="built_in">UIPinchGestureRecognizer</span> * _Nonnull sender) &#123;</span><br><span class="line">    <span class="comment">// 捏合的时候要执行的代码</span></span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// 旋转手势</span></span><br><span class="line">[<span class="keyword">self</span>.view ax_addRotationGesture:^(<span class="built_in">UIRotationGestureRecognizer</span> * _Nonnull sender) &#123;</span><br><span class="line">    <span class="comment">// 对手势对象（sender）的配置</span></span><br><span class="line">    sender.view.transform = <span class="built_in">CGAffineTransformRotate</span>(sender.view.transform, sender.rotation);</span><br><span class="line">    sender.rotation = <span class="number">0</span>;</span><br><span class="line">&#125; handler:^(<span class="built_in">UIRotationGestureRecognizer</span> * _Nonnull sender) &#123;</span><br><span class="line">    <span class="comment">// 旋转的时候要执行的代码</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><p>推荐CocoaPods方式，在podfile中添加一行：</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">pod <span class="string">&#x27;AXKit&#x27;</span></span><br></pre></td></tr></table></figure><p>然后在终端中执行 <code>pod install</code> 即可完成安装。</p><p>AXKit的全局头文件是：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过CocoaPods或静态库方式安装</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;AXKit/AXKit.h&gt;</span></span></span><br><span class="line"><span class="comment">// 通过手动方式</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;AXKit.h&quot;</span></span></span><br></pre></td></tr></table></figure><h2 id="接口声明"><a href="#接口声明" class="headerlink" title="接口声明"></a>接口声明</h2><p>直接上头文件源码，注释很详细：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIView</span> (<span class="title">AXGestureExtension</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 处理tap手势</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param handler 处理手势的block</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)ax_addTapGestureHandler:(<span class="keyword">void</span> (^)(<span class="built_in">UITapGestureRecognizer</span> *sender))handler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 添加一个tap手势，并处理</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param tap     tap</span></span><br><span class="line"><span class="comment"> @param handler 处理手势的block</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)ax_addTapGesture:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">UITapGestureRecognizer</span> *sender))tap handler:(<span class="keyword">void</span> (^)(<span class="built_in">UITapGestureRecognizer</span> *sender))handler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 添加一个tap手势，并处理，附加动画效果</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param tap      tap</span></span><br><span class="line"><span class="comment"> @param handler  处理手势的block</span></span><br><span class="line"><span class="comment"> @param scale    动画比例</span></span><br><span class="line"><span class="comment"> @param duration 持续时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)ax_addTapGesture:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">UITapGestureRecognizer</span> *sender))tap handler:(<span class="keyword">void</span> (^)(<span class="built_in">UITapGestureRecognizer</span> *sender))handler animatedScale:(<span class="built_in">CGFloat</span>)scale duration:(<span class="built_in">NSTimeInterval</span>)duration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 添加一个双击手势，并处理</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param doubleTap double tap</span></span><br><span class="line"><span class="comment"> @param duration  双击间隔时间</span></span><br><span class="line"><span class="comment"> @param handler   处理手势的block</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)ax_addDoubleTapGesture:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">UITapGestureRecognizer</span> *sender))doubleTap duration:(<span class="built_in">NSTimeInterval</span>)duration handler:(<span class="keyword">void</span> (^)(<span class="built_in">UITapGestureRecognizer</span> *sender))handler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 添加一个长按手势，并处理</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param longPress 长按手势</span></span><br><span class="line"><span class="comment"> @param handler   处理手势的block</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)ax_addLongPressGesture:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">UILongPressGestureRecognizer</span> *sender))longPress handler:(<span class="keyword">void</span> (^)(<span class="built_in">UILongPressGestureRecognizer</span> *sender))handler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 添加一个轻扫手势，并处理</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param swipe   轻扫</span></span><br><span class="line"><span class="comment"> @param handler 处理手势的block</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)ax_addSwipeGesture:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">UISwipeGestureRecognizer</span> *sender))swipe handler:(<span class="keyword">void</span> (^)(<span class="built_in">UISwipeGestureRecognizer</span> *sender))handler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 添加一个滑动手势，并处理</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param pan     滑动</span></span><br><span class="line"><span class="comment"> @param handler 处理手势的block</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)ax_addPanGesture:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">UIPanGestureRecognizer</span> *sender))pan handler:(<span class="keyword">void</span> (^)(<span class="built_in">UIPanGestureRecognizer</span> *sender))handler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 添加一个屏幕边缘滑动手势，并处理</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param screenEdgePan  屏幕边缘滑动</span></span><br><span class="line"><span class="comment"> @param handler        处理手势的block</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)ax_addScreenEdgePanGesture:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">UIScreenEdgePanGestureRecognizer</span> *sender))screenEdgePan handler:(<span class="keyword">void</span> (^)(<span class="built_in">UIScreenEdgePanGestureRecognizer</span> *sender))handler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 添加一个双指缩放手势，并处理</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param pinch   双指缩放手势</span></span><br><span class="line"><span class="comment"> @param handler 处理手势的block</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> sender.view.transform = CGAffineTransformScale(sender.view.transform, sender.scale, sender.scale);</span></span><br><span class="line"><span class="comment"> sender.scale = 1;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)ax_addPinchGesture:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">UIPinchGestureRecognizer</span> *sender))pinch handler:(<span class="keyword">void</span> (^)(<span class="built_in">UIPinchGestureRecognizer</span> *sender))handler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 添加一个双指旋转手势，并处理</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param rotation 双指旋转手势</span></span><br><span class="line"><span class="comment"> @param handler  处理手势的block</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> sender.view.transform = CGAffineTransformRotate(sender.view.transform, sender.rotation);</span></span><br><span class="line"><span class="comment"> sender.rotation = 0;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)ax_addRotationGesture:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">UIRotationGestureRecognizer</span> *sender))rotation handler:(<span class="keyword">void</span> (^)(<span class="built_in">UIRotationGestureRecognizer</span> *sender))handler;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p>以最简单的tap手势为例，其实现如下：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)ax_addTapGestureHandler:(<span class="keyword">void</span> (^)(<span class="built_in">UITapGestureRecognizer</span> *sender))handler&#123;</span><br><span class="line">    <span class="comment">// 创建手势实例</span></span><br><span class="line">    <span class="built_in">UITapGestureRecognizer</span> *gesture = [<span class="built_in">UITapGestureRecognizer</span> new];</span><br><span class="line">    <span class="comment">// 将手势和target绑定</span></span><br><span class="line">    AXBindGestureAndTarget(gesture, AXDefaultTarget);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>AXBindGestureAndTarget(gesture, AXDefaultTarget)</code> 用了inline函数：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> AXBindGestureAndTarget(<span class="built_in">UIGestureRecognizer</span> *gesture, AXEventTarget *target)&#123;</span><br><span class="line">    [gesture addTarget:target action:<span class="keyword">@selector</span>(handleEvent:)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AXDefaultTarget</code> 则是宏定义，因为大部分地方用到的都是固定的三个参数：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AXDefaultTarget AXTargetWith(self, gesture, handler)</span></span><br><span class="line"><span class="comment">// 依据self类、手势实例、handler代码块创建一个唯一的target</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> AXEventTarget *AXTargetWith(<span class="built_in">UIView</span> *obj, __kindof <span class="built_in">UIGestureRecognizer</span> *gesture, <span class="keyword">id</span> handler)&#123;</span><br><span class="line">    <span class="comment">// create a target with &lt;handler&gt;</span></span><br><span class="line">    AXEventTarget *target = [AXEventTarget targetWithHandler:handler];</span><br><span class="line">    <span class="comment">// add a &lt;gesture&gt; to target</span></span><br><span class="line">    [obj addGestureRecognizer:gesture];</span><br><span class="line">    <span class="comment">// save target (gesture + handler) to dictionary</span></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *gestures = objc_getAssociatedObject(obj, <span class="built_in">UIViewGestureAXBlockWrapperKey</span>);</span><br><span class="line">    <span class="keyword">if</span> (!gestures) &#123;</span><br><span class="line">        gestures = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">        objc_setAssociatedObject(obj, <span class="built_in">UIViewGestureAXBlockWrapperKey</span>, gestures, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSMutableSet</span> *handlers = gestures[<span class="built_in">NSStringFromPointer</span>(gesture)];</span><br><span class="line">    <span class="keyword">if</span> (!handlers) &#123;</span><br><span class="line">        handlers = [<span class="built_in">NSMutableSet</span> set];</span><br><span class="line">        gestures[<span class="built_in">NSStringFromPointer</span>(gesture)] = handlers;</span><br><span class="line">    &#125;</span><br><span class="line">    [handlers addObject:target];</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用到了一个 <code>AXEventTarget</code> 类，这个类的功能就是保存 <code>handler</code>，并在需要的时候执行 <code>handler</code>。这个分类的实现参考了BlocksKit的实现原理，对其进行扩展，用到了runtime机制，至于什么是runtime，我们稍后再作讨论。本文稍后会进行更新，补充实现的思路、更详细的细节。</p><h2 id="附：关于runtime"><a href="#附：关于runtime" class="headerlink" title="附：关于runtime"></a>附：关于runtime</h2><p><strong>runtime是运行时一些机制，其中最主要的是消息机制</strong>。它与编译时语言的最大区别在于它在运行的时候才去确定要调用的函数类型，如果一个方法没有实现体，那么在编译阶段调用并不会报错，而编译时语言调用一个未实现的函数就会报错。运行时语言调用方法的本质是让对象发送<strong>消息</strong>，属于<strong>动态调用</strong>，编译时并不能真正决定调用哪个方法。下面是runtime的一些应用场景：</p><ul><li>动态添加方法</li><li>拦截系统自带的方法调用(Swizzle)、交换方法</li><li>json转模型（KVC）</li><li>给分类增加属性</li><li>实现NSCoding的归档解档</li><li>万能控制器跳转</li><li>JSpatch热更新（苹果不再允许使用热更新）</li><li>插件的开发（Xcode8已禁止插件）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;手势的应用场景很多，如果你觉得系统给我们提供的方法使用起来并不那么方便，那么本文可能对你有帮助，因为我用block对其进行了封装。&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发" scheme="https://xaoxuu.com/blog/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="https://xaoxuu.com/blog/tags/ios/"/>
    
      <category term="开源库" scheme="https://xaoxuu.com/blog/tags/%E5%BC%80%E6%BA%90%E5%BA%93/"/>
    
      <category term="Runtime" scheme="https://xaoxuu.com/blog/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>iOS 分层架构初探</title>
    <link href="https://xaoxuu.com/blog/2017-03-29-ios-layered-architecture/"/>
    <id>https://xaoxuu.com/blog/2017-03-29-ios-layered-architecture/</id>
    <published>2017-03-28T16:00:00.000Z</published>
    <updated>2017-03-28T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>这篇博客把分层架构讲的很形象： <a href="https://blog.csdn.net/hanxuemin12345/article/details/8544957" target="_blank" rel="noopener external nofollow noreferrer">三层架构(我的理解及详细分析)</a> 。</p><h2 id="为什么要分层"><a href="#为什么要分层" class="headerlink" title="为什么要分层"></a>为什么要分层</h2><p>代码系统分层就好比管理分层一样，各司其职，优点非常多，对于软件后期的维护来说是十分有必要的。它的优点有：</p><ul><li><p>解耦</p><p>上一层依赖于下一层，如果测试下一层没有问题，那么问题就只有可能发现在本层了，便于发现和改正BUG。体现了“高内聚，低耦合”的思想。</p></li><li><p>分工明确</p><p>各个层次分工明确，将一个复杂问题简单拆分了。</p></li></ul><ul><li><p>便于维护</p><p>各层间通过接口解耦，接口与实现分离，从而可以非常简单的替换掉实现，或者实际实现等。</p></li></ul><ul><li><p>逻辑复用（代码复用）和劳动成本的减少</p><p>分层的根本在于代码的复用和劳动成本的减少。分层的最理想化的结果是实现层与层之间的互不依赖的内部实现，所谓的即插即用。</p></li></ul>]]></content>
    
    <summary type="html">
    
      代码系统分层就好比管理分层一样，各司其职，优点非常多，对于软件后期的维护来说是十分有必要的。
    
    </summary>
    
    
      <category term="开发" scheme="https://xaoxuu.com/blog/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="https://xaoxuu.com/blog/tags/ios/"/>
    
      <category term="架构" scheme="https://xaoxuu.com/blog/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Excel 导出 iOS、Android 多国语言工具</title>
    <link href="https://xaoxuu.com/blog/2017-03-08-ios-localizable-string/"/>
    <id>https://xaoxuu.com/blog/2017-03-08-ios-localizable-string/</id>
    <published>2017-03-07T16:00:00.000Z</published>
    <updated>2017-03-07T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="1-下载，解压"><a href="#1-下载，解压" class="headerlink" title="1. 下载，解压"></a>1. 下载，解压</h2><p>下载工具：<a href="https://github.com/CatchZeng/Localizable.strings2Excel" target="_blank" rel="noopener external nofollow noreferrer">https://github.com/CatchZeng/Localizable.strings2Excel</a> 。</p><p>解压开之后把里面的两个zip也解压开</p><h2 id="2-安装工具"><a href="#2-安装工具" class="headerlink" title="2. 安装工具"></a>2. 安装工具</h2><h3 id="pyexcelerator"><a href="#pyexcelerator" class="headerlink" title="pyexcelerator"></a>pyexcelerator</h3><p>打开命令行工具，cd到 <code>.../Localizable.strings2Excel-master/pyexcelerator-0.6.4.1</code> 文件夹，执行：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo python setup.py install</span><br></pre></td></tr></table></figure><h3 id="xld"><a href="#xld" class="headerlink" title="xld"></a>xld</h3><p>cd到 <code>.../Localizable.strings2Excel-master/xlrd-1.0.0</code> 文件夹，执行：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo python setup.py install</span><br></pre></td></tr></table></figure><h2 id="3-使用脚本"><a href="#3-使用脚本" class="headerlink" title="3. 使用脚本"></a>3. 使用脚本</h2><p>cd到 <code>.../Localizable.strings2Excel-master/python</code> 文件夹</p><p>如需将Excel表格转换成Localizable.strings或者strings.xml文件，执行：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">python LocalizableBack.py -f xxx/xxx.xls -t xxx/xxx</span><br></pre></td></tr></table></figure><p>如需将Localizable.strings或者strings.xml文件转换成Excel表格，执行：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">python Localizable.py -f xxx/ -t xxx/</span><br></pre></td></tr></table></figure><blockquote><p>工具的链接在：<a href="https://github.com/CatchZeng/Localizable.strings2Excel" target="_blank" rel="noopener external nofollow noreferrer">GitHub/CatchZeng</a> 感谢作者编写了如此方便的工具！<br>更多详细使用脚本请阅读<a href="https://github.com/CatchZeng/Localizable.strings2Excel" target="_blank" rel="noopener external nofollow noreferrer">官方README文件</a> 。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="开发" scheme="https://xaoxuu.com/blog/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="https://xaoxuu.com/blog/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>如何封装 Framework 静态库</title>
    <link href="https://xaoxuu.com/blog/2016-11-06-ios-framework/"/>
    <id>https://xaoxuu.com/blog/2016-11-06-ios-framework/</id>
    <published>2016-11-05T16:00:00.000Z</published>
    <updated>2016-11-05T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>像工作中使用的第三方SDK基本上都是闭源的，因为公司不能把自己的机密泄露出去。所以当需要给别人提供SDK但不让他们知道代码的实现时就需要封装成静态库。</p><a id="more"></a><p>静态库有 <code>.a</code> 库和 <code>.framework</code> 库，苹果官方更建议我们使用 <code>.framework</code> 库，因为其更加强大。</p><blockquote><p>.a是一个纯二进制文件，.framework中除了有二进制文件之外还有资源文件。<br>.a文件不能直接使用，至少要有.h文件配合，.framework文件可以直接使用。<br>.a + .h + sourceFile = .framework。</p></blockquote><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>参考这篇博客： <a href="http://www.cocoachina.com/articles/11022" target="_blank" rel="noopener external nofollow noreferrer">iOS开发——创建你自己的Framework</a> 讲解的非常详细。</p><p>总结一下步骤：</p><ol><li>创建工程，最好是起名为xxxDemo例如AXKitDemo，然后新建一个target名为AXKit，并把原来的工程改名为AXKit。（为了方便在demo中调试静态库）</li><li>新建一个target，选择类型为framework。</li><li>在framework中创建需要封装的类，写好代码。</li><li>在 <code>Build Setting</code> 里更改参数，<code>Math-O Type</code> 为 <code>Static Library</code>。</li><li>在 <code>Build Phases -&gt; Headers</code> 里将需要暴露出来的头文件从 <code>Project</code> 移动到 <code>Public</code>。</li><li>添加一个 <code>Aggregate</code> 的target，并添加运行脚本。目的是把编译出来的真机版和模拟器版的framework合并。</li><li>模拟器编译一下，真机编译一下，然后 <code>Aggregate</code> 编译一下，然后在项目的 <code>Products</code> 文件夹里就有了最终生成的静态库。</li></ol><p><code>Aggregate</code> 的Run Script脚本：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if [ &quot;$&#123;ACTION&#125;&quot; &#x3D; &quot;build&quot; ]</span><br><span class="line">then</span><br><span class="line">INSTALL_DIR&#x3D;$&#123;SRCROOT&#125;&#x2F;Products&#x2F;$&#123;PROJECT_NAME&#125;.framework</span><br><span class="line"></span><br><span class="line">DEVICE_DIR&#x3D;$&#123;BUILD_ROOT&#125;&#x2F;$&#123;CONFIGURATION&#125;-iphoneos&#x2F;$&#123;PROJECT_NAME&#125;.framework</span><br><span class="line"></span><br><span class="line">SIMULATOR_DIR&#x3D;$&#123;BUILD_ROOT&#125;&#x2F;$&#123;CONFIGURATION&#125;-iphonesimulator&#x2F;$&#123;PROJECT_NAME&#125;.framework</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if [ -d &quot;$&#123;INSTALL_DIR&#125;&quot; ]</span><br><span class="line">then</span><br><span class="line">rm -rf &quot;$&#123;INSTALL_DIR&#125;&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">mkdir -p &quot;$&#123;INSTALL_DIR&#125;&quot;</span><br><span class="line"></span><br><span class="line">cp -R &quot;$&#123;DEVICE_DIR&#125;&#x2F;&quot; &quot;$&#123;INSTALL_DIR&#125;&#x2F;&quot;</span><br><span class="line">#ditto &quot;$&#123;DEVICE_DIR&#125;&#x2F;Headers&quot; &quot;$&#123;INSTALL_DIR&#125;&#x2F;Headers&quot;</span><br><span class="line"></span><br><span class="line">lipo -create &quot;$&#123;DEVICE_DIR&#125;&#x2F;$&#123;PROJECT_NAME&#125;&quot; &quot;$&#123;SIMULATOR_DIR&#125;&#x2F;$&#123;PROJECT_NAME&#125;&quot; -output &quot;$&#123;INSTALL_DIR&#125;&#x2F;$&#123;PROJECT_NAME&#125;&quot;</span><br><span class="line"></span><br><span class="line">#open &quot;$&#123;DEVICE_DIR&#125;&quot;</span><br><span class="line">#open &quot;$&#123;SRCROOT&#125;&#x2F;Products&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;像工作中使用的第三方SDK基本上都是闭源的，因为公司不能把自己的机密泄露出去。所以当需要给别人提供SDK但不让他们知道代码的实现时就需要封装成静态库。&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发" scheme="https://xaoxuu.com/blog/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="https://xaoxuu.com/blog/tags/ios/"/>
    
      <category term="静态库" scheme="https://xaoxuu.com/blog/tags/%E9%9D%99%E6%80%81%E5%BA%93/"/>
    
      <category term="Framework" scheme="https://xaoxuu.com/blog/tags/framework/"/>
    
  </entry>
  
  <entry>
    <title>从 UIImageView 指定点取色</title>
    <link href="https://xaoxuu.com/blog/2016-09-14-get-color/"/>
    <id>https://xaoxuu.com/blog/2016-09-14-get-color/</id>
    <published>2016-09-13T16:00:00.000Z</published>
    <updated>2016-10-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>开发中有时候会遇到这样的需求，要给用户一个取色板，让用户从中自由地选取颜色，用来改变主题或者控制灯具的颜色等。这时候我们就需要获取一个视图的指定坐标的颜色值。</p><a id="more"></a><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>有时候我们可能会需要一个取色器，例如我的蓝牙灯项目，让用户从一个取色器中随意取色：</p><p>那么如何从一个图片中取色呢？ <a href="https://stackoverflow.com/questions/3773245/simple-way-to-read-pixel-color-values-from-an-png-image-on-the-iphone" target="_blank" rel="noopener external nofollow noreferrer">Stack Overflow</a> 已经有大神给出了核心代码，这段代码是对 <code>UIImage</code> 的扩展，使用起来还不是很方便。于是我根据需求确定了接口：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 从圆形范围内的指定点获取UIColor对象，并在block中执行操作</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param point      指定坐标点</span></span><br><span class="line"><span class="comment"> @param completion 取色完成后执行的block</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)ax_getColorFromCircleWithPoint:(<span class="built_in">CGPoint</span>)point completion:(<span class="keyword">void</span> (^)(<span class="built_in">UIColor</span> *color))completion;</span><br></pre></td></tr></table></figure><p>调用起来应该是这样的：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 已知imageView、point</span></span><br><span class="line">[imageView ax_getColorFromCircleWithPoint:point completion:^(<span class="built_in">UIColor</span> *color)&#123;</span><br><span class="line">  <span class="comment">// 在这里直接用color</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>因为取色板一般是圆形的，如果坐标点超出了圆形但依然在imageView的frame内，可能会返回一些用户不期望的结果，用block巧妙地解决了这一问题，超出范围就不再有回调。如果你认为我的封装使用起来更加方便，可以继续阅读下面详细内容。</p><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><p>推荐CocoaPods方式，在podfile中添加一行：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pod <span class="string">&#x27;AXKit&#x27;</span></span><br></pre></td></tr></table></figure><p>然后在终端中执行 <code>pod install</code> 即可完成安装。</p><p>AXKit的全局头文件是：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过CocoaPods或静态库方式安装</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;AXKit/AXKit.h&gt;</span></span></span><br><span class="line"><span class="comment">// 通过手动方式</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;AXKit.h&quot;</span></span></span><br></pre></td></tr></table></figure><h2 id="接口声明"><a href="#接口声明" class="headerlink" title="接口声明"></a>接口声明</h2><h3 id="从指定点获取RGBA值"><a href="#从指定点获取RGBA值" class="headerlink" title="从指定点获取RGBA值"></a>从指定点获取RGBA值</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)ax_getRed:(<span class="keyword">nullable</span> <span class="built_in">CGFloat</span> *)red green:(<span class="keyword">nullable</span> <span class="built_in">CGFloat</span> *)green blue:(<span class="keyword">nullable</span> <span class="built_in">CGFloat</span> *)blue alpha:(<span class="keyword">nullable</span> <span class="built_in">CGFloat</span> *)alpha withPoint:(<span class="built_in">CGPoint</span>)point;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用起来是这样的：</span></span><br><span class="line"><span class="comment">// 已知imageView、point</span></span><br><span class="line"><span class="built_in">CGFloat</span> r,g,b,a;</span><br><span class="line">[imageView ax_getRed:&amp;r green:&amp;g blue:&amp;b alpha:&amp;a withPoint:point];</span><br><span class="line"><span class="comment">// 然后r/g/b/a就有了值</span></span><br></pre></td></tr></table></figure><p>需要自己创建变量，然后把地址传进去，然后才能用，不推荐直接使用。</p><h3 id="从指定点获取RGBA值，并在block中执行操作"><a href="#从指定点获取RGBA值，并在block中执行操作" class="headerlink" title="从指定点获取RGBA值，并在block中执行操作"></a>从指定点获取RGBA值，并在block中执行操作</h3><p>加了一个block，调用起来就方便许多：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)ax_getRGBAWithPoint:(<span class="built_in">CGPoint</span>)point completion:(<span class="keyword">void</span>(^)(<span class="built_in">CGFloat</span> red,<span class="built_in">CGFloat</span> green,<span class="built_in">CGFloat</span> blue,<span class="built_in">CGFloat</span> alpha))completion;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用起来是这样的：</span></span><br><span class="line"><span class="comment">// 已知imageView、point</span></span><br><span class="line">[imageView ax_getRGBAWithPoint:point completion:^(<span class="built_in">CGFloat</span> red,<span class="built_in">CGFloat</span> green,<span class="built_in">CGFloat</span> blue,<span class="built_in">CGFloat</span> alpha)&#123;</span><br><span class="line">  <span class="comment">// 在这里直接用red/green/blue/alpha</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>优点是不需要自己创建变量，直接调用方法，在block回调里直接获得red/green/blue/alpha值。</p><blockquote><p>但是，很多时候，我们用的取色器是圆形的，就需要再进行一点封装。</p></blockquote><h3 id="从圆形范围内的指定点获取RGBA值，并在block中执行操作"><a href="#从圆形范围内的指定点获取RGBA值，并在block中执行操作" class="headerlink" title="从圆形范围内的指定点获取RGBA值，并在block中执行操作"></a>从圆形范围内的指定点获取RGBA值，并在block中执行操作</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)ax_getRGBAFromCircleWithPoint:(<span class="built_in">CGPoint</span>)point completion:(<span class="keyword">void</span> (^)(<span class="built_in">CGFloat</span> red,<span class="built_in">CGFloat</span> green,<span class="built_in">CGFloat</span> blue,<span class="built_in">CGFloat</span> alpha))completion;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用起来是这样的：</span></span><br><span class="line"><span class="comment">// 已知imageView、point</span></span><br><span class="line">[imageView ax_getRGBAFromCircleWithPoint:point completion:^(<span class="built_in">CGFloat</span> red,<span class="built_in">CGFloat</span> green,<span class="built_in">CGFloat</span> blue,<span class="built_in">CGFloat</span> alpha)&#123;</span><br><span class="line">  <span class="comment">// 在这里直接用red/green/blue/alpha</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>跟第2种调用方法一模一样，但是区别是超出圆形范围之后就不再执行block回调了，这是一种<strong>安全</strong>的做法。如果不用block方式，那么即使超出了圆形范围，也一定会返回对应的rgba值，会造成不想要的后果。</p><blockquote><p>block的回调机制巧妙地解决了这个问题。</p></blockquote><p>如果我想直接获得一个UIColor对象呢，跟获取RGBA一样有三种方法。</p><h3 id="从指定点获取UIColor对象"><a href="#从指定点获取UIColor对象" class="headerlink" title="从指定点获取UIColor对象"></a>从指定点获取UIColor对象</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIColor</span> *)ax_getColorWithPoint:(<span class="built_in">CGPoint</span>)point;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用起来是这样的：</span></span><br><span class="line"><span class="comment">// 已知imageView、point</span></span><br><span class="line"><span class="built_in">UIColor</span> *color = [imageView ax_getColorWithPoint:point];</span><br><span class="line"><span class="comment">// 获得UIColor对象</span></span><br></pre></td></tr></table></figure><p>由声明可以看出来，返回的值是一个可空类型，因此这跟第一种方法一样是<strong>不安全</strong>的。</p><h3 id="从指定点获取UIColor对象，并在block中执行操作"><a href="#从指定点获取UIColor对象，并在block中执行操作" class="headerlink" title="从指定点获取UIColor对象，并在block中执行操作"></a>从指定点获取UIColor对象，并在block中执行操作</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)ax_getColorWithPoint:(<span class="built_in">CGPoint</span>)point completion:(<span class="keyword">void</span>(^)(<span class="built_in">UIColor</span> *color))completion;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用起来是这样的：</span></span><br><span class="line"><span class="comment">// 已知imageView、point</span></span><br><span class="line">[imageView ax_getColorWithPoint:point completion:^(<span class="built_in">UIColor</span> *color)&#123;</span><br><span class="line">  <span class="comment">// 在这里直接用color</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>这种方法比第4种要方便一些，如果超出UIImageView的时候就不执行block里的代码。</p><h3 id="从圆形范围内的指定点获取UIColor对象，并在block中执行操作"><a href="#从圆形范围内的指定点获取UIColor对象，并在block中执行操作" class="headerlink" title="从圆形范围内的指定点获取UIColor对象，并在block中执行操作"></a>从圆形范围内的指定点获取UIColor对象，并在block中执行操作</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)ax_getColorFromCircleWithPoint:(<span class="built_in">CGPoint</span>)point completion:(<span class="keyword">void</span> (^)(<span class="built_in">UIColor</span> *color))completion;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用起来是这样的：</span></span><br><span class="line"><span class="comment">// 已知imageView、point</span></span><br><span class="line">[imageView ax_getColorFromCircleWithPoint:point completion:^(<span class="built_in">UIColor</span> *color)&#123;</span><br><span class="line">  <span class="comment">// 在这里直接用color</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>引言中的Demo用的就是这一种方法，在圆形取色器中取色，既方便又安全。</p><blockquote><p>相关资料：<br><a href="https://stackoverflow.com/questions/3773245/simple-way-to-read-pixel-color-values-from-an-png-image-on-the-iphone" target="_blank" rel="noopener external nofollow noreferrer">Simple way to read pixel color values from an PNG image on the iPhone?</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开发中有时候会遇到这样的需求，要给用户一个取色板，让用户从中自由地选取颜色，用来改变主题或者控制灯具的颜色等。这时候我们就需要获取一个视图的指定坐标的颜色值。&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发" scheme="https://xaoxuu.com/blog/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="https://xaoxuu.com/blog/tags/ios/"/>
    
      <category term="开源库" scheme="https://xaoxuu.com/blog/tags/%E5%BC%80%E6%BA%90%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>iOS 链式封装，更优雅地存取沙盒文件</title>
    <link href="https://xaoxuu.com/blog/2016-09-12-sandbox/"/>
    <id>https://xaoxuu.com/blog/2016-09-12-sandbox/</id>
    <published>2016-09-11T16:00:00.000Z</published>
    <updated>2016-10-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>假如你需要把一个字典或者别的什么东西保存到沙盒里，你准备怎么做？也许你已经条件反射的想到了操作步骤……其实，你可以不必每次都那么老老实实的把每一步写出来，一行代码就可以了：【路径+保存文件】两个关键点，组成一条链式语法。</p><a id="more"></a><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="string">@&quot;文件名&quot;</span>.cachePath.save(要保存的内容);</span><br></pre></td></tr></table></figure><h2 id="接入AXKit"><a href="#接入AXKit" class="headerlink" title="接入AXKit"></a>接入AXKit</h2><p>如果你的项目里还没有AXKit，可以在pod文件里添加一条 <code>pod &#39;AXKit&#39;</code> 进行接入，也可移步至 <a href="https://xaoxuu.com/wiki/axkit">AXKit在线文档</a> 查看详细的安装和使用方法。</p><h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><p>我封装了几个常用的沙盒路径，如下：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)mainBundlePath; <span class="comment">// mainBundlePath就是主工程项目里的文件路径</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)docPath; <span class="comment">// 文档，iTunes会备份，适合保存重要的数据</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)cachePath; <span class="comment">// 缓存，iTunes不会备份，适合保存不太重要的较大的数据</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)tempPath; <span class="comment">// 临时文件，iTunes不会备份，系统空闲时会自动删除，设备重启时也会删除</span></span><br></pre></td></tr></table></figure><p>除此之外，还提供了所有的路径，通过枚举的方式获取：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *(^)(<span class="built_in">NSSearchPathDirectory</span>))path; <span class="comment">// 传入NSSearchPathDirectory枚举就可得到路径</span></span><br></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>在沙盒的文档路径里有个叫 <code>abc.plist</code> 的文件，它的描述就是：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="string">@&quot;abc.plist&quot;</span>.docPath;</span><br></pre></td></tr></table></figure><h3 id="路径的拼接"><a href="#路径的拼接" class="headerlink" title="路径的拼接"></a>路径的拼接</h3><p>任何一个字符串都可以使用 <code>.append()</code> 进行拼接。</p><h2 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h2><p>保存的方法目前提供有四个：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>(^)(<span class="keyword">id</span>))savePlist;</span><br><span class="line">- (<span class="built_in">BOOL</span>(^)(<span class="built_in">NSObject</span>&lt;<span class="built_in">NSCoding</span>&gt; *))saveArchivedPlist;</span><br><span class="line">- (<span class="built_in">BOOL</span>(^)(<span class="built_in">NSObject</span>&lt;<span class="built_in">NSCoding</span>&gt; *))saveArchivedObject;</span><br><span class="line">- (<span class="built_in">BOOL</span>(^)(<span class="keyword">id</span> &lt;<span class="built_in">NSCoding</span>&gt;))save;</span><br></pre></td></tr></table></figure><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><ol><li><p>在doc路径下保存一个名为&quot;arr.plist&quot;的文件：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *arr = [<span class="built_in">NSArray</span> array];</span><br><span class="line"><span class="built_in">BOOL</span> result = <span class="string">@&quot;arr&quot;</span>.docPath.savePlist(arr);</span><br></pre></td></tr></table></figure></li><li><p>在cache路径下归档一个名为&quot;myfile.plist&quot;的文件：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">MyProfiles *myfile = [[MyProfiles alloc] init];</span><br><span class="line"><span class="comment">// MyProfiles类需实现NSCoding协议</span></span><br><span class="line"><span class="built_in">BOOL</span> result = <span class="string">@&quot;myfile&quot;</span>.cachePath.saveArchivedPlist(myfile);</span><br></pre></td></tr></table></figure><p>​</p></li></ol><h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h2><p>读取的方法目前提供了七个：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> __kindof <span class="built_in">NSArray</span> *)readArray;</span><br><span class="line">- (<span class="keyword">nullable</span> __kindof <span class="built_in">NSDictionary</span> *)readDictionary;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)readArchivedPlist;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)readJson;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)readTxt;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)readArchivedFile;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)readArchivedObject;</span><br></pre></td></tr></table></figure><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><ol><li><p>在doc路径下读取一个名为&quot;arr.plist&quot;的文件：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *arr = <span class="string">@&quot;arr&quot;</span>.docPath.readArray;</span><br></pre></td></tr></table></figure></li><li><p>在cache路径下解档一个名为&quot;myfile.plist&quot;的文件：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">MyProfiles *myfile = <span class="string">@&quot;myfile&quot;</span>.cachePath.readArchivedPlist;</span><br></pre></td></tr></table></figure><p>​</p></li></ol><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>遍历路径下所有文件</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取doc/myDir 路径下所有的扩展名为&quot;plist&quot;文件路径</span></span><br><span class="line"><span class="built_in">NSArray</span> *paths = <span class="string">@&quot;myDir&quot;</span>.docPath.subpaths(<span class="string">@&quot;plist&quot;</span>);</span><br><span class="line"><span class="comment">// 如果传入值为空，则不区分扩展名获取所有文件路径</span></span><br><span class="line"><span class="built_in">NSArray</span> *paths2 = <span class="string">@&quot;myDir&quot;</span>.docPath.subpaths(<span class="string">@&quot;&quot;</span>);</span><br><span class="line"><span class="comment">// paths里面装的是doc/myDir路径下的所有文件完整路径</span></span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>结构：【路径+删除】</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)removePlist;</span><br><span class="line">- (<span class="built_in">BOOL</span>)removeJson;</span><br><span class="line">- (<span class="built_in">BOOL</span>)removeTxt;</span><br><span class="line">- (<span class="built_in">BOOL</span>)remove;</span><br></pre></td></tr></table></figure><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><ol><li><p>在doc路径下删除一个名为&quot;arr.plist&quot;的文件：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> result = <span class="string">@&quot;arr.plist&quot;</span>.docPath.remove;</span><br></pre></td></tr></table></figure></li><li><p>在cache路径下删除一个名为&quot;myfile.plist&quot;的文件：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">MyProfiles *myfile = <span class="string">@&quot;myfile.plist&quot;</span>.cachePath.remove;</span><br></pre></td></tr></table></figure></li></ol><h2 id="详细文档"><a href="#详细文档" class="headerlink" title="详细文档"></a>详细文档</h2><p>详细请看 <a href="https://xaoxuu.com/wiki/axkit/">文档</a> 。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;假如你需要把一个字典或者别的什么东西保存到沙盒里，你准备怎么做？也许你已经条件反射的想到了操作步骤……其实，你可以不必每次都那么老老实实的把每一步写出来，一行代码就可以了：【路径+保存文件】两个关键点，组成一条链式语法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发" scheme="https://xaoxuu.com/blog/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="https://xaoxuu.com/blog/tags/ios/"/>
    
      <category term="开源库" scheme="https://xaoxuu.com/blog/tags/%E5%BC%80%E6%BA%90%E5%BA%93/"/>
    
      <category term="沙盒" scheme="https://xaoxuu.com/blog/tags/%E6%B2%99%E7%9B%92/"/>
    
      <category term="缓存" scheme="https://xaoxuu.com/blog/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>如何发布开源库到 CocoaPods</title>
    <link href="https://xaoxuu.com/blog/2016-08-11-cocoapods/"/>
    <id>https://xaoxuu.com/blog/2016-08-11-cocoapods/</id>
    <published>2016-08-10T16:00:00.000Z</published>
    <updated>2018-10-04T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>说实在话，类似的教程网上很多，基本可以满足大多数人零基础发布 CocoaPods，但是其中可能会遇到一些问题，只有亲自尝试过才知道。</p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="1-clone-远程仓库到本地"><a href="#1-clone-远程仓库到本地" class="headerlink" title="1. clone 远程仓库到本地"></a>1. clone 远程仓库到本地</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> 你的仓库链接</span><br></pre></td></tr></table></figure><h3 id="2-注册-trunk"><a href="#2-注册-trunk" class="headerlink" title="2. 注册 trunk"></a>2. 注册 trunk</h3><p>注册的命令</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pod trunk register 你的邮箱 你的用户名</span><br></pre></td></tr></table></figure><p>记得去邮箱里验证，然后可以输入以下命令查看个人信息</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pod trunk me</span><br></pre></td></tr></table></figure><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="1-创建-podspec"><a href="#1-创建-podspec" class="headerlink" title="1. 创建 .podspec"></a>1. 创建 <code>.podspec</code></h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pod spec create AXKit</span><br></pre></td></tr></table></figure><h3 id="2-修改-podspec-并验证"><a href="#2-修改-podspec-并验证" class="headerlink" title="2. 修改 .podspec 并验证"></a>2. 修改 <code>.podspec</code> 并验证</h3><p>有很多类似的教程，可以参考。</p><blockquote><p>一个小技巧：你可以去GItHub搜索一些热门的第三方库，然后点击查看这些大牛的 <code>.podspec</code> 是怎么写的。<br>传送门：<a href="https://github.com/ibireme/YYKit/blob/master/YYKit.podspec" target="_blank" rel="noopener external nofollow noreferrer">YYKit的podspec</a>、<a href="https://github.com/ReactiveCocoa/ReactiveObjC/blob/master/ReactiveObjC.podspec" target="_blank" rel="noopener external nofollow noreferrer">ReactiveObjC的podspec</a>、<a href="https://github.com/BlocksKit/BlocksKit/blob/master/BlocksKit.podspec" target="_blank" rel="noopener external nofollow noreferrer">BlocksKit的podspec</a></p></blockquote><p>最容易出错的地方就是资源路径</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">s.source_files = <span class="string">&quot;AXKit/**/*.&#123;h,m&#125;&quot;</span></span><br></pre></td></tr></table></figure><p>常见写法</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;Directory1/*&quot;</span>  表示匹配所有文件</span><br><span class="line"><span class="string">&quot;Directory1/Directory2/*.&#123;h,m&#125;&quot;</span>  表示匹配所有以.h和.m结尾的文件</span><br><span class="line"><span class="string">&quot;Directory1/**/*.h&quot;</span>  表示匹配所有子目录</span><br></pre></td></tr></table></figure><p>s.source 常见写法</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 推荐写法：与版本号绑定</span></span><br><span class="line">s.source = &#123; <span class="symbol">:git</span> =&gt; <span class="string">&quot;https://github.com/TeaseTian/HTQRCode.git&quot;</span>, <span class="symbol">:tag</span> =&gt; <span class="string">&quot;<span class="subst">#&#123;s.version&#125;</span>&quot;</span> &#125;</span><br><span class="line"><span class="comment"># 与commit id 绑定</span></span><br><span class="line">s.source = &#123; <span class="symbol">:git</span> =&gt; <span class="string">&quot;https://github.com/TeaseTian/HTQRCode.git&quot;</span>, <span class="symbol">:commit</span> =&gt; <span class="string">&quot;68defea&quot;</span> &#125;</span><br></pre></td></tr></table></figure><p>tag =&gt; s.version 表示将这个 Pod 版本与 Git 仓库中相同版本的 comit 绑定</p><div class="note "><p><strong>注意</strong></p><p>如果仓库中对应的tag是 <code>“v1.0.0”</code> 这样以字母开头的，可以在 <code>#{s.version}</code> 前面加上对应的字母。commit =&gt; &quot;68defea&quot; 表示将这个 Pod 版本与 Git 仓库中某个 commit 绑定</p></div><p><strong>验证</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pod spec lint AXKit.podspec</span><br></pre></td></tr></table></figure><h3 id="3-上传到远程仓库"><a href="#3-上传到远程仓库" class="headerlink" title="3. 上传到远程仓库"></a>3. 上传到远程仓库</h3><p>修改 <code>.podspec</code> 时指定的版本号，如 <code>0.0.1</code>。那么远程仓库中必须始终存在这个版本的 <code>branch</code> 或 <code>tag</code> 才能够下载。建议使用 tag。<code>s.source</code> 中的 tag 需要与远程仓库中的 tag 对应起来。</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">s.version = <span class="string">&quot;0.0.1&quot;</span></span><br><span class="line">s.source  = &#123; <span class="symbol">:git</span> =&gt; <span class="string">&quot;https://github.com/xaoxuu/AXKit.git&quot;</span>, <span class="symbol">:tag</span> =&gt; <span class="string">&quot;v<span class="subst">#&#123;s.version&#125;</span>&quot;</span> &#125;</span><br></pre></td></tr></table></figure><p>这里指向的是 <code>&quot;v0.0.1&quot;</code> 这个分支，因为分支我们用完之后习惯把它删掉，所以这里也可以指向 tag，也就是说打一个 <code>&quot;v0.0.1&quot;</code> 的 tag 并推送到远程就可以了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag v0.0.1</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure><p>这样做的好处就是删掉当前分支不影响 CocoaPods 中指向的仓库源码。</p><h3 id="4-发布到-CocoaPods"><a href="#4-发布到-CocoaPods" class="headerlink" title="4. 发布到 CocoaPods"></a>4. 发布到 CocoaPods</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod trunk push AXKit.podspec</span><br></pre></td></tr></table></figure><h3 id="n-删除一个-podspec-版本"><a href="#n-删除一个-podspec-版本" class="headerlink" title="n. 删除一个 podspec 版本"></a>n. 删除一个 podspec 版本</h3><p>删除的命令是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod trunk delete 项目名 版本号</span><br></pre></td></tr></table></figure><p>官方建议使用 <code>deprecate</code> 来弃用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod trunk deprecate 项目名</span><br></pre></td></tr></table></figure><p>这两种方法执行完有很大几率会出现一串很长很长的错误，不要着急，这实际上这是一个 html。把它保存到一个 html 文件中，打开，是个404错误页，原因众所周知。</p><blockquote><p>删除之后立即搜索还是能搜到的，因为有一定的延迟，可能要半个小时才能更新。</p></blockquote><h3 id="pod-trunk-命令"><a href="#pod-trunk-命令" class="headerlink" title="pod trunk 命令"></a>pod trunk 命令</h3><p>在终端输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod trunk --help</span><br></pre></td></tr></table></figure><p>可以查看帮助</p><h2 id="使用脚本"><a href="#使用脚本" class="headerlink" title="使用脚本"></a>使用脚本</h2><p>没必要每次都重复每个步骤，如果你已经发布过一个，可以省去注册的步骤，直接把已经发不过的 podspec 复制一份，改一下仓库模块名，验证通过就可以发布了。</p><p>我写了一个便于发布更新的脚本，把脚本放在与 podspec 同级目录下，当你更新了项目之后，如果需要更新到 cocoapods，可以执行此脚本。流程是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入版本号 -&gt; commit、push tag -&gt; pod spec lint -&gt; 询问是否发布(y&#x2F;n) -&gt; 发布(y)</span><br></pre></td></tr></table></figure><div class="note link"><p>脚本的项目在这里：<a href="https://github.com/xaoxuu/podspec.sh" target="_blank" rel="noopener external nofollow noreferrer">https://github.com/xaoxuu/podspec.sh</a></p></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说实在话，类似的教程网上很多，基本可以满足大多数人零基础发布 CocoaPods，但是其中可能会遇到一些问题，只有亲自尝试过才知道。&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发" scheme="https://xaoxuu.com/blog/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="CocoaPods" scheme="https://xaoxuu.com/blog/tags/cocoapods/"/>
    
  </entry>
  
  <entry>
    <title>ReactiveCocoa 响应式编程初探</title>
    <link href="https://xaoxuu.com/blog/2016-07-20-reactive-cocoa/"/>
    <id>https://xaoxuu.com/blog/2016-07-20-reactive-cocoa/</id>
    <published>2016-07-19T16:00:00.000Z</published>
    <updated>2018-09-26T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>RAC 即 ReactiveCocoa，是 Github 开源的函数响应式编程框架。可以简化代码，使一个功能的代码集中到一起，提高了代码聚合性。</p><a id="more"></a><ol><li>创建信号（冷信号）</li><li>订阅信号（热信号）</li><li>发送信号</li></ol><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 创建信号，点进去可以看到：</span></span><br><span class="line"><span class="comment">// 它其实创建了一个RACDynamicSignal信号，并保存了didSubscribe这个Block</span></span><br><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt; _Nonnull subscriber) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;创建了信号&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 发送信号，点进去可以看到：</span></span><br><span class="line">    <span class="comment">// 执行之前所保存的nextBlock</span></span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;ZM&quot;</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;发送了信号&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">        <span class="comment">// 取消订阅时的回调</span></span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 订阅信号，点进去可以看到：</span></span><br><span class="line"><span class="comment">// 创建了一个RACSubscriber订阅者，并保存了一个nextBlock，</span></span><br><span class="line"><span class="comment">// 同时执行之前所保存的didSubscribe这个Block</span></span><br><span class="line">[signal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;订阅了信号&quot;</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line"></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><!-- *_ --><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>代替代理（更少代码）<code>rac_signalForSelector:</code></li><li>代替 KVO <code>rac_valuesAndChangesForKeyPath:</code></li><li>监听事件（用于 MVVM）<code>rac_signalForControllerEvents:</code></li><li>代替通知（自动 remove）<code>rac_addObserverForName:</code></li><li>监听文本框内容改变 <code>rac_textSignal:</code></li><li>处理当界面有多次请求时，需要都获取到数据时，才能展示界面 <code>rac_liftSelector:WithSignalFromArray:Signals:</code></li></ul><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="map-amp-flattenMap"><a href="#map-amp-flattenMap" class="headerlink" title="map &amp;  flattenMap"></a>map &amp;  flattenMap</h3><p>这是两个映射方法，将源信号内容映射成新的内容，就像 signal 管道上的中间处理器，从这里走过的 signal 都会经过一段处理后，变成新的 signal 继续传输。</p><figure class="highlight objc"><figcaption><span>map</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// map，将输出NSNumber的signal转换成输出NSString</span></span><br><span class="line">RACSignal *mapSignal = [[RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt; _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@(<span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;] map:^<span class="keyword">id</span> _Nullable(<span class="keyword">id</span>  _Nullable value) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@&quot;</span>, value];</span><br><span class="line">&#125;];</span><br><span class="line">[mapSignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">// NSString类型</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;x&quot;</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><figcaption><span>flattenMap</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// flattenMap，将输出NSNumber的signal转换成输出NSString</span></span><br><span class="line">RACSignal *mapSignal = [[RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@(<span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;] flattenMap:^__kindof RACSignal * _Nullable(<span class="keyword">id</span>  _Nullable value) &#123;</span><br><span class="line">    <span class="keyword">return</span> [RACReturnSignal <span class="keyword">return</span>:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@&quot;</span>, value]];</span><br><span class="line">&#125;];</span><br><span class="line">[mapSignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">// NSString类型</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;x&quot;</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>两者之间的区别就在于，map 中 Block 返回转换对象，flattenMap 返回转换对象的信号。一般信号发出的值不是信号，使用 map；如果是信号则使用 flattenMap，它可以处理信号中的信号。</p><h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><p>把多个信号合并成一个信号，只需订阅这一个信号就相当于订阅了多个信号，任何一个信号有新值的时候都会触发调用。</p><figure class="highlight objc"><figcaption><span>merge</span></figcaption><table><tr><td class="code"><pre><span class="line">RACSignal *signal1 = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@(<span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">RACSignal *signal2 = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@(<span class="number">2</span>)];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">RACSignal *signal3 = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@(<span class="number">3</span>)];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">RACSignal *mergeSignal = [RACSignal merge:@[signal1, signal2, signal3]];</span><br><span class="line">[mergeSignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">// 分别输出1,2,3</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><p>将多个信号有顺序的连接起来，按照顺序接收信号，但是一定要之前的信号完成了才能发送下一个信号。</p><figure class="highlight objc"><figcaption><span>concat</span></figcaption><table><tr><td class="code"><pre><span class="line">RACSignal *signal1 = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@(<span class="number">1</span>)];</span><br><span class="line">    <span class="comment">// 发送信号完成，表示不再订阅了，内部会自动调用[RACDisposable disposable]取消订阅信号。</span></span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">RACSignal *signal2 = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@(<span class="number">2</span>)];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">RACSignal *signal3 = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@(<span class="number">3</span>)];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">RACSignal *concatSignal = [RACSignal concat:@[signal2, signal1, signal3]];</span><br><span class="line">[concatSignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">// 分别输出2,1,3</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="then"><a href="#then" class="headerlink" title="then"></a>then</h3><p>用于连接两个信号，内部也是使用 concat，当前一个信号完成之后才会连接 then 返回的信号，但是会忽略前一个信号，只会触发下个信号。</p><figure class="highlight objc"><figcaption><span>then</span></figcaption><table><tr><td class="code"><pre><span class="line">RACSignal *signal1 = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@(<span class="number">1</span>)];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">RACSignal *thenSignal =  [signal1 then:^RACSignal * _Nonnull&#123;</span><br><span class="line">  <span class="keyword">return</span>  [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">       [subscriber sendNext:@(<span class="number">2</span>)];</span><br><span class="line">       [subscriber sendCompleted];</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">   &#125;];</span><br><span class="line">&#125;];</span><br><span class="line">[thenSignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">// 输出2</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><p>将对各信号压缩成一个信号，只有当几个信号同时 sendNext 的时候才会触发压缩流的 next 事件，其中每一个信号 send 的内容都是一一对应的。</p><figure class="highlight objc"><figcaption><span>zip</span></figcaption><table><tr><td class="code"><pre><span class="line">RACSignal *signal1 = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@(<span class="number">1</span>)];</span><br><span class="line">    <span class="comment">// 不会覆盖上一个信号</span></span><br><span class="line">    [subscriber sendNext:@(<span class="number">3</span>)];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">RACSignal *signal2 = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@(<span class="number">2</span>)];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;] ;</span><br><span class="line">RACSignal *zipSignal = [RACSignal zip:@[signal1, signal2]];</span><br><span class="line">[zipSignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">// 输出(1, 2)</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="combineLatest"><a href="#combineLatest" class="headerlink" title="combineLatest"></a>combineLatest</h3><p>将多个信号组合起来，当其中每一个信号都 sendNext 之后，才会触发组合的信号，其中每一个信号再次 sendNext 都会覆盖之前的信号内容，返回的是一个 RACTuple（元组，类似于NSArray）。</p><figure class="highlight objc"><figcaption><span>combineLatest</span></figcaption><table><tr><td class="code"><pre><span class="line">RACSignal *signal1 = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@(<span class="number">1</span>)];</span><br><span class="line">    <span class="comment">// 将覆盖之前的信号，这就是跟zip的区别</span></span><br><span class="line">    [subscriber sendNext:@(<span class="number">3</span>)];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">RACSignal *signal2 = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@(<span class="number">2</span>)];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">//如果其中一个信号不sendNext，则不会触发组合信号</span></span><br><span class="line">RACSignal *combineSignal = [RACSignal combineLatest:@[signal1, signal2]];</span><br><span class="line">[combineSignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">// 输出(3, 2)</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="rac-liftSelector-withSignalsFromArray"><a href="#rac-liftSelector-withSignalsFromArray" class="headerlink" title="rac_liftSelector: withSignalsFromArray:"></a>rac_liftSelector: withSignalsFromArray:</h3><p>当信号组中每一个信号都至少一次 sendNext 之后，将触发 Selector 方法，类似于 combineLatest。</p><figure class="highlight objc"><figcaption><span>rac_liftSelector: withSignalsFromArray:</span></figcaption><table><tr><td class="code"><pre><span class="line">RACSubject *subject1 = [RACSubject subject];</span><br><span class="line">RACSubject *subject2 = [RACSubject subject];</span><br><span class="line">[[<span class="keyword">self</span> rac_liftSelector:<span class="keyword">@selector</span>(updateWithParameter1:parameter2:) withSignals:subject1, subject2, <span class="literal">nil</span>] subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line">[subject1 sendNext:@<span class="number">1</span>];</span><br><span class="line">[subject2 sendNext:@<span class="number">2</span>];</span><br></pre></td></tr></table></figure><h3 id="reduceEach"><a href="#reduceEach" class="headerlink" title="reduceEach"></a>reduceEach</h3><p>一般用于元组，把元组的值聚合成一个值。</p><figure class="highlight objc"><figcaption><span>reduceEach</span></figcaption><table><tr><td class="code"><pre><span class="line">RACSignal *combineSignal = [RACSignal combineLatest:@[signal1, signal2]];</span><br><span class="line">RACSignal *reduceSignal = [combineSignal reduceEach:^<span class="keyword">id</span> (<span class="built_in">NSNumber</span> *num1, <span class="built_in">NSNumber</span> *num2)&#123;</span><br><span class="line">    <span class="keyword">return</span> @(num1.doubleValue+num2.doubleValue);</span><br><span class="line">&#125;];</span><br><span class="line">[reduceSignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">// 输出3</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// 等同于：`+ (RACSignal *)combineLatest:(id&lt;NSFastEnumeration&gt;)signals reduce:(id (^)())reduceBlock`</span></span><br><span class="line"><span class="comment">// RACSignal *combineSignal = [RACSignal combineLatest:@[signal1,signal2] reduce:^id (NSNumber *num1, NSNumber *num2)&#123;</span></span><br><span class="line"><span class="comment">//     return @(num1.doubleValue+num2.doubleValue);</span></span><br><span class="line"><span class="comment">// &#125;];</span></span><br></pre></td></tr></table></figure><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>过滤信号，添加筛选条件，只有符合的才会触发调用。</p><figure class="highlight objc"><figcaption><span>filter</span></figcaption><table><tr><td class="code"><pre><span class="line">RACSignal *signal1 = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@(<span class="number">1</span>)];</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;3&quot;</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">RACSignal *filterSignal = [signal1 filter:^<span class="built_in">BOOL</span>(<span class="keyword">id</span>  _Nullable value) &#123;</span><br><span class="line">    <span class="keyword">return</span> [value isKindOfClass:[<span class="built_in">NSNumber</span> <span class="keyword">class</span>]];</span><br><span class="line">&#125;];</span><br><span class="line">[filterSignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">// 输出1</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组的筛选</span></span><br><span class="line">RACSequence *sequence = [@[@(<span class="number">1</span>),@(<span class="number">2</span>),<span class="string">@&quot;3&quot;</span>].rac_sequence filter:^<span class="built_in">BOOL</span>(<span class="keyword">id</span>  _Nullable value) &#123;</span><br><span class="line">    <span class="keyword">return</span> [value isKindOfClass:[<span class="built_in">NSNumber</span> <span class="keyword">class</span>]];</span><br><span class="line">&#125;];</span><br><span class="line">[sequence.signal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">// 输出1, 2</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="distinctUntilChanged"><a href="#distinctUntilChanged" class="headerlink" title="distinctUntilChanged"></a>distinctUntilChanged</h3><p>当前值跟上一次的值不同的时候，就会触发调用，否则被忽略。</p><figure class="highlight objc"><figcaption><span>distinctUntilChanged</span></figcaption><table><tr><td class="code"><pre><span class="line">[textField.rac_textSignal.distinctUntilChanged subscribeNext:^(<span class="built_in">NSString</span> * _Nullable x) &#123;</span><br><span class="line">    <span class="comment">// 变化时输出变化之后的值</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="take"><a href="#take" class="headerlink" title="take"></a>take</h3><p>从第一个信号开始设置信号发送的有效的个数。</p><figure class="highlight objc"><figcaption><span>take</span></figcaption><table><tr><td class="code"><pre><span class="line">RACSignal *signal = [[RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@(<span class="number">1</span>)];</span><br><span class="line">    [subscriber sendNext:@(<span class="number">2</span>)];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;] take:<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">[signal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">// 输出1，因为take为1，所以有效的只有最开始的那一个，其他的忽略掉了</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="takeLast"><a href="#takeLast" class="headerlink" title="takeLast"></a>takeLast</h3><p>从最后一个开始设置信号发送的有效个数，必须 sendCompleted，不然不知道总共多少个信号。</p><figure class="highlight objc"><figcaption><span>takeLast</span></figcaption><table><tr><td class="code"><pre><span class="line">[[[RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@(<span class="number">1</span>)];</span><br><span class="line">    [subscriber sendNext:@(<span class="number">2</span>)];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;] takeLast:<span class="number">1</span>] subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">// 输出2</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="takeUntil"><a href="#takeUntil" class="headerlink" title="takeUntil"></a>takeUntil</h3><p><code>[signal1 takeUntil:signal2]</code>，当 signal2 已经 sendNext 或者 sendCompleted，signal1 就会失效。</p><figure class="highlight objc"><figcaption><span>takeUntil</span></figcaption><table><tr><td class="code"><pre><span class="line">RACSignal *signal1 = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@(<span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">RACSignal *signal2 = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@(<span class="number">2</span>)];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">[[signal1 takeUntil:signal2] subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">// 什么都不会输出，因为signal2已经sendNext，所以signal1就会失效</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h3><p>跳跃，从第一个发出的信号开始跳。</p><figure class="highlight objc"><figcaption><span>skip</span></figcaption><table><tr><td class="code"><pre><span class="line">[[[RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@(<span class="number">1</span>)];</span><br><span class="line">    [subscriber sendNext:@(<span class="number">2</span>)];</span><br><span class="line">    [subscriber sendNext:@(<span class="number">3</span>)];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;] skip:<span class="number">2</span>] subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">// 输出3</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="doNext"><a href="#doNext" class="headerlink" title="doNext"></a>doNext</h3><p>在执行 sendNext 之前会执行这个。</p><figure class="highlight objc"><figcaption><span>doNext</span></figcaption><table><tr><td class="code"><pre><span class="line">[[[RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@(<span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;] doNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    x = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@haha&quot;</span>,x];</span><br><span class="line">    <span class="comment">// 输出1haha，在订阅回调之前执行</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">&#125;] subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">// 输出1</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h3><p>在超过设定时间范围之后让信号报错，且不能发送内容。</p><figure class="highlight objc"><figcaption><span>timeout</span></figcaption><table><tr><td class="code"><pre><span class="line">RACSubject *subject = [RACSubject subject];</span><br><span class="line">[[subject timeout:<span class="number">3</span> onScheduler:[RACScheduler mainThreadScheduler]] subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">// 只输出1</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">    <span class="comment">// 3秒之后输出错误日志</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, error);</span><br><span class="line">&#125;];</span><br><span class="line">[subject sendNext:@<span class="number">1</span>];</span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">4</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    [subject sendNext:@<span class="number">2</span>];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="interval"><a href="#interval" class="headerlink" title="interval"></a>interval</h3><p>定时，每隔一定时间发出时间信号。</p><figure class="highlight objc"><figcaption><span>interval</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// RACScheduler:队列</span></span><br><span class="line">[[RACSignal interval:<span class="number">1</span> onScheduler:[RACScheduler currentScheduler]] subscribeNext:^(<span class="built_in">NSDate</span> * _Nullable x) &#123;</span><br><span class="line">        <span class="comment">// 每隔一秒输出当前时间</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="delay"><a href="#delay" class="headerlink" title="delay"></a>delay</h3><p>延时发送信号。</p><figure class="highlight objc"><figcaption><span>delay</span></figcaption><table><tr><td class="code"><pre><span class="line">[[[RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@(<span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;] delay:<span class="number">3</span>] subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">// 3秒之后输出1</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="retry"><a href="#retry" class="headerlink" title="retry"></a>retry</h3><p>重试，只要失败，就会重新执行创建信号中的 block，直到成功。</p><figure class="highlight objc"><figcaption><span>retry</span></figcaption><table><tr><td class="code"><pre><span class="line">__block <span class="built_in">NSInteger</span> i = <span class="number">0</span>;</span><br><span class="line">[[[RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">10</span>) &#123;</span><br><span class="line">        [subscriber sendNext:@(<span class="number">1</span>)];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        [subscriber sendError:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;] retry] subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">// 重试10次之后输出1</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, error);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="throttle"><a href="#throttle" class="headerlink" title="throttle"></a>throttle</h3><p>节流，当某个信号发送比较频繁的时候，可以限制在一定之间内不接受信号，等过了这个时间再取最后发送的信号内容发出，类似于 <code>bufferWithTime:onScheduler:</code>。</p><figure class="highlight objc"><figcaption><span>throttle</span></figcaption><table><tr><td class="code"><pre><span class="line">RACSubject *subject = [RACSubject subject];</span><br><span class="line"><span class="comment">// [subject bufferWithTime:1 onScheduler:[RACScheduler currentScheduler]];</span></span><br><span class="line">[[subject throttle:<span class="number">1</span>] subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">// 输出3，拿到最后发出的内容3</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line">[subject sendNext:@<span class="number">1</span>];</span><br><span class="line">[subject sendNext:@<span class="number">2</span>];</span><br><span class="line">[subject sendNext:@<span class="number">3</span>];</span><br></pre></td></tr></table></figure><h3 id="deliverOn"><a href="#deliverOn" class="headerlink" title="deliverOn"></a>deliverOn</h3><p>内容传递切换到指定线程中，副作用在原来线程中，把在创建信号时 block 中的代码称之为副作用。</p><h3 id="subscribeOn"><a href="#subscribeOn" class="headerlink" title="subscribeOn"></a>subscribeOn</h3><p>内容传递和副作用都会切换到指定线程中。</p><h2 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h2><h3 id="RACSubject"><a href="#RACSubject" class="headerlink" title="RACSubject"></a>RACSubject</h3><p>信号提供者，本身可以充当信号，又能发送信号，继承自 RACSignal，但是底层实现跟 RACSignal 有些不一样，当订阅信号的时候会创建订阅者并保存订阅响应 Block，而发送信号的时候会遍历订阅者，然后分别调用 nextBlock。它提供的 API 很少，但是经常使用，因为它继承自 RACSignal。这里顺便来看一下方法 flatten 跟 switchToLatest，这两个都只能用来处理信号中的信号。</p><h4 id="flatten"><a href="#flatten" class="headerlink" title="flatten"></a>flatten</h4><p>压平信号中的信号，信号中的信号我们称之为子信号，flatten 可以拿到所有子信号发送的值。</p><figure class="highlight objc"><figcaption><span>flatten</span></figcaption><table><tr><td class="code"><pre><span class="line">RACSubject *subject = [RACSubject subject];</span><br><span class="line">RACSubject *subSubject1 = [RACSubject subject];</span><br><span class="line">RACSubject *subSubject2 = [RACSubject subject];</span><br><span class="line">[subject subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">// 分别输出subSubject1，subSubject2，但是不能拿到其中的值</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line">[subject.flatten subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">// 分别输出1, 2，flatten可以拿到所有子信号发送的值</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line">[subject sendNext:subSubject1];</span><br><span class="line">[subject sendNext:subSubject2];</span><br><span class="line">[subSubject1 sendNext:@<span class="number">1</span>];</span><br><span class="line">[subSubject2 sendNext:@<span class="number">2</span>];</span><br></pre></td></tr></table></figure><h4 id="switchToLatest"><a href="#switchToLatest" class="headerlink" title="switchToLatest"></a>switchToLatest</h4><p>与 flatten 相同，压平信号中的信号，不同的是，在存在多个子信号时候只会拿到最新的子信号，然后输出最新的子信号的值。</p><figure class="highlight objc"><figcaption><span>switchToLatest</span></figcaption><table><tr><td class="code"><pre><span class="line">RACSubject *subject = [RACSubject subject];</span><br><span class="line">RACSubject *subSubject1 = [RACSubject subject];</span><br><span class="line">RACSubject *subSubject2 = [RACSubject subject];</span><br><span class="line">[subject subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">// 分别输出subSubject1，subSubject2，但是不能拿到其中的值</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line">[subject.switchToLatest subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">// 输出2，switchToLatest只会拿到最新的子信号发送的值</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line">[subject sendNext:subSubject1];</span><br><span class="line">[subject sendNext:subSubject2];</span><br><span class="line">[subSubject1 sendNext:@<span class="number">1</span>];</span><br><span class="line">[subSubject2 sendNext:@<span class="number">2</span>];</span><br></pre></td></tr></table></figure><h3 id="RACReplaySubject"><a href="#RACReplaySubject" class="headerlink" title="RACReplaySubject"></a>RACReplaySubject</h3><p>重复提供信号类，继承自 RACSubject，它可以先发送信号，再订阅信号，原理就是将发送的信号内容保存了起来，当订阅信号的时候再将之前保存的信号，由订阅者一个一个的发送出来，而保存信号的容量由 capacity 来控制。</p><figure class="highlight objc"><figcaption><span>RACReplaySubject</span></figcaption><table><tr><td class="code"><pre><span class="line">RACReplaySubject *replaySubject = [RACReplaySubject replaySubjectWithCapacity:<span class="number">5</span>];</span><br><span class="line">[replaySubject subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">// 输出1</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line">[replaySubject sendNext:@<span class="number">1</span>];</span><br><span class="line">[replaySubject subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">// 输出1</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="RACMulticastConnection"><a href="#RACMulticastConnection" class="headerlink" title="RACMulticastConnection"></a>RACMulticastConnection</h3><p>这是一个组播连接类，是对信号的一个封装处理，当一个信号被多次订阅时，则会多次执行 didSubscribe 这个 Block，造成副作用，而这个类就能避免多次执行 didSubscribe，是一对多的单向数据流，一般用来处理信号被多次订阅的情况。</p><figure class="highlight objc"><figcaption><span>RACMulticastConnection</span></figcaption><table><tr><td class="code"><pre><span class="line">__block <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 创建信号</span></span><br><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@(i)];</span><br><span class="line">    i ++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">//创建RACMulticastConnection对象</span></span><br><span class="line">RACMulticastConnection *connect = [signal publish]</span><br><span class="line"> [connect.signal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">// 输出0</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line">[connect.signal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">// 输出0，当再次订阅时，不会再执行didSubscribe，所以并没有i++</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// 连接</span></span><br><span class="line">[connect connect];</span><br></pre></td></tr></table></figure><p>方法解析及实现原理：</p><ul><li>publish，multicast：这是对RACMulticastConnection初始化方法的一个封装，publish其实就是调用了multicast，并把创建好的RACSubject对象传给它，而multicast也就是调用了RACMulticastConnection的初始化方法，将原始信号传给source，把RACSubject对象传给subject。</li><li>当我们订阅connect.signal，其实就是订阅subject，然后将subject的订阅者保存起来，而调用[connect connect]的时候，会订阅原始信号（source），而source的订阅者就是subject，这时候subject就会执行[subject sendNext]，之后就会遍历subject所有的订阅者，逐一发送信号，触发外部subscribeNext回调。</li></ul><h3 id="RACCommand"><a href="#RACCommand" class="headerlink" title="RACCommand"></a>RACCommand</h3><p>这是一个命令类，可以把事件如何处理，事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程，一般来说是在UI上的某些动作来触发这些事件，比如点击一个按钮，RACCommand的实例能够决定是否可以被执行，一般用于网络请求，监控请求过程。</p><ol><li>创建命令，初始化RACCommand对象</li><li>在signalBlock中创建RACSignal，用来做数据传递，如果不需要可以创建空信号[RACSignal empty]。</li><li>执行命令execute</li></ol><figure class="highlight objc"><figcaption><span>RACCommand</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 创建命令对象</span></span><br><span class="line">RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(<span class="keyword">id</span> input) &#123;</span><br><span class="line">    <span class="comment">// 输出1，由execute传入</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, input);</span><br><span class="line">    <span class="comment">// 2. 创建信号</span></span><br><span class="line">    <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@(<span class="number">2</span>)];</span><br><span class="line">        <span class="comment">// 注意：数据传递完，最好调用sendCompleted，这时命令才执行完毕。</span></span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取信号传输的数据</span></span><br><span class="line">[command.executionSignals.switchToLatest subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="comment">// 输出2</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// 这里用flatten跟switchToLatest也是一样的</span></span><br><span class="line">[[command.executionSignals flatten] subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">// 输出2</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听命令是否执行完毕,初始化时会调用一次，用skip直接跳过。</span></span><br><span class="line">[[command.executing skip:<span class="number">1</span>] subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="keyword">if</span> ([x boolValue] == <span class="literal">YES</span>) &#123;</span><br><span class="line">        <span class="comment">// 正在执行</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;正在执行&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 执行完成</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;执行完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 执行命令</span></span><br><span class="line">RACSignal *connectSignal = [command execute:@<span class="number">1</span>] ;</span><br><span class="line">[connectSignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">// 输出2，connectSignal是connect.signal</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="RACChannel"><a href="#RACChannel" class="headerlink" title="RACChannel"></a>RACChannel</h3><p>这是一个通道类，可以理解为一个双向的连接，连接的两端都配有RACChannelTerminal（通道终端，继承自RACSignal，且又实现了RACSubscriber协议，所以它可以充当信号，又能发送信号），分别是leadingTerminal，followingTerminal，只要其中任何一端输出信号，另一端都会有相同的信号输出。我们平时很少直接使用RACChannel，而是使用RACChannelTo。</p><figure class="highlight objc"><figcaption><span>RACChannel</span></figcaption><table><tr><td class="code"><pre><span class="line">RACChannelTerminal *followT = RACChannelTo(view, backgroundColor);</span><br><span class="line">[followT subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">// 每点击一次就输出一次随机颜色</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="built_in">UITapGestureRecognizer</span> *tap = [[<span class="built_in">UITapGestureRecognizer</span> alloc]init];</span><br><span class="line">[tap.rac_gestureSignal subscribeNext:^(__kindof <span class="built_in">UIGestureRecognizer</span> * _Nullable x) &#123;</span><br><span class="line">    <span class="comment">// 改变view.backgroundColor</span></span><br><span class="line">    [followT sendNext:RandomColor];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将_textField.backgroundColor跟view.backgroundColor绑定</span></span><br><span class="line">RACChannelTo(button, backgroundColor) = RACChannelTo(view, backgroundColor);</span><br></pre></td></tr></table></figure><h2 id="常用宏"><a href="#常用宏" class="headerlink" title="常用宏"></a>常用宏</h2><h3 id="RAC-TARGET"><a href="#RAC-TARGET" class="headerlink" title="RAC(TARGET, ...)"></a>RAC(TARGET, ...)</h3><p>给某个对象的某个属性进行绑定。</p><figure class="highlight objc"><figcaption><span>RAC(TARGET, ...)</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当textfield开始编辑时，关闭button响应</span></span><br><span class="line">RAC(_button, enabled) = [[<span class="keyword">self</span> rac_signalForSelector:<span class="keyword">@selector</span>(textFieldDidBeginEditing:) fromProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">UITextFieldDelegate</span>)] <span class="title">mapReplace</span>:@<span class="title">NO</span>];</span></span><br></pre></td></tr></table></figure><h3 id="RACObserve-TARGET-KEYPATH"><a href="#RACObserve-TARGET-KEYPATH" class="headerlink" title="RACObserve(TARGET, KEYPATH)"></a>RACObserve(TARGET, KEYPATH)</h3><p>KVO，监听某个对象的属性，返回的是信号。</p><figure class="highlight objc"><figcaption><span>RACObserve(TARGET, KEYPATH)</span></figcaption><table><tr><td class="code"><pre><span class="line">[RACObserve(<span class="keyword">self</span>.view, backgroundColor) subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="RACChannelTo"><a href="#RACChannelTo" class="headerlink" title="RACChannelTo"></a>RACChannelTo</h3><p>用于双向绑定的一个通道终端。</p><figure class="highlight objc"><figcaption><span>RACChannelTo</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将_textField.backgroundColor跟view.backgroundColor绑定</span></span><br><span class="line">RACChannelTo(button, backgroundColor) = RACChannelTo(view, backgroundColor);</span><br></pre></td></tr></table></figure><h3 id="RACTuplePack"><a href="#RACTuplePack" class="headerlink" title="RACTuplePack"></a>RACTuplePack</h3><p>将数据包装成 RACTuple（元组）。</p><figure class="highlight objc"><figcaption><span>RACTuplePack</span></figcaption><table><tr><td class="code"><pre><span class="line">RACTuple *tuple = RACTuplePack(@<span class="number">1</span>, @<span class="number">2</span>, <span class="string">@&quot;3&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="RACTupleUnpack"><a href="#RACTupleUnpack" class="headerlink" title="RACTupleUnpack(...)"></a>RACTupleUnpack(...)</h3><p>把元组解包成对应的数据</p><figure class="highlight objc"><figcaption><span>RACTupleUnpack(...)</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传入需要解析生成的变量名，从第一个开始解析</span></span><br><span class="line">RACTupleUnpack(<span class="built_in">NSNumber</span> *num1, <span class="built_in">NSNumber</span> *num2) = tuple;</span><br><span class="line"><span class="comment">// 输出 1, 2</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@, %@&quot;</span>, num1, num2);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RAC 即 ReactiveCocoa，是 Github 开源的函数响应式编程框架。可以简化代码，使一个功能的代码集中到一起，提高了代码聚合性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发" scheme="https://xaoxuu.com/blog/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="https://xaoxuu.com/blog/tags/ios/"/>
    
      <category term="ReactiveCocoa" scheme="https://xaoxuu.com/blog/tags/reactivecocoa/"/>
    
      <category term="响应式编程" scheme="https://xaoxuu.com/blog/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 iOS 蓝牙 BLE 开发</title>
    <link href="https://xaoxuu.com/blog/2016-06-22-ios-ble/"/>
    <id>https://xaoxuu.com/blog/2016-06-22-ios-ble/</id>
    <published>2016-06-21T16:00:00.000Z</published>
    <updated>2016-06-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>BLE，即 Bluetooth Low Energy 低功耗蓝牙。可穿戴产品、无线耳机、无线鼠标等低功耗外设都使用 BLE 技术。轩霆科技所使用的手环和手表产品就是通过 BLE 连接与手机同步数据。</p><blockquote><p>本文以官方文档作为主要教材进行学习，所有插图均来源于苹果官方文档，文末提供文档链接。</p></blockquote><a id="more"></a><h2 id="认识-CoreBluetooth-框架"><a href="#认识-CoreBluetooth-框架" class="headerlink" title="认识 CoreBluetooth 框架"></a>认识 CoreBluetooth 框架</h2><p>CoreBluetooth 框架的核心是 Central 和 Peripheral，即中心管理与外设。Central 和 Peripheral 的关系 Client 和 Server 的关系一样。</p><div class="gallery ">              <img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/2016/5d33b1fba460da907770ad280a980de172d15f.png'>            </div><h3 id="中心发现并连接到正在广播的外围设备"><a href="#中心发现并连接到正在广播的外围设备" class="headerlink" title="中心发现并连接到正在广播的外围设备"></a>中心发现并连接到正在广播的外围设备</h3><p>外围设备以广播包的形式广播他们拥有的一些数据。广播数据包是一个相对较小的数据包，可能包含有关外设必须提供的有用信息，例如外设的名称和主要功能。例如，数字恒温器可以广播它提供房间的当前温度。在低功耗蓝牙中，广播是外围设备了解其存在的主要方式。</p><p>另一方面，中央可以扫描和侦听任何正在广播其感兴趣的信息的外围设备，如图下图所示。中央可以要求连接到它发现的任何正在广播的外围设备。</p><div class="gallery ">              <img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/2016/69adccd10dd8d7eb20eca76d2981b64627d3d2.png'>            </div><h3 id="外围设备的数据构成"><a href="#外围设备的数据构成" class="headerlink" title="外围设备的数据构成"></a>外围设备的数据构成</h3><p>外围设备可能包含一项或多项服务，或提供有关其连接信号强度的有用信息。服务是用于完成设备（或该设备的一部分）的功能或特征的数据和相关行为的集合。例如，心率监测器的一项服务可以是从监测器的心率传感器暴露心率数据。</p><p>服务本身由特征或包含的服务（即对其他服务的引用）组成。特性提供了有关外围设备服务的更多详细信息。例如，刚刚描述的心率服务可以包含描述设备的心率传感器的预期身体位置的一个特征和发送心率测量数据的另一个特征。下图说明了心率监测器服务和特征的一种可能结构。</p><div class="gallery ">              <img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/2016/330aa166f0114ad4cb1230c53e55f8fc992f2b.png'>            </div><h3 id="中心与外围设备的数据交互"><a href="#中心与外围设备的数据交互" class="headerlink" title="中心与外围设备的数据交互"></a>中心与外围设备的数据交互</h3><p>在中心成功建立与外围设备的连接之后，它可以发现外围设备必须提供的全部服务和特性（广告数据可能只包含一小部分可用服务）。</p><p>中央还可以通过读取或写入该服务特征的值来与外围设备的服务进行交互。例如，应用可以从数字恒温器请求当前室温，或者它可以为恒温器提供设置房间温度的值。</p><h4 id="设备作为-Central-时"><a href="#设备作为-Central-时" class="headerlink" title="设备作为 Central 时"></a>设备作为 Central 时</h4><p>当 Central 和作为外设的 Peripheral 通信时，绝大部分操作都在 Central 这边。此时，Central 被描述为CBCentralManager，这个类提供了扫描、寻找、连接 Peripheral （被描述为 CBPeripheral）的方法。</p><p>下图标示了 Central 和 Peripheral 在 Core Bluetooth 中的表示方式：</p><div class="gallery ">              <img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/2016/123b1ca5193f178debe7380d902b84529b69fc.png'>            </div><p>当你操作 Peripheral 的时候，实际上是在和它的 Service 和 Characteristic 打交道，这两个分别由CBService和CBCharacteristic表示。</p><p>一个 Peripheral 包含多个 Service，而一个 Service 又可以包含多个 Characteristic，所以他们的关系大致可以表示为：</p><div class="gallery ">              <img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/2016/5cce104c928078cbd95a3fe684d312e78b54f8.png'>            </div><h4 id="设备作为-Peripheral-时"><a href="#设备作为-Peripheral-时" class="headerlink" title="设备作为 Peripheral 时"></a>设备作为 Peripheral 时</h4><p>在 OS X 10.9 和 iOS 6 以后，设备除了能作为 Central 外，还可以作为 Peripheral。也就是说，可以发起数据，而不像以前只能管理数据了。</p><p>那么在此时，它被描述为CBPeripheralManager，既然是作为 Peripheral，那么这个类提供的主要方法则是对 Service 的管理，同时还兼备着向 Central 广播数据的功能。Peripheral 同样会对 Central 的读写要求做出相应。</p><p>下图则是设备作为 Central 和 Peripheral 的示意图：</p><div class="gallery ">              <img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/2016/9168e6a648e02946f2a5789c6e05d8ec617f32.png'>            </div><p>在充当 Peripheral 时，CBPeripheralManager处理的是可变的 Service 和 Characteristic，分别由CBMutableService和CBMutableCharacteristic表示。</p><p>下图则是在设备 Peripheral 时，相关类的关系：</p><div class="gallery ">              <img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/2016/d975f14f6a95389149918e1f1a2e5cb25fee9e.png'>            </div><h2 id="作为-Central-时的数据读写"><a href="#作为-Central-时的数据读写" class="headerlink" title="作为 Central 时的数据读写"></a>作为 Central 时的数据读写</h2><p>在蓝牙低功耗通信中实现核心作用的设备执行许多常见任务 - 例如，发现和连接到可用外围设备，以及探索外围设备必须提供的数据并与之交互。实现外围设备角色的设备还执行许多常见但不同的任务 - 例如，发布和广告服务，以及响应来自连接中心的读取，写入和订阅请求。</p><ul><li>使用CBCentralManager</li><li>搜索并连接可用的 Peripheral</li><li>连接时候，进行数据接收</li><li>对 Characteristic 进行数据读写</li><li>当 Characteristic 状态更新时，进行回调</li></ul><h3 id="初始化-CBCentralManager"><a href="#初始化-CBCentralManager" class="headerlink" title="初始化 CBCentralManager"></a>初始化 CBCentralManager</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">myCentralManager = [[CBCentralManager alloc] initWithDelegate:<span class="keyword">self</span> queue:<span class="literal">nil</span> options:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><p>将self设置为代理，用于接收各种 central 事件。将queue设置为nil，则表示直接在主线程中执行。  </p><h3 id="发现-Peripheral"><a href="#发现-Peripheral" class="headerlink" title="发现 Peripheral"></a>发现 Peripheral</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[myCentralManager scanForPeripheralsWithServices:<span class="literal">nil</span> options:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><p>第一个参数为nil，表示所有周围全部可用的设备。在实际应用中，你可以传入一个CBUUID的数组（注意，这个 UUID 是 Service 的 UUID 数组，如有不明白可以参考 最佳实践），表示只搜索当前数组包含的设备（每个 Peripheral 的 Service 都有唯一标识——UUID）。所以，如果你传入了这样一个数组，那么 Central Manager 则只会去包含这些 Service UUID 的 Peripheral。</p><p>在调用 <code>scanForPeripheralsWithServices:options:</code> 方法之后，找到可用设备，系统会回调（每找到一个都会回调）<code>centralManager:didDiscoverPeripheral:advertisementData:RSSI:</code>。该方法会以 CBPeripheral 对象返回找到的 Peripheral，所以你可以使用数组将找到的 Peripheral 存起来。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)centralManager:(CBCentralManager *)central</span><br><span class="line"> didDiscoverPeripheral:(CBPeripheral *)peripheral</span><br><span class="line">     advertisementData:(<span class="built_in">NSDictionary</span> *)advertisementData</span><br><span class="line">                  RSSI:(<span class="built_in">NSNumber</span> *)RSSI &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Discovered %@&quot;</span>, peripheral.name);</span><br><span class="line">    <span class="keyword">self</span>.discoveredPeripheral = peripheral;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你找到你需要的那个 peripheral 时，可以调用stop方法来停止搜索。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[myCentralManager stopScan];</span><br></pre></td></tr></table></figure><h3 id="连接-Peripheral"><a href="#连接-Peripheral" class="headerlink" title="连接 Peripheral"></a>连接 Peripheral</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[myCentralManager connectPeripheral:peripheral options:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><p>当连接成功后，会回调方法centralManager:didConnectPeripheral:。在这个方法中，你可以去记录当前的连接状态等数据。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)centralManager:(CBCentralManager *)central</span><br><span class="line">  didConnectPeripheral:(CBPeripheral *)peripheral &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Peripheral connected&quot;</span>);</span><br><span class="line">    peripheral.delegate = <span class="keyword">self</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发现-Services"><a href="#发现-Services" class="headerlink" title="发现 Services"></a>发现 Services</h3><p>当与 peripheral 成功建立连接以后，就可以通信了。第一步是先找到当前 peripheral 提供的 service，因为 service 广播的数据有大小限制（貌似是 31 bytes），所以你实际找到的 service 的数量可能要比它广播时候说的数量要多。调用CBPeripheral的 discoverServices:方法可以找到当前 peripheral 的所有 service。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[peripheral discoverServices:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><p>在实际项目中，这个参数应该不是nil的，因为nil表示查找所有可用的Service，但实际上，你可能只需要其中的某几个。搜索全部的操作既耗时又耗电，所以应该提供一个要搜索的 service 的 UUID 数组。更加详细的内容会在最佳实践中讲到。</p><p>当找到特定的 Service 以后，会回调<CBPeripheralDelegate>的peripheral:didDiscoverServices:方法。Core Bluetooth 提供了CBService类来表示 service，找到以后，它们以数组的形式存入了当前 peripheral 的services属性中，你可以在当前回调中遍历这个属性。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)peripheral:(CBPeripheral *)peripheral</span><br><span class="line">didDiscoverServices:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (CBService *service <span class="keyword">in</span> peripheral.services) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Discovered service %@&quot;</span>, service);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发现-Characteristics"><a href="#发现-Characteristics" class="headerlink" title="发现 Characteristics"></a>发现 Characteristics</h3><p>找到需要的 service 之后，下一步是找它所提供的 characteristic。如果搜索全部 characteristic，那调用CBPeripheral的discoverCharacteristics:forService:方法即可。如果是搜索当前 service 的 characteristic，那还应该传入相应的CBService对象。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;Discovering characteristics for service %@&quot;</span>, interestingService);</span><br><span class="line">[peripheral discoverCharacteristics:<span class="literal">nil</span> forService:interestingService];</span><br></pre></td></tr></table></figure><p>同样是出于节能的考虑，第一个参数在实际项目中应该是 characteristic 的 UUID 数组。也同样能在最佳实践中介绍。</p><p>找到所有 Characteristic 之后，回调 <code>peripheral:didDiscoverCharacteristicsForService:error:</code> 方法，此时 Core Bluetooth 提供了 CBCharacteristic 类来表示 Characteristic。可以通过以下代码来遍历找到的 Characteristic：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)peripheral:(CBPeripheral *)peripheral</span><br><span class="line">didDiscoverCharacteristicsForService:(CBService *)service</span><br><span class="line">             error:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (CBCharacteristic *characteristic <span class="keyword">in</span> service.characteristics) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Discovered characteristic %@&quot;</span>, characteristic);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样也可以通过添加 UUID 的判断来找到需要的 Characteristic。</p><h3 id="检索-Characteristic-的值"><a href="#检索-Characteristic-的值" class="headerlink" title="检索 Characteristic 的值"></a>检索 Characteristic 的值</h3><p>特征包含表示外围设备服务信息的单个值。例如，健康温度计服务的温度测量特性可以具有指示摄氏温度的值。通过直接读取或订阅特征来检索特征的值。</p><h4 id="读取-Characteristic-的值"><a href="#读取-Characteristic-的值" class="headerlink" title="读取 Characteristic 的值"></a>读取 Characteristic 的值</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;Reading value for characteristic %@&quot;</span>, interestingCharacteristic);</span><br><span class="line">[peripheral readValueForCharacteristic:interestingCharacteristic];</span><br></pre></td></tr></table></figure><p>当你调用上面这方法后，会回调 <code>peripheral:didUpdateValueForCharacteristic:error:</code> 方法，其中包含了要读取的数据。如果读取正确，可以用以下方式来获得值：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)peripheral:(CBPeripheral *)peripheral</span><br><span class="line">didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic</span><br><span class="line">             error:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSData</span> *data = characteristic.value;</span><br><span class="line">    <span class="comment">// parse the data as needed</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="订阅-Characteristic-的值"><a href="#订阅-Characteristic-的值" class="headerlink" title="订阅 Characteristic 的值"></a>订阅 Characteristic 的值</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[peripheral setNotifyValue:<span class="literal">YES</span> forCharacteristic:interestingCharacteristic];</span><br></pre></td></tr></table></figure><p>当您订阅（或取消订阅）特征的值时，外设调用外设 <code>peripheral:didUpdateNotificationStateForCharacteristic:error:</code> 其委托对象的方法。如果订阅请求因任何原因失败，您可以实现此委托方法来访问错误原因，如以下示例所示：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)peripheral:(CBPeripheral *)peripheral</span><br><span class="line">didUpdateNotificationStateForCharacteristic:(CBCharacteristic *)characteristic</span><br><span class="line">             error:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Error changing notification state: %@&quot;</span>,</span><br><span class="line">           [error localizedDescription]);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="写入-Characteristic-的值"><a href="#写入-Characteristic-的值" class="headerlink" title="写入 Characteristic 的值"></a>写入 Characteristic 的值</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;Writing value for characteristic %@&quot;</span>, interestingCharacteristic);</span><br><span class="line">[peripheral writeValue:dataToWrite forCharacteristic:interestingCharacteristic type:CBCharacteristicWriteWithResponse];</span><br></pre></td></tr></table></figure><p>关于写入数据的 type，如上面这行代码，type 就是 CBCharacteristicWriteWithResponse，表示当写入成功时，要进行回调。更多的类型可以参考 CBCharacteristicWriteType 枚举。这个枚举会在下一章中介绍到。</p><p>如果写入成功后要回调，那么回调方法是 <code>peripheral:didWriteValueForCharacteristic:error:</code>。如果写入失败，那么会包含到 error 参数返回。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)peripheral:(CBPeripheral *)peripheral</span><br><span class="line">didWriteValueForCharacteristic:(CBCharacteristic *)characteristic</span><br><span class="line">             error:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Error writing characteristic value: %@&quot;</span>,</span><br><span class="line">            [error localizedDescription]);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Characteristic 也可能并不支持写操作，可以通过 CBCharacteristic 的 properties 属性来判断。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;BLE，即 Bluetooth Low Energy 低功耗蓝牙。可穿戴产品、无线耳机、无线鼠标等低功耗外设都使用 BLE 技术。轩霆科技所使用的手环和手表产品就是通过 BLE 连接与手机同步数据。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文以官方文档作为主要教材进行学习，所有插图均来源于苹果官方文档，文末提供文档链接。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="开发" scheme="https://xaoxuu.com/blog/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="https://xaoxuu.com/blog/tags/ios/"/>
    
      <category term="BLE" scheme="https://xaoxuu.com/blog/tags/ble/"/>
    
  </entry>
  
  <entry>
    <title>十万蝼蚁不如一个巨人</title>
    <link href="https://xaoxuu.com/blog/2016-05-22-its-better-to-be-a-titan/"/>
    <id>https://xaoxuu.com/blog/2016-05-22-its-better-to-be-a-titan/</id>
    <published>2016-05-21T16:00:00.000Z</published>
    <updated>2016-05-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><div class="note quote"><p>混乱不是深渊。<br>混乱是阶梯。<br>很多人想往上爬 却失败了<br>且永无机会再试。<br>他们坠落而亡。<br>有人本有机会攀爬，<br>但他们拒绝了。<br>他们守着王国不放<br>守着诸神<br>守着爱情<br>尽皆幻想。<br>唯有阶梯是真实存在。<br>攀爬才是生活的全部。<br>—— Game of Thrones</p></div><a id="more"></a><h2 id="物竞天择"><a href="#物竞天择" class="headerlink" title="物竞天择"></a>物竞天择</h2><p>世界是残酷的，强者以弱者为食。</p><h2 id="个体意识"><a href="#个体意识" class="headerlink" title="个体意识"></a>个体意识</h2><p>每个人都是一个独立的个体，群众的力量再强大，他们也不属于你，只是在某些时刻能够帮到你。<br>与其成为一个强大群体中微不足道的一员，不如成为一个强大的个体。</p><h2 id="群体意识"><a href="#群体意识" class="headerlink" title="群体意识"></a>群体意识</h2><p>社会不需要太多巨人，需要团结在一起才能发挥威力的蚂蚁。像牧羊一样，管好头羊，其他都会乖乖跟着头羊，即使有不听话的，也不会威胁到牧羊人。<br>但如果羊羔中有几个或更多比牧羊人掌管的头羊更加强壮的个体，牧羊人就会地位不保。这些羊羔如果足够聪明的话，是不应该过早展露实力的，冲动的结局则是变成一桌美食。</p><h2 id="珍惜当下"><a href="#珍惜当下" class="headerlink" title="珍惜当下"></a>珍惜当下</h2><p>活着本来就是如临深渊，如履薄冰，永远不能保证下一刻不会遭遇意外。<br>每天早上睁开眼能够看到熟悉的世界，能够记得自己走过的人生，都值得庆幸。<br>不做别人的棋子，更不教育自己的后代如何做好这一颗棋子，生活是你自己的。</p><h2 id="时间、效率、实力"><a href="#时间、效率、实力" class="headerlink" title="时间、效率、实力"></a>时间、效率、实力</h2><p>我一直把时间作为衡量价值的标准，因为只有时间是有限的、平等的。<br>效率则是将时间转化成实力的最关键一步，是靠自己的努力获得的，谁也赠予不了，谁也偷不了。<br>实力则是我的人生观中的价值所在，也是唯一的追求。</p><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>你可以选择随遇而安，只需要一双发现美的眼睛和积极乐观的心态。</p><p>也可以攀爬，你会发现到处都是陷阱，一步跌落，就是万丈深渊。<br>哪怕你认为现在的处境已经跌落人生谷底，但是事实是前方依然会有更深的陷阱在等着你。</p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note quote&quot;&gt;&lt;p&gt;混乱不是深渊。&lt;br&gt;混乱是阶梯。&lt;br&gt;很多人想往上爬 却失败了&lt;br&gt;且永无机会再试。&lt;br&gt;他们坠落而亡。&lt;br&gt;有人本有机会攀爬，&lt;br&gt;但他们拒绝了。&lt;br&gt;他们守着王国不放&lt;br&gt;守着诸神&lt;br&gt;守着爱情&lt;br&gt;尽皆幻想。&lt;br&gt;唯有阶梯是真实存在。&lt;br&gt;攀爬才是生活的全部。&lt;br&gt;—— Game of Thrones&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="https://xaoxuu.com/blog/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>macOS10.12 最新版 CocoaPods 的安装及使用</title>
    <link href="https://xaoxuu.com/blog/2016-03-21-cocoapods/"/>
    <id>https://xaoxuu.com/blog/2016-03-21-cocoapods/</id>
    <published>2016-03-20T16:00:00.000Z</published>
    <updated>2019-08-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>本文最新更新于2019年8月，macOS10.15中可用。</p><a id="more"></a><h2 id="1-移除现有Ruby默认源"><a href="#1-移除现有Ruby默认源" class="headerlink" title="1. 移除现有Ruby默认源"></a>1. 移除现有Ruby默认源</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gem sources --remove https://rubygems.org/</span><br></pre></td></tr></table></figure><h2 id="2-使用新的源"><a href="#2-使用新的源" class="headerlink" title="2. 使用新的源"></a>2. 使用新的源</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gem sources -a https://gems.ruby-china.com</span><br></pre></td></tr></table></figure><h2 id="3-验证新源是否替换成功"><a href="#3-验证新源是否替换成功" class="headerlink" title="3. 验证新源是否替换成功"></a>3. 验证新源是否替换成功</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gem sources -l</span><br></pre></td></tr></table></figure><h2 id="4-更新gem"><a href="#4-更新gem" class="headerlink" title="4. 更新gem"></a>4. 更新gem</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo gem update --system</span><br></pre></td></tr></table></figure><h2 id="5-安装CocoaPods"><a href="#5-安装CocoaPods" class="headerlink" title="5. 安装CocoaPods"></a>5. 安装CocoaPods</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo gem install -n /usr/<span class="built_in">local</span>/bin cocoapods</span><br><span class="line">pod setup</span><br></pre></td></tr></table></figure><h2 id="6-新建工程，并在终端用cd指令到文件夹内"><a href="#6-新建工程，并在终端用cd指令到文件夹内" class="headerlink" title="6. 新建工程，并在终端用cd指令到文件夹内"></a>6. 新建工程，并在终端用cd指令到文件夹内</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pod search 某第三方库</span><br></pre></td></tr></table></figure><h2 id="7-新建Podfile文件"><a href="#7-新建Podfile文件" class="headerlink" title="7. 新建Podfile文件"></a>7. 新建Podfile文件</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim Podfile</span><br></pre></td></tr></table></figure><p>写入以下内容并保存：（参考）</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="symbol">platform:</span>ios, <span class="string">&#x27;9.0&#x27;</span></span><br><span class="line"></span><br><span class="line">target <span class="string">&#x27;你的项目的target&#x27;</span> <span class="keyword">do</span></span><br><span class="line">  pod <span class="string">&#x27;MJRefresh&#x27;</span>, <span class="string">&#x27;~&gt; 3.1.0&#x27;</span></span><br><span class="line">  pod <span class="string">&#x27;YYKit&#x27;</span></span><br><span class="line">  pod <span class="string">&#x27;AXKit&#x27;</span></span><br><span class="line">  pod <span class="string">&#x27;SCLAlertView-Objective-C&#x27;</span>, <span class="string">&#x27;~&gt; 1.0.3&#x27;</span></span><br><span class="line">  <span class="comment">#pod &#x27;MJExtension&#x27;, &#x27;~&gt; 3.0.10&#x27;</span></span><br><span class="line">  <span class="comment">#pod &#x27;SDWebImage&#x27;, &#x27;~&gt; 3.7.6&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>小提示：（终端 <code>vim</code> 文件 按 <code>i</code> 可编辑 ，<code>esc</code> 退出编辑，<code>:wq</code> 可保存退出）</p><h2 id="8-安装第三方库到项目中"><a href="#8-安装第三方库到项目中" class="headerlink" title="8. 安装第三方库到项目中"></a>8. 安装第三方库到项目中</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pod install</span><br></pre></td></tr></table></figure><p>等待安装完成，打开 <code>你的项目.xcworkspace</code> 即可。</p><h2 id="n-更新本地的repo"><a href="#n-更新本地的repo" class="headerlink" title="n. 更新本地的repo"></a>n. 更新本地的repo</h2><p>如果第三方库更新了，而本地已有一个旧版本，可以执行 <code>pod update</code> 以更新。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文最新更新于2019年8月，macOS10.15中可用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发" scheme="https://xaoxuu.com/blog/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="CocoaPods" scheme="https://xaoxuu.com/blog/tags/cocoapods/"/>
    
  </entry>
  
  <entry>
    <title>关于未来的智能生活的畅想</title>
    <link href="https://xaoxuu.com/blog/2016-02-11-smart-life/"/>
    <id>https://xaoxuu.com/blog/2016-02-11-smart-life/</id>
    <published>2016-02-10T16:00:00.000Z</published>
    <updated>2016-02-10T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>我从小就对 “活着” 的机械十分着迷，就是我们现在所说的人工智能，当我初次了解到这个概念的时候，<del>就确定了我将奉献一生的事业</del>。</p><p>然而梦想很遥远，遥远到我这辈子无法见证 <a href="https://baike.baidu.com/item/%E6%88%91%EF%BC%8C%E6%9C%BA%E5%99%A8%E4%BA%BA/1189079" target="_blank" rel="noopener external nofollow noreferrer">《I, Robot》</a> 那样的时代。</p><a id="more"></a><h2 id="智能家居"><a href="#智能家居" class="headerlink" title="智能家居"></a>智能家居</h2><p>我相信，不久的未来会有越来越多的东西要接入互联网，接入互联网就可以用手机控制。<br>网络就像神经，门窗联了网，门窗就活了，扫把联了网，扫把就活了。等所有的家具家电都联网的时候，就需要一个平台来管理这些智能硬件了。</p><p>所有接入互联网的传感器都成为了这个智能系统的感官，神经将这些信息传递到可以分析、处理数据的终端，经过计算后作出应答，并由这些神经传递指令到相应的智能设备上。</p><p>人与人、人与物之间的联系就更加紧密了，随时的远程互动，远程协助都更加方便了。<br>当然，这中间涉及到的隐私和网络安全问题也十分重要，但问题总要解决，不能因噎废食。</p><p>传统硬件，将一步一步被替换为智能硬件，至少是能用手机 app 控制，用手机 app 来控制，就是一种雏形了。毕竟目前没有足够多的智能硬件，没有到需要开发一个系统的程度。</p><h2 id="平台化"><a href="#平台化" class="headerlink" title="平台化"></a>平台化</h2><p>现在智能硬件也越来越多了，网络也十分发达了，但是它们的 “语言” 不同，各厂商的产品都用自己的标准，不同厂商之间的硬件是无法协同工作的。它们需要一个协议、或者一个平台，来实现合作。平台，也许就是智能家居时代来临的一个必要条件吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我从小就对 “活着” 的机械十分着迷，就是我们现在所说的人工智能，当我初次了解到这个概念的时候，&lt;del&gt;就确定了我将奉献一生的事业&lt;/del&gt;。&lt;/p&gt;
&lt;p&gt;然而梦想很遥远，遥远到我这辈子无法见证 &lt;a href=&quot;https://baike.baidu.com/item/%E6%88%91%EF%BC%8C%E6%9C%BA%E5%99%A8%E4%BA%BA/1189079&quot; target=&quot;_blank&quot; rel=&quot;noopener external nofollow noreferrer&quot;&gt;《I, Robot》&lt;/a&gt; 那样的时代。&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="https://xaoxuu.com/blog/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>如何进行有效的团队合作</title>
    <link href="https://xaoxuu.com/blog/2013-02-06-my-team-concept/"/>
    <id>https://xaoxuu.com/blog/2013-02-06-my-team-concept/</id>
    <published>2013-02-05T16:00:00.000Z</published>
    <updated>2020-08-24T09:48:51.078Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>本文只是我在大学时期关于小组决策效率与分工方面的思考，可能不适用于其它场景。</p><p>在任何一个团队中，我始终都是先做一个观察者。因为在掌握足够的信息之前，我的看法可能是片面的，由此产生的观点及推论发表出来可能会误导人。</p><a id="more"></a><h2 id="偏执"><a href="#偏执" class="headerlink" title="偏执"></a>偏执</h2><p>我印象非常深刻的一次经历：初二的时候，物理老师提问一个思考问题，我的答案和班上其它同学的都不一样，我有点犹豫了，老师说了一句话：“有时候，真理往往掌握在少数人手中”，而正是那一次的正确的坚持，让我受益匪浅。这件事在我的成长过程中起到了非常重要的作用，所以现在我是一个对认定事情非常偏执的人。</p><p>要相信自己有理有据的判断，在追求真理的路上敢于以一敌众，后来的某些经历也表明，即使所有人都反对你，你也未必要因此放弃，因为真相总有浮出水面的时候。</p><h2 id="交流意见"><a href="#交流意见" class="headerlink" title="交流意见"></a>交流意见</h2><p>然而我却又是一个不爱争论的人，往往我发表完我的意见，也理解了对方的意见之后，就不会再继续谈论了。</p><p>为什么不说服别人呢？我会尝试去说服别人，但是当说服的难度远远大于它所带来的意义的时候，我就放弃了。我没有当过领导者，所以说服别人对我来说也不是个必选项，尤其是考虑到这个过程所花费的时间成本跟成果的价值孰轻孰重，我会越来越谨慎行事。</p><h2 id="独裁与民主"><a href="#独裁与民主" class="headerlink" title="独裁与民主"></a>独裁与民主</h2><p>两者并非不可兼得。为什么要兼得？为了效率。</p><p>我的眼中只有效率，不在乎形式，假如一个问题有两种既定方案，如果三十个人讨论半天各执己见，有些人选择A方案，有些人选择B方案，选择A方案的人试图说服选择B方案的人，选择B方案的人也试图说服选择A方案的人，最终的结果可能是选A也可能是选B，也可能出来一种新的C方案。</p><p><strong>不是所有人都能看见真相</strong>，经过讨论可能会让更多人走向正确的道路，也有可能会让少部分持有最佳方案却意志不够坚定的人被说服放弃，历史上这样的例子并不少见，每时每刻，都有数不清的人会在讨论中与<strong>成为历史</strong>或<strong>被历史遗忘</strong>擦肩而过。</p><p>我们更需要的是：交流意见 -&gt; 独立思考 -&gt; 独立决策。</p><h2 id="合力不等于力量的叠加"><a href="#合力不等于力量的叠加" class="headerlink" title="合力不等于力量的叠加"></a>合力不等于力量的叠加</h2><p>力量都是有方向的，方向相同则相加。很多时候一次糟糕的合作导致若干力量相抵消，最终还不如一个人的效率高，一个聪明的团队应该在力量和方向上都作出最优选择。</p><p>我自认为是一个没有大家所谓的“团队精神”的人，因为我认为即使我们做不到最好，也不要硬撑着搞形式，作出最糟糕的选择，效率才是最终目的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文只是我在大学时期关于小组决策效率与分工方面的思考，可能不适用于其它场景。&lt;/p&gt;
&lt;p&gt;在任何一个团队中，我始终都是先做一个观察者。因为在掌握足够的信息之前，我的看法可能是片面的，由此产生的观点及推论发表出来可能会误导人。&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="https://xaoxuu.com/blog/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
</feed>
