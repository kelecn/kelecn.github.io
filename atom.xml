<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kelecn</title>
  
  
  <link href="https://kelecn.top/atom.xml" rel="self"/>
  
  <link href="https://kelecn.top/"/>
  <updated>2020-10-26T14:57:02.405Z</updated>
  <id>https://kelecn.top/</id>
  
  <author>
    <name>kelecn</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C语言内存管理</title>
    <link href="https://kelecn.top/2020/09/07/21%E3%80%81C%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://kelecn.top/2020/09/07/21%E3%80%81C%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2020-09-07T12:00:00.000Z</published>
    <updated>2020-10-26T14:57:02.405Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简介：嵌入式系统的内存资源很稀缺，其内存页会更小，在嵌入式开发当中需要特别注意内存管理。<br><img src="https://w.wallhaven.cc/full/0w/wallhaven-0wqylq.jpg"></p><a id="more"></a><h3 id="一、内存分配方式"><a href="#一、内存分配方式" class="headerlink" title="一、内存分配方式"></a>一、内存分配方式</h3><hr><p>　　内存分配方式有三种：<br>　　[1]从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。<br>　　[2]在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。<br>　　[3]从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释 放内存。动态内存的生存期由程序员决定，使用非常灵活，但如果在堆上分配了空间，就有责任回收它，否则运行的程序会出现内存泄漏，频繁地分配和释放不同大 小的堆空间将会产生堆内碎块。</p><h3 id="二、程序的内存空间"><a href="#二、程序的内存空间" class="headerlink" title="二、程序的内存空间"></a>二、程序的内存空间</h3><hr><p>　　在C语言程序中，代码是放在内存中执行的，我们大致将程序所占用的内存分为四个区域：栈区 堆区 数据区 代码区。<br>　　一个由C/C++编译的程序占用的内存分为以下几个部分,</p><p><strong>1、栈区（stack）</strong></p><p>由编译器自动分配释放 ，存放为运行函数而分配的局部变量、函数参数、返回数据、返回地址等。其操作方式类似于数据结构中的栈。 例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recive</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;<span class="comment">//其中，参数a，参数b和变量c都是存放在栈区，当函数执行完毕的时候，它们占有的空间自动释放。</span></span><br></pre></td></tr></table></figure><p><strong>2、堆区（heap）</strong></p><p>一般由程序员分配释放（malloc&amp;free）， 若程序员不释放，程序结束时可能由OS(operating system)回收 。分配方式类似于链表。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *src;</span><br><span class="line">src = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">4</span> *<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line"><span class="comment">//动态分配内存，表示查找可用的连续4个字节内存的空间，并将该内存首地址强制转换为指向字符数据的指针赋给scr，为src这个指针变量分配4个char类型的空间。</span></span><br></pre></td></tr></table></figure><p><strong>3、数据区（全局区）</strong></p><p>1、（文字）常量区：存放常量，一般是字符串常量。<br>2、静态区（static）：存放全局变量和静态变量。<br>该区域是在程序结束后由操作系统释放。</p><p><strong>4、程序代码区</strong></p><p>存放函数体（类成员函数和全局函数）的二进制代码，也是由操作系统进行管理。</p><h3 id="三、一个例子"><a href="#三、一个例子" class="headerlink" title="三、一个例子"></a>三、一个例子</h3><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span>* p1[<span class="number">3</span>]= &#123;<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;ghi&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> p2[<span class="number">3</span>][<span class="number">4</span>]= &#123;<span class="string">&quot;123&quot;</span>,<span class="string">&quot;456&quot;</span>,<span class="string">&quot;789&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span>** p3= (<span class="keyword">char</span>**)<span class="built_in">malloc</span>( <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">char</span>*));</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p3[i]= (<span class="keyword">char</span> *)<span class="built_in">malloc</span> ( <span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">        <span class="built_in">sprintf</span>(p3[i],<span class="string">&quot;%d%d%d&quot;</span>,i,i,i);  </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        sprintf()函数:最常见的应用之一是把整数打印到字符串中</span></span><br><span class="line"><span class="comment">        例如：</span></span><br><span class="line"><span class="comment">        srpintf(s,&quot;%d&quot;,123);</span></span><br><span class="line"><span class="comment">        输出为：&quot;123&quot;</span></span><br><span class="line"><span class="comment">        输出结果不会打印在屏幕上，而是写入字符串中</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,p3[i]);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        printf()函数才将结果输出到屏幕上</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/kelecn/images/%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90.jpg"></p><h3 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、参考资料</h3><hr><p><a href="https://www.cnblogs.com/yif1991/p/5049638.html">C语言知识整理（3）：内存管理（详细版）</a></p><p><a href="https://www.jianshu.com/p/98cb5f584a31">C语言中一些关于内存四区的归纳</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简介：嵌入式系统的内存资源很稀缺，其内存页会更小，在嵌入式开发当中需要特别注意内存管理。&lt;br&gt;&lt;img src=&quot;https://w.wallhaven.cc/full/0w/wallhaven-0wqylq.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="知识" scheme="https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="嵌入式" scheme="https://kelecn.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="C语言" scheme="https://kelecn.top/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="内存" scheme="https://kelecn.top/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>常见总线通讯协议：SPI、I2C、UART、USART、CAN、USB等</title>
    <link href="https://kelecn.top/2020/09/05/20%E3%80%81%E5%B8%B8%E8%A7%81%E6%80%BB%E7%BA%BF%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%EF%BC%9ASPI%E3%80%81I2C%E3%80%81UART%E3%80%81USART%E3%80%81CAN%E3%80%81USB/"/>
    <id>https://kelecn.top/2020/09/05/20%E3%80%81%E5%B8%B8%E8%A7%81%E6%80%BB%E7%BA%BF%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%EF%BC%9ASPI%E3%80%81I2C%E3%80%81UART%E3%80%81USART%E3%80%81CAN%E3%80%81USB/</id>
    <published>2020-09-05T13:50:00.000Z</published>
    <updated>2020-10-26T14:56:19.125Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简介：介绍常见总线通讯协议：SPI、I2C、UART、USART、CAN、USB等。<br><img src="https://w.wallhaven.cc/full/43/wallhaven-43kg30.jpg"></p><a id="more"></a><h3 id="一、SPI：串行外设接口"><a href="#一、SPI：串行外设接口" class="headerlink" title="一、SPI：串行外设接口"></a>一、SPI：串行外设接口</h3><hr><p>SPI（Serial Peripheral Interface）是一种由Motorola公司提出的串行串行同步通讯协议，由一个主设备和一个或多个从设备组成。其拥有四根(类)硬脚引线，分别为 SDI（串行数据输入），SDO（串行数据输出），SCK（串行移位时钟），CS（片选）。因为一个主设备可以挂多个从设备，则通过片选引脚对从设备进行选择。从设备的工作时钟则是来自于主设备的SCK线。</p><p><strong>1.1  电路示意图</strong></p><p><img src="https://i.loli.net/2020/10/19/AMdWBKQ3rEuqY6J.png"></p><p><strong>1.2  数据的传输</strong></p><p>SPI在数据传输的时候，需要确定两件事情：其一，数据是在时钟的上升沿采集还是下降沿采集；其二，时钟的初始(空闲)状态是为高电平还是低电平。而I2C的空闲状态，时钟线为高电平；数据采集的时候，时钟线也为高电平。但SPI给出了更自由的方式。</p><p>CPOL：时钟极性, 表示 SPI 在空闲时, 时钟信号是高电平还是低电平。</p><p>CPHA：时钟相位, 表示 SPI 设备是在 SCK 管脚上的时钟信号变为上升沿时触发数据采样, 还是在时钟信号变为下降沿时触发数据采样。</p><p>那么，SPI CPOL有两种可能，CPHA有两种可能，则SPI数据传输就有四种可能—按照标准的说法，SPI数据传输就有四种模式。</p><p><img src="https://i.loli.net/2020/10/19/EP18ladSbs7eBfD.png"></p><p><img src="https://i.loli.net/2020/10/19/wkXPlg5TjNRVzKB.png"></p><p><img src="https://i.loli.net/2020/10/19/ZBQTzHjsCqoXaLM.png"></p><p><img src="https://i.loli.net/2020/10/19/rvpmoZsayKjuPDk.png"></p><p><img src="https://i.loli.net/2020/10/19/uK87tNvjsEnoxS5.png"></p><p><strong>1.3  SPI读写</strong></p><p>SPI在硬件设计上采用的双数据线制，根据设计，在SPI通信过程中，主从设备之间会形成一个数据环形链路—也即是，主设备向从设备写一次数据，从设备就会回一次数据(至于该从设备回复的数据是否有效，则另当别论—如果有效，主设备就把它读入；如果无效，则丢弃即可)。</p><p><img src="https://i.loli.net/2020/10/19/I3XNlJKQFuhe1Za.png"></p><p><img src="https://i.loli.net/2020/10/19/X1ekaFGwvPjcSYh.png"></p><h3 id="二、I2C：意为IC之间总线"><a href="#二、I2C：意为IC之间总线" class="headerlink" title="二、I2C：意为IC之间总线"></a>二、I2C：意为IC之间总线</h3><hr><p><strong>I²C</strong> (<strong>Inter-Integrated Circuit</strong>)。其拥有一根数据线SDA和一根时钟线SCL。其总线通过上拉电阻与电源相连接。每个接到I2C总线上的器件都有唯一的地址。其中，主动发起操作的一方为主机，另外一方为从机。</p><p><strong>1.1  电路示意图</strong></p><p><img src="https://i.loli.net/2020/10/19/bOAjyodXL4QEfFe.png"></p><p><strong>1.2 数据传输</strong></p><p>当没有数据传输的时候，两根总线都为高电平；当采集IIC上的数据时，其时钟线SCL必须是高电平且SDA的数据必须保持稳定不变—将SDA的电平与SCL的高电平进行“与”操作后，以便确定SDA上是1还是0；在SCL为低电平的时候，SDA上的数据可以进行跳变。</p><p>数据传输开始时，需要发送一个起始信号；数据传输结束后，需要发送一个终止信号；每8bit数据传输结束，都需要一个ACK。起止信号都有Master发出，而ACK则可能由Master或者SLAVE来发出。数据的传输采用大端传输。</p><p>开始信号：SCL为高电平，SDA的电平由高跳到低表示开始信号。</p><p>终止信号：SCL为高电平，SDA的电平由低跳到高表示终止信号。</p><p><img src="https://i.loli.net/2020/10/19/Aj2czE6vKdFxs5P.png"></p><p><strong>1.3 数据协议</strong></p><p><img src="https://i.loli.net/2020/10/19/GnaKejT4yMIcRiz.png"></p><p><strong>1.4  I2C读写流程</strong></p><p><img src="https://i.loli.net/2020/10/19/qT2A8OmuDR1CoaY.png"></p><p><img src="https://i.loli.net/2020/10/19/oTSdiG3Ov89jMey.png"></p><p><img src="https://i.loli.net/2020/10/19/iMXBxWsm9E5A2NQ.png"></p><p><img src="https://i.loli.net/2020/10/19/zRjVw9kO5aBTlyH.png"></p><h3 id="三、UART：通用异步收发器"><a href="#三、UART：通用异步收发器" class="headerlink" title="三、UART：通用异步收发器"></a>三、UART：通用异步收发器</h3><hr>**1.1  电路示意图**<p>UART是一个大家族，其包括了RS232、RS499、RS423、RS422和RS485等接口标准规范和总线标准规范。它们的主要区别在于其各自的电平范围不相同。</p><p>嵌入式设备中常常使用到的是TTL、TTL转RS232的这种方式。常用的就三根引线：发送线TX、接收线RX、电平参考地线GND。</p><p><img src="https://i.loli.net/2020/10/19/IdEzHLYABVh5rQD.png"></p><p><strong>1.2  通信协议</strong></p><p>将传输数据的每个字符一位接一位地传输。</p><p><img src="https://i.loli.net/2020/10/19/8pUDkvCqPsVKbrg.png"></p><p>起始位：先发出一个逻辑”0”的信号，表示传输字符的开始。</p><p>数据位：紧接着起始位之后。数据位的个数可以是4、5、6、7、8等，构成一个字符。通常采用ASCII码。</p><p>奇偶校验位：数据位加上这一位后，使得“1”的位数应为偶数(偶校验)或奇数(奇校验)，以此来校验资料传送的正确性。</p><p>停止位：它是一个字符数据的结束标志。可以是1位、1.5位、2位的高电平。</p><p>空闲位：处于逻辑“1”状态，表示当前线路上没有资料传送。</p><p>波特率：数据传输的速率。有以下几个档位：300、600、1200、2400、4800、9600、19200、38400、43000、56000、57600、115200.当然也可以自定义。在数据传输和接收双方，需要预先统一波特率，以便正确的传输数据。</p><h3 id="四、USART：通用同步异步收发器"><a href="#四、USART：通用同步异步收发器" class="headerlink" title="四、USART：通用同步异步收发器"></a>四、USART：通用同步异步收发器</h3><hr><p>USART是一个全双工通用同步/异步串行收发模块，该接口是一个高度灵活的串行通信设备。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 全双工操作（相互独立的接收数据和发送数据）；</span><br><span class="line">2. 同步操作时，可主机时钟同步，也可从机时钟同步；</span><br><span class="line">3. 独立的高精度波特率发生器，不占用定时/计数器；</span><br><span class="line">4. 支持5、6、7、8和9位数据位，1或2位停止位的串行数据桢结构；</span><br><span class="line">5. 由硬件支持的奇偶校验位发生和检验；</span><br><span class="line">6. 数据溢出检测；</span><br><span class="line">7. 帧错误检测；</span><br><span class="line">8. 包括错误起始位的检测噪声滤波器和数字低通滤波器；</span><br><span class="line">9. 三个完全独立的中断，TX发送完成、TX发送数据寄存器空、RX接收完成；</span><br><span class="line">10.支持多机通信模式；</span><br><span class="line">11.支持倍速异步通信模式。</span><br></pre></td></tr></table></figure><h3 id="五、CAN：现场总线"><a href="#五、CAN：现场总线" class="headerlink" title="五、CAN：现场总线"></a>五、CAN：现场总线</h3><hr><p>CAN是控制器局域网络(Controller Area Network, CAN)的简称，是由以研发和生产汽车电子产品著称的德国BOSCH公司开发的，并最终成为国际标准（ISO 11898），是国际上应用最广泛的现场总线之一。 在北美和西欧，CAN总线协议已经成为汽车计算机控制系统和嵌入式工业控制局域网的标准总线，并且拥有以CAN为底层协议专为大型货车和重工机械车辆设计的J1939协议。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CAN属于现场总线的范畴，它是一种有效支持分布式控制或实时控制的串行通信网络。较之许多RS-485基于R线构建的分布式控制系统而言，基于CAN总线的分布式控制系统在以下方面具有明显的优越性：</span><br><span class="line">1、网络各节点之间的数据通信实时性强</span><br><span class="line">2、开发周期短</span><br><span class="line">3、已形成国际标准的现场总线</span><br><span class="line">4、最有前途的现场总线之一</span><br></pre></td></tr></table></figure><h3 id="六、LIN：局域互联网络"><a href="#六、LIN：局域互联网络" class="headerlink" title="六、LIN：局域互联网络"></a>六、LIN：局域互联网络</h3><hr><p>LIN总线是针对汽车分布式电子系统而定义的一种低成本的串行通讯网络，是对控制器区域网络(CAN)等其它汽车多路网络的一种补充，适用于对网络的带宽、性能或容错功能没有过高要求的应用。LIN总线是基于SCI(UART)数据格式，采用单主控制器/多从设备的模式，是UART中的一种特殊情况。</p><h3 id="七、USB：通用串行总线"><a href="#七、USB：通用串行总线" class="headerlink" title="七、USB：通用串行总线"></a>七、USB：通用串行总线</h3><hr><p>USB是英文Universal Serial BUS（通用串行总线）的缩写，是一个外部总线标准，用于规范电脑与外部设备的连接和通讯，是应用在PC 领域的接口技术。USB 接口支持设备的即 即用和热插拔功能。USB 是在1994 年底由尔、康柏.IBM、Microsoft 等多家公司联合提出的.USB的电气特性还有传输特性</p><h3 id="八、GPIO：通用输入-输出"><a href="#八、GPIO：通用输入-输出" class="headerlink" title="八、GPIO：通用输入/输出"></a>八、GPIO：通用输入/输出</h3><hr><p> <strong>GPIO</strong>（General Purpose Input Output ）为通用输入/输出，通用端口，总线扩展器， 利用工业标准I2C、SMBus™或SPI™接口简化了I/O口的扩展。当微控制器或芯片组没有足够的I/O端口，或当系统需要采用远端串行通信或控制时，GPIO产品能够提供额外的控制和监视功能。</p><p>由于LIN网络在汽车中一般不独立存在，通常会与上层CAN网络相连，形成CAN-LIN网关节点。</p><h3 id="九、SPI、I2C、UART、CAN、LIN对比"><a href="#九、SPI、I2C、UART、CAN、LIN对比" class="headerlink" title="九、SPI、I2C、UART、CAN、LIN对比"></a>九、SPI、I2C、UART、CAN、LIN对比</h3><hr><p><img src="https://cdn.jsdelivr.net/gh/kelecn/images/%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE%E5%AF%B9%E6%AF%94.png"></p><h3 id="十、参考文献"><a href="#十、参考文献" class="headerlink" title="十、参考文献"></a>十、参考文献</h3><hr><p><a href="https://blog.csdn.net/weixin_43046653/article/details/84998083?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">通信方式梳理：GPIO，I2C，SPI，UART，USART，USB的区别</a></p><p><a href="https://blog.csdn.net/qq_32693119/article/details/81263446">通信总线协议学习整理</a></p><p><a href="https://blog.csdn.net/weixin_43046653/article/details/84998083?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">通信方式梳理：GPIO，I2C，SPI，UART，USART，USB的区别</a></p><p><a href="https://blog.csdn.net/u010183728/article/details/81984433">SPI、I2C、UART、CAN</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简介：介绍常见总线通讯协议：SPI、I2C、UART、USART、CAN、USB等。&lt;br&gt;&lt;img src=&quot;https://w.wallhaven.cc/full/43/wallhaven-43kg30.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="知识" scheme="https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="SPI" scheme="https://kelecn.top/tags/SPI/"/>
    
    <category term="I2C" scheme="https://kelecn.top/tags/I2C/"/>
    
    <category term="USB" scheme="https://kelecn.top/tags/USB/"/>
    
    <category term="总线" scheme="https://kelecn.top/tags/%E6%80%BB%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>精简指令集计算机(RISC)和复杂指令集计算机(CISC)的区别</title>
    <link href="https://kelecn.top/2020/09/01/19%E3%80%81%E5%A4%8D%E6%9D%82%E6%8C%87%E4%BB%A4%E9%9B%86%E8%AE%A1%E7%AE%97%E6%9C%BA(CISC)%E5%92%8C%E7%B2%BE%E7%AE%80%E6%8C%87%E4%BB%A4%E9%9B%86%E8%AE%A1%E7%AE%97%E6%9C%BA(RISC)%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://kelecn.top/2020/09/01/19%E3%80%81%E5%A4%8D%E6%9D%82%E6%8C%87%E4%BB%A4%E9%9B%86%E8%AE%A1%E7%AE%97%E6%9C%BA(CISC)%E5%92%8C%E7%B2%BE%E7%AE%80%E6%8C%87%E4%BB%A4%E9%9B%86%E8%AE%A1%E7%AE%97%E6%9C%BA(RISC)%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-09-01T13:50:00.000Z</published>
    <updated>2020-10-26T14:54:58.059Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简介：精简指令集计算机(RISC)和复杂指令集计算机(CISC)的区别<br><img src="https://w.wallhaven.cc/full/6q/wallhaven-6q9o2l.png"></p><a id="more"></a><h3 id="一、RISC（精简指令集计算机）"><a href="#一、RISC（精简指令集计算机）" class="headerlink" title="一、RISC（精简指令集计算机）"></a>一、RISC（精简指令集计算机）</h3><hr><p>RISC（reduced instruction set computer，精简指令集计算机）是一种执行较少类型计算机指令的微处理器。这样一来，它能够以更快的速度执行操作。因为计算机执行每个指令类型都需要额外的晶体管和电路元件，计算机指令集越大就会使微处理器更复杂，执行操作也会更慢。</p><h3 id="二、-CISC-复杂指令集计算机）"><a href="#二、-CISC-复杂指令集计算机）" class="headerlink" title="二、 CISC(复杂指令集计算机）"></a>二、 CISC(复杂指令集计算机）</h3><hr><p>除了RISC，任何全指令集计算机都使用的是CISC（complexinstruction set computer，复杂指令集计算机）。</p><p>目前常见使用RISC的处理器包括DEC Alpha、ARC、ARM、MIPS、PowerPC、SPARC和SuperH等。</p><p>常见使用CISC的处理器主要有X86.</p><h3 id="三、RISC和CISC的区别"><a href="#三、RISC和CISC的区别" class="headerlink" title="三、RISC和CISC的区别"></a>三、RISC和CISC的区别</h3><hr><p><strong>（1） 指令系统：</strong>RISC 设计者把主要精力放在那些经常使用的指令上，尽量使它们具有简单高效的特色。对不常用的功能，常通过组合指令来完成。因此，在RISC 机器上实现特殊功能时，效率可能较低。但可以利用流水技术和超标量技术加以改进和弥补。而CISC 计算机的指令系统比较丰富，有专用指令来完成特定的功能。因此，处理特殊任务效率较高。</p><p><strong>（2） 存储器操作：</strong>RISC 对存储器操作有限制，使控制简单化；而CISC 机器的存储器操作指令多，操作直接。</p><p><strong>（3） 程序：</strong>RISC 汇编语言程序一般需要较大的内存空间，实现特殊功能时程序复杂，不易设计；而CISC 汇编语言程序编程相对简单，科学计算及复杂操作的程序设计相对容易，效率较高。</p><p><strong>（4） 中断：</strong>RISC 机器在一条指令执行的适当地方可以响应中断；而CISC 机器是在一条指令执行结束后响应中断。</p><p><strong>（5） CPU芯片电路：</strong>RISC CPU 包含有较少的单元电路，因而面积小、功耗低；而CISC CPU 包含有丰富的电路单元，因而功能强、面积大、功耗大。</p><p><strong>（6） 设计周期：</strong>RISC 微处理器结构简单，布局紧凑，设计周期短，且易于采用最新技术；CISC 微处理器结构复杂，设计周期长。</p><p><strong>（7） 用户使用：</strong>RISC 微处理器结构简单，指令规整，性能容易把握，易学易用；CISC微处理器结构复杂，功能强大，实现特殊功能容易。</p><p><strong>（8） 应用范围：</strong>由于RISC 指令系统的确定与特定的应用领域有关，故RISC 机器更适合于专用机；而CISC 机器则更适合于通用机。</p><h3 id="四、参考文章"><a href="#四、参考文章" class="headerlink" title="四、参考文章"></a>四、参考文章</h3><hr><p><a href="https://blog.csdn.net/WHEgqing/article/details/101300822">RISC和CISC的区别</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简介：精简指令集计算机(RISC)和复杂指令集计算机(CISC)的区别&lt;br&gt;&lt;img src=&quot;https://w.wallhaven.cc/full/6q/wallhaven-6q9o2l.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="知识" scheme="https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="CISC" scheme="https://kelecn.top/tags/CISC/"/>
    
    <category term="RISC" scheme="https://kelecn.top/tags/RISC/"/>
    
    <category term="指令集" scheme="https://kelecn.top/tags/%E6%8C%87%E4%BB%A4%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>几种常见的DC-DC拓扑</title>
    <link href="https://kelecn.top/2020/08/28/18%E3%80%81%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84DC-DC%E6%8B%93%E6%89%91/"/>
    <id>https://kelecn.top/2020/08/28/18%E3%80%81%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84DC-DC%E6%8B%93%E6%89%91/</id>
    <published>2020-08-28T13:50:00.000Z</published>
    <updated>2020-10-26T14:32:13.034Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简介：开关电源三大基础拓扑解析：BUCK/BOOST/BUCK-BOOST<br><img src="https://w.wallhaven.cc/full/j8/wallhaven-j863k5.jpg"></p><a id="more"></a><h3 id="一、Buck-拓扑电路"><a href="#一、Buck-拓扑电路" class="headerlink" title="一、Buck 拓扑电路"></a>一、Buck 拓扑电路</h3><hr><p><img src="https://i.loli.net/2020/10/16/rbCHwEJvOo5c8Y3.png"><br>Buck电路是一个降压电路，Uin=Ul+Uo。因Uin&gt;Uo,故具有降压作用。</p><h3 id="二、Boost拓扑电路"><a href="#二、Boost拓扑电路" class="headerlink" title="二、Boost拓扑电路"></a>二、Boost拓扑电路</h3><hr><p><img src="https://i.loli.net/2020/10/16/cX8pmlbNvU9IiCB.png"><br>Boost电路是一个升压电路，Uo=Uin+Ul-Ud ,由于Ud值较小，忽略不计，Uin+Ul&gt;Uo,故具有升压作用。</p><h3 id="三、Buck-Boost拓扑电路"><a href="#三、Buck-Boost拓扑电路" class="headerlink" title="三、Buck-Boost拓扑电路"></a>三、Buck-Boost拓扑电路</h3><hr><p><img src="https://i.loli.net/2020/10/16/B6LDJfIMojQirGb.png"></p><ul><li>其中的器件和Buck电路完全一致，只是开关SW，二极管和电感的位置发生了改变</li><li>Buck-Boost变换器输出的是相对地的负压<h3 id="四、参考文献"><a href="#四、参考文献" class="headerlink" title="四、参考文献"></a>四、参考文献</h3></li></ul><hr><p><a href="https://blog.csdn.net/ima_xu/article/details/88393304">开关电源学习笔记1 — Buck变换器的基本原理</a><br><a href="https://blog.csdn.net/ima_xu/article/details/88382812">开关电源学习笔记2 — Boost变换器的基本原理</a><br><a href="https://blog.csdn.net/ima_xu/article/details/88536926">开关电源学习笔记3 — Buck-Boost变换器的基本原理</a><br><a href="https://zhuanlan.zhihu.com/p/52887325">开关电源三大基础拓扑解析：BUCK/BOOST/BUCK-BOOST</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简介：开关电源三大基础拓扑解析：BUCK/BOOST/BUCK-BOOST&lt;br&gt;&lt;img src=&quot;https://w.wallhaven.cc/full/j8/wallhaven-j863k5.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="知识" scheme="https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Boost" scheme="https://kelecn.top/tags/Boost/"/>
    
    <category term="Buck" scheme="https://kelecn.top/tags/Buck/"/>
    
    <category term="DCDC" scheme="https://kelecn.top/tags/DCDC/"/>
    
  </entry>
  
  <entry>
    <title>一文搞懂TCP与UDP的区别</title>
    <link href="https://kelecn.top/2020/08/26/17%E3%80%81%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82TCP%E4%B8%8EUDP%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://kelecn.top/2020/08/26/17%E3%80%81%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82TCP%E4%B8%8EUDP%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-08-26T13:57:00.000Z</published>
    <updated>2020-10-26T14:33:28.933Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简介：网络协议是每个IT工程师都必须要掌握的知识，TCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP，本文将介绍下这两者以及它们之间的区别。<br><img src="https://i.loli.net/2020/10/15/icOPNUCS2Kgzy7W.jpg"></p><a id="more"></a><h3 id="一、TCP-IP网络模型"><a href="#一、TCP-IP网络模型" class="headerlink" title="一、TCP/IP网络模型"></a>一、TCP/IP网络模型</h3><hr><p>计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（protocol）。</p><p>TCP/IP 是互联网相关的各类协议族的总称，比如：TCP，UDP，IP，FTP，HTTP，ICMP，SMTP 等都属于 TCP/IP 族内的协议。</p><p>TCP/IP模型是互联网的基础，它是一系列网络协议的总称。这些协议可以划分为四层，分别为链路层、网络层、传输层和应用层。</p><ul><li>链路层：负责封装和解封装IP报文，发送和接受ARP/RARP报文等。</li><li>网络层：负责路由以及把分组报文发送给目标网络或主机。</li><li>传输层：负责对报文进行分组和重组，并以TCP或UDP协议格式封装报文。</li><li>应用层：负责向用户提供应用程序，比如HTTP、FTP、Telnet、DNS、SMTP等。</li></ul><p><img src="https://i.loli.net/2020/10/15/1gqV3oWnEi7yZxB.png"></p><p>在网络体系结构中网络通信的建立必须是在通信双方的对等层进行，不能交错。 在整个数据传输过程中，数据在发送端时经过各层时都要附加上相应层的协议头和协议尾（仅数据链路层需要封装协议尾）部分，也就是要对数据进行协议封装，以标识对应层所用的通信协议。接下去介绍TCP/IP 中有两个具有代表性的传输层协议—-TCP 和 UDP。</p><h3 id="二、UDP"><a href="#二、UDP" class="headerlink" title="二、UDP"></a>二、UDP</h3><hr><p>UDP协议全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。</p><p>它有以下几个特点：</p><p><strong>1. 面向无连接</strong></p><p>首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。</p><p>具体来说就是：</p><ul><li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了</li><li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</li></ul><p><strong>2. 有单播，多播，广播的功能</strong></p><p>UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。</p><p><strong>3. UDP是面向报文的</strong></p><p>发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文</p><p><strong>4. 不可靠性</strong></p><p>首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。</p><p>并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。</p><p>再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。</p><p><img src="https://i.loli.net/2020/10/15/CV5nmJiacTAyQFH.gif"></p><p>从上面的动态图可以得知，UDP只会把想发的数据报文一股脑的丢给对方，并不在意数据有无安全完整到达。</p><p><strong>5. 头部开销小，传输数据报文时是很高效的。</strong></p><p><img src="https://i.loli.net/2020/10/15/xcSuoCbsHUvTgnE.png"></p><p>UDP 头部包含了以下几个数据：</p><ul><li>两个十六位的端口号，分别为源端口（可选字段）和目标端口</li><li>整个数据报文的长度</li><li>整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误</li></ul><p>因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的</p><h3 id="三、TCP"><a href="#三、TCP" class="headerlink" title="三、TCP"></a>三、TCP</h3><hr><p>当一台计算机想要与另一台计算机通讯时，两台计算机之间的通信需要畅通且可靠，这样才能保证正确收发数据。例如，当你想查看网页或查看电子邮件时，希望完整且按顺序查看网页，而不丢失任何内容。当你下载文件时，希望获得的是完整的文件，而不仅仅是文件的一部分，因为如果数据丢失或乱序，都不是你希望得到的结果，于是就用到了TCP。</p><p>TCP协议全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的RFC 793定义。TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，你可以把它想象成排水管中的水流。</p><p><strong>1. TCP连接过程</strong></p><p>如下图所示，可以看到建立一个TCP连接的过程为（三次握手的过程）:</p><p><img src="https://i.loli.net/2020/10/15/5cVC9ElRnb1jqQZ.png"></p><p><strong>第一次握手</strong></p><p>客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。</p><p><strong>第二次握手</strong></p><p>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。</p><p><strong>第三次握手</strong></p><p>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。</p><p>这里可能大家会有个疑惑：为什么 TCP 建立连接需要三次握手，而不是两次？这是因为这是为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。</p><p><img src="https://i.loli.net/2020/10/15/jzIdoxmeAnbp9HM.gif"></p><p><strong>2. TCP断开链接</strong></p><p><img src="https://i.loli.net/2020/10/15/hgMfjN9XKrvuxUc.png"></p><p>TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK。</p><p><strong>第一次握手</strong></p><p>若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。</p><p><strong>第二次握手</strong></p><p>B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。</p><p><strong>第三次握手</strong></p><p>B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。</p><p><strong>第四次握手</strong></p><p>A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。</p><p><strong>3. TCP协议的特点</strong></p><ul><li><p>面向连接</p><p>面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。</p></li><li><p>仅支持单播传输</p></li></ul><p>每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。</p><ul><li>面向字节流</li></ul><p>TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。</p><ul><li><p>可靠传输</p><p>对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。</p></li><li><p>提供拥塞控制</p></li></ul><p>当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞</p><ul><li>TCP提供全双工通信</li></ul><p>TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）</p><h3 id="四、TCP和UDP的比较"><a href="#四、TCP和UDP的比较" class="headerlink" title="四、TCP和UDP的比较"></a>四、TCP和UDP的比较</h3><hr><p><strong>1. 对比</strong></p><table><thead><tr><th align="left"></th><th align="left">UDP</th><th>TCP</th></tr></thead><tbody><tr><td align="left">是否连接</td><td align="left">无连接</td><td>面向连接</td></tr><tr><td align="left">是否可靠</td><td align="left">不可靠传输，不使用流量控制和拥塞控制</td><td>可靠传输，使用流量控制和拥塞控制</td></tr><tr><td align="left">连接对象个数</td><td align="left">支持一对一，一对多，多对一和多对多交互通信</td><td>只能是一对一通信</td></tr><tr><td align="left">传输方式</td><td align="left">面向报文</td><td>面向字节流</td></tr><tr><td align="left">首部开销</td><td align="left">首部开销小，仅8字节</td><td>首部最小20字节，最大60字节</td></tr><tr><td align="left">适用场景</td><td align="left">适用于实时应用（IP电话、视频会议、直播等）</td><td>适用于要求可靠传输的应用，例如文件传输</td></tr></tbody></table><p><strong>2. 总结</strong></p><ul><li>TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务。</li><li>虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为</li><li>对数据准确性要求高，速度可以相对较慢的，可以选用TCP</li></ul><h3 id="五、参考文章"><a href="#五、参考文章" class="headerlink" title="五、参考文章"></a><strong>五、参考文章</strong></h3><hr><p><strong><a href="https://www.cnblogs.com/fundebug/p/differences-of-tcp-and-udp.html">一文搞懂TCP与UDP的区别</a></strong> </p><p><strong><a href="https://blog.csdn.net/qq_38950316/article/details/81087809">TCP的三次握手与四次挥手理解及面试题（很全面）</a></strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简介：网络协议是每个IT工程师都必须要掌握的知识，TCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP，本文将介绍下这两者以及它们之间的区别。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2020/10/15/icOPNUCS2Kgzy7W.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="知识" scheme="https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="TCP" scheme="https://kelecn.top/tags/TCP/"/>
    
    <category term="UDP" scheme="https://kelecn.top/tags/UDP/"/>
    
    <category term="计算机网络" scheme="https://kelecn.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>C语言基础知识（复习）</title>
    <link href="https://kelecn.top/2020/08/25/16%E3%80%81C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E5%A4%8D%E4%B9%A0%EF%BC%89/"/>
    <id>https://kelecn.top/2020/08/25/16%E3%80%81C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E5%A4%8D%E4%B9%A0%EF%BC%89/</id>
    <published>2020-08-25T13:57:00.000Z</published>
    <updated>2020-10-26T14:16:17.563Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简介： 嵌入式笔试相关题目、考点。<br><img src="https://w.wallhaven.cc/full/5w/wallhaven-5wr6y9.jpg"></p><a id="more"></a><h3 id="一、static关键词"><a href="#一、static关键词" class="headerlink" title="一、static关键词"></a>一、static关键词</h3><hr><p>1）、用于声明函数体内的变量为静态局部变量，存储在静态数据存储区，在函数被调用过程中维持其值保持不变。<br>2）、在文件内（函数体外）被声明为静态的变量，可以被文件内的所有函数访问，但不能被其他文件的函数访问，是一个本地的局部变量。<br>3）、在文件内,被声明为静态的函数只可被文件内的其他函数调用，但不能被其他文件的函数调用。</p><h3 id="二、const关键词"><a href="#二、const关键词" class="headerlink" title="二、const关键词"></a>二、const关键词</h3><hr><p>常类型是指使用类型修饰符const说明的类型，常类型的变量或对象的值是不能被更新的。不管出现在任何上下文都是为这个目的而服务的。<br>注意:非const变量默认为extern。要使const变量能够在其他文件中访问，必须在文件中显式地指定它为extern。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="comment">//同上面的代码行是等价的，都表示一个常整形数。</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> a;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* const具有&quot;左结合&quot;性，即const修饰*，那么，不难理解，该句表示一个指向整数的常指针，</span></span><br><span class="line"><span class="comment">   a指向的整数可以修改，但指针a不能修改。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 同理，下面的这两行，根据&quot;左结合&quot;性，const修饰的是(*a)，也即是一个整数，</span></span><br><span class="line"><span class="comment">   所以，这两句表示指针指向一个常整数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *a;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据&quot;左结合&quot;性质，第一个const修饰(*)，第二个const修饰(a)，因此，这句话表示一个指向常整数的常指针。</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *a <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p; <span class="comment">//*p是const,p可变</span></span><br><span class="line"><span class="keyword">const</span> (<span class="keyword">char</span> *) p;<span class="comment">//p是const,*p可变</span></span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> p; <span class="comment">//p是const,*p可变</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> p; <span class="comment">//p和*p都是const</span></span><br><span class="line"><span class="keyword">char</span> <span class="keyword">const</span> * p;<span class="comment">// *p是const,p可变</span></span><br><span class="line">(<span class="keyword">char</span>*) <span class="keyword">const</span> p;<span class="comment">//p是const,*p可变</span></span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> p;<span class="comment">// p是const,*p可变</span></span><br><span class="line"><span class="keyword">char</span> <span class="keyword">const</span>* <span class="keyword">const</span> p;<span class="comment">// p和*p都是const</span></span><br><span class="line"><span class="comment">//例如</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//const修饰一个变量为只读</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//a = 100; //err</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指针变量， 指针指向的内存， 2个不同概念</span></span><br><span class="line"><span class="keyword">char</span> buf[] = <span class="string">&quot;aklgjdlsgjlkds&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从左往右看，跳过类型，看修饰哪个字符</span></span><br><span class="line"><span class="comment">//如果是*， 说明指针指向的内存不能改变</span></span><br><span class="line"><span class="comment">//如果是指针变量，说明指针的指向不能改变，指针的值不能修改</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p = buf;</span><br><span class="line"><span class="comment">// 等价于上面 char const *p1 = buf;</span></span><br><span class="line"><span class="comment">//p[1] = &#x27;2&#x27;; //err</span></span><br><span class="line">p = <span class="string">&quot;agdlsjaglkdsajgl&quot;</span>; <span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> * <span class="keyword">const</span> p2 = buf;</span><br><span class="line">p2[<span class="number">1</span>] = <span class="string">&#x27;3&#x27;</span>;</span><br><span class="line"><span class="comment">//p2 = &quot;salkjgldsjaglk&quot;; //err</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//p3为只读，指向不能变，指向的内存也不能变</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> p3 = buf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、数组越界问题"><a href="#三、数组越界问题" class="headerlink" title="三、数组越界问题"></a>三、数组越界问题</h3><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">string</span>[<span class="number">10</span>];<span class="comment">//应该是char string[11];//字符串数组最后一位是\0</span></span><br><span class="line"><span class="keyword">char</span>*str=<span class="string">&quot;0123456789&quot;</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(<span class="built_in">string</span>,str);<span class="comment">//err</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、C语言中宏定义的使用"><a href="#四、C语言中宏定义的使用" class="headerlink" title="四、C语言中宏定义的使用"></a>四、C语言中宏定义的使用</h3><hr><p>==预处理==命令可以改变程序设计环境,提高编程效率,它们并不是 C 语言本身的组成部分,不能直接对 它们进行编译,必须在对程序进行编译之前,先对程序中这些特殊的命令进行“预处理” 。经过预处理后,程序就不再包括预处理命令了,最后再由编译程序对==预处理==之后的源程序进行==编译==处理,得到可供执行的目标代码。C 语言提供的预处理功能有三种,分别为==宏定义==、文件包含和条件编译。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不带参数的宏定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 10</span></span><br><span class="line"><span class="comment">/*带参宏定义*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M(y) y*y+3*y</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*宏调用*/</span></span><br><span class="line">k=M(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//宏定义最大值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) (((a)&gt;(b))?(a):(b))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; max(<span class="number">1</span>+<span class="number">1</span>,<span class="number">2</span>+<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个面试题主要考查面试者对宏定义的使用，宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对“参数”进行的是一对一的替换。</span></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">#define  MAX( x, y ) ( ((x) &gt; (y)) ? (x) : (y) )//输入a++，a=a+2 调用两次</span></span><br><span class="line"><span class="comment">#define  MIN( x, y ) ( ((x) &lt; (y)) ? (x) : (y) )</span></span><br><span class="line"><span class="comment">#define MAX( a, b )  (&#123;int _a = a;int _b = b;(_a) &gt; (_b)? (_a) :(_b); &#125;)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*程序员对宏定义的使用要非常小心，特别要注意两个问题：</span></span><br><span class="line"><span class="comment">　　（1）谨慎地将宏定义中的“参数”和整个宏用用括弧括起来。所以，严格地讲，下述解答：</span></span><br><span class="line"><span class="comment">#define MIN(A,B) (A) &lt;= (B) ? (A) : (B)</span></span><br><span class="line"><span class="comment">#define MIN(A,B) (A &lt;= B ? A : B )</span></span><br><span class="line"><span class="comment">　　都应判0分；</span></span><br><span class="line"><span class="comment">　　（2）防止宏的副作用。</span></span><br><span class="line"><span class="comment">　　宏定义#define MIN(A,B) ((A) &lt;= (B) ? (A) : (B))对MIN(*p++, b)的作用结果是：</span></span><br><span class="line"><span class="comment">((*p++) &lt;= (b) ? (*p++) : (*p++))</span></span><br><span class="line"><span class="comment">　　这个表达式会产生副作用，指针p会作三次++自增操作。</span></span><br><span class="line"><span class="comment">　　除此之外，另一个应该判0分的解答是：</span></span><br><span class="line"><span class="comment">#define MIN(A,B) ((A) &lt;= (B) ? (A) : (B));  不能在后面加冒号。</span></span><br></pre></td></tr></table></figure><p>参考文章：<a href="https://www.cnblogs.com/emptyYPen/p/7872604.html">宏定义正确处理a++</a></p><h3 id="五、递归算N！"><a href="#五、递归算N！" class="headerlink" title="五、递归算N！"></a>五、递归算N！</h3><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">long</span> <span class="title">fac</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="keyword">long</span> f;</span><br><span class="line"> <span class="keyword">if</span>(n&lt;<span class="number">0</span>)</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;n&lt;0,data error!&quot;</span>);</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">0</span>,n==<span class="number">1</span>)</span><br><span class="line"> f=<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">else</span> f = fac(n<span class="number">-1</span>)*n;</span><br><span class="line"> <span class="keyword">return</span> (f);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fac</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="keyword">int</span> n,y;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;input an integer number:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">y= fac(n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d!=%ld\n&quot;</span>,n,y);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><h3 id="六、中断服务子程序-ISR"><a href="#六、中断服务子程序-ISR" class="headerlink" title="六、中断服务子程序(ISR)"></a>六、中断服务子程序(ISR)</h3><hr><p>中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展-让标准C支持中断。其代表事实是，产生了一个新的关键字 interrupt（51即如此）。下面的代码就使用了interrupt关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__interrupt <span class="keyword">double</span> <span class="title">compute_area</span> <span class="params">(<span class="keyword">double</span> radius)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> area = PI * radius * radius;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;/nArea = %f&quot;</span>, area);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> area;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">中断服务程序需要满足如下要求： </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">(1)不能返回值； </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">(2)不能向ISR传递参数； （嵌入式中的ISR指的是中断服务处理）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">(3) ISR应该尽可能的短小精悍； </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">(4) printf(char * lpFormatString,…)函数会带来重入和性能问题，不能在ISR中采用。</span></span><br><span class="line"><span class="comment">这个函数有太多的错误了，以至让人不知从何说起了（前提是**非操作系统**下的中断服务函数）：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**1)ISR 不能返回一个值（都应该为void类型）。如果你不懂这个，那么你不会被雇用的。**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**2)ISR 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3)在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额外的寄存器入栈，有些处理器/编译器就是不允许在ISR中做浮点运算。此外，ISR应该是**短而有效率**的，在ISR中做浮点运算是不明智的。另外中断服务程序是运行在内核态的（linux），**内核通常是不支持浮点运算的**。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="七、位运算符"><a href="#七、位运算符" class="headerlink" title="七、位运算符"></a>七、位运算符</h3><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5=&gt;0101，7=&gt;0111</span></span><br><span class="line"><span class="number">1</span>)&amp; 按位与<span class="comment">//5&amp;7==&gt;0101，也就是5</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>)| 按位或<span class="comment">//5|7==&gt;0111，也就是7</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>)^ 按位异或<span class="comment">//5^7==&gt;0010，也就是2</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>)~ 按位取反</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>)&lt;&lt;  左移</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>)&gt;&gt; 右移 </span><br></pre></td></tr></table></figure><h3 id="八、register-关键词"><a href="#八、register-关键词" class="headerlink" title="八、register 关键词"></a>八、register 关键词</h3><hr><p><strong>寄存器存在于CPU内部，运算速度非常快， 因为内存中的数据必须载入寄存器才能计算。如果直接定义一个变量为寄存器变量，则少了载入等过程自然会快。对于频繁使用的变量可以把它放在寄存器中来提速度。</strong><br>1.寄存器变量可以用来优化加速c语言程序<br>2.声名只需在类型前多加register 即可，eg   register int quick; （quick 就是一个整形的寄存器变量）<br>3.register只是一个建议型关键字，能不能声名成功还取决于编译器（建议型的关键字还有c++中的 inline），若不幸没有请求成功，则变量变成一个普通的自动变量。<br>4.是无法对一个register变量取地址的（因为寄存器变量多放在寄存器而非内存中，内存有地址，而寄存器是无地址的）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量最好不要占用寄存器，会影响程序的速度</span></span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> num = <span class="number">1000</span>;<span class="comment">//err</span></span><br><span class="line"><span class="comment">//只有局部自动变量和形参才可以定义为寄存器变量。因为寄存器变量属于动态存储方式，凡需要采用静态存储方式的量都不能定义为寄存器变量，包括：模块间全局变量、模块内全局变量、局部static变量。 </span></span><br><span class="line"><span class="comment">//静态变量无法定义为寄存器变量,静态变量存在静态区</span></span><br><span class="line"><span class="keyword">register</span> <span class="keyword">static</span> <span class="keyword">double</span>  res = <span class="number">0.0</span>;<span class="comment">//err</span></span><br></pre></td></tr></table></figure><h3 id="九、volatile-关键词"><a href="#九、volatile-关键词" class="headerlink" title="九、volatile 关键词"></a>九、volatile 关键词</h3><hr><p>volatile的作用是告知编译器，它修饰的变量随时都可能被改变，因此，编译后的程序每次在使用该变量的值时，都会从变量的地址中读取数据，而不是从寄存器中获取。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*volatile的本意是“易变的”</span></span><br><span class="line"><span class="comment">由于访问寄存器的速度要快过RAM，所以编译器一般都会作减少存取外部RAM的优化。比如：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i) do_something();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Interrupt service routine. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ISR_2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">i=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*程序的本意是希望ISR_2中断产生时，在main当中调用do_something函数，但是，由于编译器判断在main函数里面没有修改过i，因此可能只执行一次对从i到某寄存器的读操作，然后每次if判断都只使用这个寄存器里面的“i副本”，导致do_something永远也不会被调用。如果变量加上volatile修饰，则编译器保证对此变量的读写操作都不会被优化（肯定执行）。此例中i也应该如此说明。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>  <strong>一般说来，volatile用在如下的几个地方：</strong><br><strong>1、中断服务程序中修改的供其它程序检测的变量需要加volatile；</strong><br><strong>2、多任务环境下各任务间共享的标志应该加volatile；</strong><br><strong>3、存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；</strong><br><strong>另外，以上这几种情况经常还要同时考虑数据的完整性（相互关联的几个标志读了一半被打断了重写），在1中可以通过关中断来实现，2中可以禁止任务调度，3中则只能依靠硬件的良好设计了。</strong></p><h3 id="十、C-库函数-memset"><a href="#十、C-库函数-memset" class="headerlink" title="十、C 库函数 - memset()"></a>十、C 库函数 - memset()</h3><hr><p>C 库函数 void *memset(void *str, int c, size_t n) 复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *str, <span class="keyword">int</span> c, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"><span class="comment">//str -- 指向要填充的内存块。</span></span></span><br><span class="line"><span class="function"><span class="comment">//c -- 要被设置的值。该值以 int 形式传递，但是函数在填充内存块时是使用该值的无符号字符形式。</span></span></span><br><span class="line"><span class="function"><span class="comment">//n -- 要被设置为该值的字符数。</span></span></span><br><span class="line"><span class="function"><span class="comment">//该值返回一个指向存储区 str 的指针。</span></span></span><br></pre></td></tr></table></figure><h3 id="十一、排序算法"><a href="#十一、排序算法" class="headerlink" title="十一、排序算法"></a>十一、排序算法</h3><hr><p>冒泡排序：基本思想：比较相邻的两个数，如果前者比后者大，则进行交换。每一轮排序结束，选出一个未排序中最大的数放到数组后面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//冒泡排序算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n - <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果前面的数比后面大，进行交换</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j]; arr[j] = arr[j + <span class="number">1</span>]; arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123; <span class="number">10</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    bubbleSort(arr, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后的数组为：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><hr><p>参考文章：<a href="https://www.cnblogs.com/maluning/p/7944809.html">七大经典排序算法总结(C语言描述)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简介： 嵌入式笔试相关题目、考点。&lt;br&gt;&lt;img src=&quot;https://w.wallhaven.cc/full/5w/wallhaven-5wr6y9.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="知识" scheme="https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="C++" scheme="https://kelecn.top/tags/C/"/>
    
    <category term="编程" scheme="https://kelecn.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="嵌入式" scheme="https://kelecn.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="C" scheme="https://kelecn.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>精简代码：改换运算符</title>
    <link href="https://kelecn.top/2020/08/22/15%E3%80%81%E7%B2%BE%E7%AE%80%E4%BB%A3%E7%A0%81%EF%BC%9A%E6%94%B9%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>https://kelecn.top/2020/08/22/15%E3%80%81%E7%B2%BE%E7%AE%80%E4%BB%A3%E7%A0%81%EF%BC%9A%E6%94%B9%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6/</id>
    <published>2020-08-22T13:57:00.000Z</published>
    <updated>2020-10-15T01:12:28.929Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简介： 精简代码：改换运算符<br><img src="https://w.wallhaven.cc/full/48/wallhaven-48o3ky.jpg"></p><a id="more"></a><h5 id="1、位运算（-amp-）替换取余（-）运算"><a href="#1、位运算（-amp-）替换取余（-）运算" class="headerlink" title="1、位运算（&amp;）替换取余（%）运算"></a>1、位运算（&amp;）替换取余（%）运算</h5><p><strong>即：如果Y =<img src="https://private.codecogs.com/gif.latex?2%5E%7Bn%7D" alt="2^{n}">,则X%Y可以变化为X&amp;(Y-1)</strong><br>由于我们知道位运算比较高效，在某些情况下，当b为2的n次方时，有如下替换公式：<br>a % b = a &amp; (b-1)(b=2^n)<br>即：a % 2^n = a &amp; (2^n-1)<br>例如：14%8，取余数，相当于取出低位，而余数最大为7，14二进制为1110，8的二进制1000，8-1 = 7的二进制为0111，由于现在低位全为1，让其跟14做&amp;运算，正好取出的是其低位上的余数。1110&amp;0111=110即6=14%8；（此公式只适用b=2^n，是因为可以保证b始终只有最高位为1，其他二进制位全部为0，减去1，之后，可以把高位1消除，其他位都为1，而与1做&amp;运算，会保留原来的数。）</p><h5 id="2、左移运算（-lt-lt-）替换乘法（-）运算"><a href="#2、左移运算（-lt-lt-）替换乘法（-）运算" class="headerlink" title="2、左移运算（&lt;&lt;）替换乘法（*）运算"></a>2、左移运算（&lt;&lt;）替换乘法（*）运算</h5><p>a=a8;<br>b=b/8;<br><strong>可以改为：</strong><br>a=a&lt;&lt;3;<br>b=b&gt;&gt;3;<br><strong>说明：</strong><br>除2 = 右移1位； 乘2 = 左移1位<br>除4 = 右移2位； 乘4 = 左移2位<br>除8 = 右移3位； 乘8 = 左移3位<br><strong>通常如果需要乘以或除以2的n次方，都可以用移位的方法代替，大部分的C编译器,用移位的方法得到代码比调用乘除法子程序生成的代码效率高。</strong><br><strong>实际上，只要是乘以或除以一个整数才可以用移位的方法得到结果。</strong><br>如：<br>a=a9 =a(8+1)=a8+a1<br><strong>可以改为：</strong><br>a=(a&lt;&lt;3)+a<br>如：<br>a=a7 =a(8-1)=a8-a1<br><strong>可以改为：</strong><br>a=(a&lt;&lt;3)-a</p><p><strong>总结：a=an; n分解成(2^m + s),则a=an可以改为a=(a&lt;&lt;m)+as;as再同理分解替换。</strong></p><p>例：a=a10 =&gt; a=a(8+2) =&gt; a=a8 + a2 =&gt; a=(a&lt;&lt;3)+(a&lt;&lt;1)</p><h5 id="3、右移运算（-gt-gt-）替换除法（-）运算"><a href="#3、右移运算（-gt-gt-）替换除法（-）运算" class="headerlink" title="3、右移运算（&gt;&gt;）替换除法（/）运算"></a>3、右移运算（&gt;&gt;）替换除法（/）运算</h5><p>a=a*8;<br>b=b/8;<br><strong>可以改为：</strong><br>a=a&lt;&lt;3;<br>b=b&gt;&gt;3;<br><strong>说明：</strong><br>除2 = 右移1位； 乘2 = 左移1位<br>除4 = 右移2位； 乘4 = 左移2位<br>除8 = 右移3位； 乘8 = 左移3位<br><strong>通常如果需要乘以或除以2的n次方，都可以用移位的方法代替，大部分的C编译器,用移位的方法得到代码比调用乘除法子程序生成的代码效率高。</strong><br><strong>实际上，只要是乘以或除以一个整数才可以用移位的方法得到结果。</strong><br>如：<br>a=a/9 =a/(8+1)=a/8+a/1<br><strong>可以改为：</strong><br>a=(a&gt;&gt;3)+a<br>如：<br>a=a/7 =a/(8-1)=a/8-a/1<br><strong>可以改为：</strong><br>a=(a&gt;&gt;3)-a<br><strong>总结：a=a/n; n分解成(2^m + s),则a=a/n可以改为a=(a&gt;&gt;m)+a/s;a/s再同理分解替换。</strong><br>例：a=a/10 =&gt; a=a/(8+2) =&gt; a=a/8 + a/2 =&gt; a=(a&gt;&gt;3)+(a&gt;&gt;1)</p><h5 id="4、C-C-中的移位操作容易出错的情况："><a href="#4、C-C-中的移位操作容易出错的情况：" class="headerlink" title="4、C/C++中的移位操作容易出错的情况："></a>4、C/C++中的移位操作容易出错的情况：</h5><ul><li><strong>什么样的数据类型可以直接移位</strong><br> 只有整型数据才能用移位替代乘除法，如：char、short、int、long、unsigned char、unsigned short、unsigned int、unsigned long。（double、float、bool、long double则不可以进行移位操作。）</li><li><strong>有符号数据类型移位需要注意符号位</strong><br>对于char、short、int、long这些有符号的数据类型：<br>对负数进行左移：符号位始终为1，其他位左移。<br>对正数进行左移：所有位左移，即 &lt;&lt;，可能会变成负数<br>对负数进行右移：取绝对值，然后右移，再取相反数<br>对正数进行右移：所有位右移，即 &gt;&gt;</li><li><strong>无符号数据类型的移位操作</strong><br>对于unsigned char、unsigned short、unsigned int、unsigned long这些无符号数据类型：<br>没有特殊要说明的，使用&lt;&lt; 和 &gt;&gt; 操作符就OK了。<h5 id="5、参考资料："><a href="#5、参考资料：" class="headerlink" title="5、参考资料："></a>5、参考资料：</h5></li><li><a href="https://blog.csdn.net/LZAlgorithm/article/details/101348934">使用位运算替换取余操作</a></li><li><a href="https://blog.csdn.net/qq_34473360/article/details/90547684">移位操作与乘除法的关系</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;简介： 精简代码：改换运算符&lt;br&gt;&lt;img src=&quot;https://w.wallhaven.cc/full/48/wallhaven-48o3ky.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="知识" scheme="https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="C++" scheme="https://kelecn.top/tags/C/"/>
    
    <category term="ARM" scheme="https://kelecn.top/tags/ARM/"/>
    
    <category term="嵌入式" scheme="https://kelecn.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="C" scheme="https://kelecn.top/tags/C/"/>
    
    <category term="单片机" scheme="https://kelecn.top/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>基于PicGo的GitHub图床</title>
    <link href="https://kelecn.top/2020/08/18/14%E3%80%81%E6%88%91%E7%9A%84GitHub%E5%9B%BE%E5%BA%8A%EF%BC%88%E5%9F%BA%E4%BA%8EPicGo%EF%BC%89/"/>
    <id>https://kelecn.top/2020/08/18/14%E3%80%81%E6%88%91%E7%9A%84GitHub%E5%9B%BE%E5%BA%8A%EF%BC%88%E5%9F%BA%E4%BA%8EPicGo%EF%BC%89/</id>
    <published>2020-08-18T13:57:00.000Z</published>
    <updated>2020-10-12T03:38:07.223Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简介：GitHub图床（基于PicGo）</p><p><img src="https://w.wallhaven.cc/full/2e/wallhaven-2ekjlm.png"></p><a id="more"></a><h1 id="GitHub图床（基于PicGo）"><a href="#GitHub图床（基于PicGo）" class="headerlink" title="GitHub图床（基于PicGo）"></a>GitHub图床（基于PicGo）</h1><h5 id="1-首先你得有一个GitHub账号。注册GitHub就不用我多言。"><a href="#1-首先你得有一个GitHub账号。注册GitHub就不用我多言。" class="headerlink" title="1. 首先你得有一个GitHub账号。注册GitHub就不用我多言。"></a><strong>1.</strong> 首先你得有一个GitHub账号。注册GitHub就不用我多言。</h5><h5 id="2-新建一个仓库"><a href="#2-新建一个仓库" class="headerlink" title="2. 新建一个仓库"></a><strong>2.</strong> 新建一个仓库</h5><p><img src="https://i.loli.net/2020/10/11/TsLZEyarxYoVhpj.png"></p><p>记下你取的仓库名。</p><h5 id="3-生成一个token用于PicGo操作你的仓库："><a href="#3-生成一个token用于PicGo操作你的仓库：" class="headerlink" title="3. 生成一个token用于PicGo操作你的仓库："></a><strong>3.</strong> 生成一个token用于PicGo操作你的仓库：</h5><p>访问：<a href="https://github.com/settings/tokens">https://github.com/settings/tokens</a></p><p>然后点击<code>Generate new token</code>。</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/generate_new_token.png"></p><p>把repo的勾打上即可。然后翻到页面最底部，点击<code>Generate token</code>的绿色按钮生成token。</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/20180508210435.png"></p><p><strong>注意：</strong>这个token生成后只会显示一次！你要把这个token复制一下存到其他地方以备以后要用。</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/copy_token.png"></p><h5 id="4-配置PicGo"><a href="#4-配置PicGo" class="headerlink" title="4. 配置PicGo"></a><strong>4.</strong> 配置PicGo</h5><p><strong>注意：</strong>仓库名的格式是<code>用户名/仓库</code>，比如我创建了一个叫做<code>test</code>的仓库，在PicGo里我要设定的仓库名就是<code>kelecn/images</code>。一般我们选择<code>master</code>分支即可。然后记得点击确定以生效，然后可以点击<code>设为默认图床</code>来确保上传的图床是GitHub。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PicGo配置</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;repo&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="comment">// 仓库名，格式是username/reponame</span></span><br><span class="line">  <span class="attr">&quot;token&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="comment">// github token</span></span><br><span class="line">  <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="comment">// 自定义存储路径，比如img/</span></span><br><span class="line">  <span class="attr">&quot;customUrl&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="comment">// 自定义域名，注意要加http://或者https://</span></span><br><span class="line">  <span class="attr">&quot;branch&quot;</span>: <span class="string">&quot;&quot;</span> <span class="comment">// 分支名，默认是master</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/11/MVezNlYvZGSXuId.png"></p><p>至此配置完毕，已经可以使用了。当你上传的时候，你会发现你的仓库里也会增加新的图片了：</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/success.png"></p><p>更多图床设计：请参考<a href="https://picgo.github.io/PicGo-Doc/zh/guide/">PicGo官方手册</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简介：GitHub图床（基于PicGo）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://w.wallhaven.cc/full/2e/wallhaven-2ekjlm.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://kelecn.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Hexo" scheme="https://kelecn.top/tags/Hexo/"/>
    
    <category term="相册" scheme="https://kelecn.top/tags/%E7%9B%B8%E5%86%8C/"/>
    
    <category term="图床" scheme="https://kelecn.top/tags/%E5%9B%BE%E5%BA%8A/"/>
    
    <category term="Github" scheme="https://kelecn.top/tags/Github/"/>
    
    <category term="PicGo" scheme="https://kelecn.top/tags/PicGo/"/>
    
  </entry>
  
  <entry>
    <title>ARM处理器7种工作模式</title>
    <link href="https://kelecn.top/2020/06/11/12%E3%80%81ARM%E5%A4%84%E7%90%86%E5%99%A87%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/"/>
    <id>https://kelecn.top/2020/06/11/12%E3%80%81ARM%E5%A4%84%E7%90%86%E5%99%A87%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-11T13:47:00.000Z</published>
    <updated>2020-10-12T03:37:46.978Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简介：ARM处理器7种工作模式（特权模式，异常模式，用户模式）。</p><p><img src="https://w.wallhaven.cc/full/2k/wallhaven-2kd28x.jpg"></p><a id="more"></a><h3 id="ARM处理器7种工作模式（特权模式，异常模式，用户模式）"><a href="#ARM处理器7种工作模式（特权模式，异常模式，用户模式）" class="headerlink" title="ARM处理器7种工作模式（特权模式，异常模式，用户模式）"></a>ARM处理器7种工作模式（特权模式，异常模式，用户模式）</h3><p><strong>用户模式（USR）：</strong>正常程序执行模式，不能直接切换到其他模式<br><strong>系统模式（SYS）：</strong>运行操作系统的特权任务，与用户模式类似，但具有可以直接切换到其他模式等特权<br><strong>快中断模式（FIQ）：</strong>支持高速数据传输及通道处理，FIQ异常响应时进入此模式<br><strong>中断模式（IRQ）：</strong>用于通用中断处理，IRQ异常响应时进入此模式<br><strong>管理模式（SVC）：</strong>操作系统保护模式，系统复位和软件中断响应时进入此模式（由系统调用执行软中断SWI命令触发）<br><strong>中止模式（ABT）：</strong>用于支持虚拟内存和/或存储器保护，在ARM7TDMI没有大用处<br><strong>未定义模式（UND）：</strong>支持硬件协处理器的软件仿真，未定义指令异常响应时进入此模式 </p><p><strong>7种工作模式分类：</strong></p><ul><li><p>除用户模式外，其余6种工作模式都属于特权模式</p></li><li><p>特权模式中除了系统模式以外的其余5种模式称为异常模式</p></li><li><p>大多数程序运行于用户模式</p></li><li><p>进入特权模式是为了处理中断、异常、或者访问被保护的系统资源</p></li></ul><p><strong>硬件权限级别：</strong>系统模式 &gt; 异常模式 &gt; 用户模式<br><strong>快中断与慢中断区别：</strong>快中断处理时禁止中断</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简介：ARM处理器7种工作模式（特权模式，异常模式，用户模式）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://w.wallhaven.cc/full/2k/wallhaven-2kd28x.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="知识" scheme="https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="ARM" scheme="https://kelecn.top/tags/ARM/"/>
    
    <category term="嵌入式" scheme="https://kelecn.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="处理器" scheme="https://kelecn.top/tags/%E5%A4%84%E7%90%86%E5%99%A8/"/>
    
    <category term="硬件" scheme="https://kelecn.top/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>测试相册功能</title>
    <link href="https://kelecn.top/2020/06/09/13%E3%80%81%E7%9B%B8%E5%86%8C%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    <id>https://kelecn.top/2020/06/09/13%E3%80%81%E7%9B%B8%E5%86%8C%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/</id>
    <published>2020-06-09T13:57:00.000Z</published>
    <updated>2020-10-20T12:45:39.992Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p class='p center logo large red'>相</p><p class='p center logo large blue'>册</p><div class="tabs" id="tab-id"><ul class="nav-tabs"><li class="tab active"><a href="#tab-id-1">壁纸</a></li><li class="tab"><a href="#tab-id-2">二次元</a></li><li class="tab"><a href="#tab-id-3">日常</a></li><li class="tab"><a href="#tab-id-4">旅游</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tab-id-1"><div class="gallery stretch" col='4'>              <p><img src="https://cdn.jsdelivr.net/gh/kelecn/images/001.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/002.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/003.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/004.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/005.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/006.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/007.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/008.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/009.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/010.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/011.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/012.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/013.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/014.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/015.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/016.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/017.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/018.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/019.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/020.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/021.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/022.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/023.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/024.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/025.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/026.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/027.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/028.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/029.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/030.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/031.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/032.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/033.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/034.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/035.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/036.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/037.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/038.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/039.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/040.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/041.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/042.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/043.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/044.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/045.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/046.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/047.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/048.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/049.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/050.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/051.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/052.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/053.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/054.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/055.jpg"><br><img src="https://cdn.jsdelivr.net/gh/kelecn/images/056.jpg"></p>            </div></div><div class="tab-pane" id="tab-id-2"><div class="gallery stretch" col='4'>              <p><img src="https://w.wallhaven.cc/full/4g/wallhaven-4g789d.png"><br><img src="https://w.wallhaven.cc/full/70/wallhaven-70pz34.jpg"><br><img src="https://w.wallhaven.cc/full/0q/wallhaven-0q2637.jpg"><br><img src="https://w.wallhaven.cc/full/5w/wallhaven-5wr6y9.jpg"><br><img src="https://w.wallhaven.cc/full/nz/wallhaven-nz8mqw.png"><br><img src="https://w.wallhaven.cc/full/1j/wallhaven-1j292g.png"><br><img src="https://w.wallhaven.cc/full/43/wallhaven-43zow3.jpg"><br><img src="https://w.wallhaven.cc/full/8x/wallhaven-8x67go.jpg"></p>            </div></div><div class="tab-pane" id="tab-id-3"><div class="gallery ">              <p><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/B18FCBB3-67FD-48CC-B4F3-457BA145F17A.jpeg" alt="图片描述"><br><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/67239FBB-E15D-4F4F-8EE8-0F1C9F3C4E7C.jpeg" alt="图片描述"><br><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/00E0F0ED-9F1C-407A-9AA6-545649D919F4.jpeg" alt="图片描述"></p>            </div></div><div class="tab-pane" id="tab-id-4"><div class="gallery ">              <p><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg" alt="图片描述"></p>            </div></div></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="日记" scheme="https://kelecn.top/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="Hexo" scheme="https://kelecn.top/tags/Hexo/"/>
    
    <category term="相册" scheme="https://kelecn.top/tags/%E7%9B%B8%E5%86%8C/"/>
    
    <category term="Kelecn" scheme="https://kelecn.top/tags/Kelecn/"/>
    
  </entry>
  
  <entry>
    <title>C++与Java多态的区别</title>
    <link href="https://kelecn.top/2020/06/06/11%E3%80%81C++%E4%B8%8EJava%E5%A4%9A%E6%80%81%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://kelecn.top/2020/06/06/11%E3%80%81C++%E4%B8%8EJava%E5%A4%9A%E6%80%81%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-06-06T13:40:00.000Z</published>
    <updated>2020-10-03T07:49:41.989Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简介：C++与Java多态的区别。</p><p><img src="https://w.wallhaven.cc/full/6k/wallhaven-6k35rl.jpg"></p><a id="more"></a><h3 id="多态是指用父指针指向不同子类对象时，调用其共有的函数，不同的子类会有不同的行为。虽然C-和Java都具有多态机制，但是他们的实现不同，使用时的效果也会略有不同。"><a href="#多态是指用父指针指向不同子类对象时，调用其共有的函数，不同的子类会有不同的行为。虽然C-和Java都具有多态机制，但是他们的实现不同，使用时的效果也会略有不同。" class="headerlink" title="多态是指用父指针指向不同子类对象时，调用其共有的函数，不同的子类会有不同的行为。虽然C++和Java都具有多态机制，但是他们的实现不同，使用时的效果也会略有不同。"></a>多态是指用父指针指向不同子类对象时，调用其共有的函数，不同的子类会有不同的行为。虽然C++和Java都具有多态机制，但是他们的实现不同，使用时的效果也会略有不同。</h3><h4 id="在C-中"><a href="#在C-中" class="headerlink" title="在C++中"></a>在C++中</h4><ul><li>普通函数调用：具体调用哪个方法在编译时就可以决定(通过查找编译器的符号表)，同时在使用标准过程调用机制基础上增加一个表示对象身份的指针(this指针)。</li><li>虚函数调用：函数调用依赖于对象的实际类型，一般地说，对象的实际类型只能在运行时间才能确定。实现机制是使用virtual table(vtbls)和virtual table pointers(vptrs)。<ol><li>vtbl 是由函数指针构成的数组或链表，程序中每一个class凡声明(或继承)虚函数者，都有一个自己的vtbl，其中的条目就是该class的各个虚函数实现的指针。因此必须为每一个class消耗一个vtbl空间，其大小视虚函数的个数确定。</li><li>凡声明有虚函数的class，其对象都有一个隐藏的data member，用来指向class的vtbl。</li><li>当多态发生时，编译器首先根据对象vptr找出其vtbl，然后找出vtbl内对应的函数指针，最后调用函数指针指向的函数。从而实现多态。</li></ol></li></ul><h4 id="在Java中"><a href="#在Java中" class="headerlink" title="在Java中"></a>在Java中</h4><p>1.C++中VTable和vptr是在编译阶段由编译器自动生成的，也就是说，在C++程序载入内存以前，在.obj（.o）文件中已经有这些结构的信 息；Java中的方法表是由JVM生成的，因此，使用javac命令编译后生成的.class文件中并没有方法表的信息。只有等JVM把.class文件 载入到内存中时，才会为该.class文件动态生成一个与之关联的方法表，放置在JVM的方法区中。</p><p>2.C++中某个方法在VTable的索引号是在编译阶段已经明确知道的，并不需要在运行过程中动态获知；Java中的方法初始时都只是一个符号，并不是 一个明确的地址，只有等到该方法被第一次调用时，才会被解析成一个方法表中的偏移量，也就是说，只有在这个时候，实例方法才明确知道自己在方发表中的偏移 量了，在这之前必须经历一个解析的过程。</p><p>因此在构造函数是Java会发生多态，即使子类此时还没有构造完全（一个极难发现的bug）。而C++则不会发生多态，待父类构造完全，在构造子类。<br><strong>Java代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.fun();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            fun();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] argv)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            B b = <span class="keyword">new</span> B();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//B</span></span><br><span class="line"><span class="comment">//B</span></span><br></pre></td></tr></table></figure><p><strong>C++代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;A&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        A()</span><br><span class="line">        &#123;</span><br><span class="line">            fun();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;B&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        B()</span><br><span class="line">    &#123;</span><br><span class="line">        fun();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//A</span></span><br><span class="line"><span class="comment">//B</span></span><br></pre></td></tr></table></figure><p>可以发现，C++构造子类时，先构造父类，输出A，然后在构造自身，输出B。而Java在构造子类时，父类并未构造完成，但已经可以发生多态输出B，然后再构造自身，输出B。Java一般为了避免这种情况，会把fun等init()函数声明为private或者finial。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简介：C++与Java多态的区别。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://w.wallhaven.cc/full/6k/wallhaven-6k35rl.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="知识" scheme="https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="面向对象" scheme="https://kelecn.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    <category term="C++" scheme="https://kelecn.top/tags/C/"/>
    
    <category term="代码" scheme="https://kelecn.top/tags/%E4%BB%A3%E7%A0%81/"/>
    
    <category term="编程" scheme="https://kelecn.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Java" scheme="https://kelecn.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>C++重载注意点</title>
    <link href="https://kelecn.top/2020/05/20/10%E3%80%81%E9%87%8D%E8%BD%BD%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
    <id>https://kelecn.top/2020/05/20/10%E3%80%81%E9%87%8D%E8%BD%BD%E6%B3%A8%E6%84%8F%E7%82%B9/</id>
    <published>2020-05-20T13:30:00.000Z</published>
    <updated>2020-10-12T03:37:34.274Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简介：C++重载注意点。</p><p><img src="https://w.wallhaven.cc/full/g8/wallhaven-g8e98d.png"></p><a id="more"></a><h4 id="1-调用函数在前，定义函数在后，进行原型声明"><a href="#1-调用函数在前，定义函数在后，进行原型声明" class="headerlink" title="1.调用函数在前，定义函数在后，进行原型声明"></a>1.调用函数在前，定义函数在后，进行原型声明</h4><h4 id="2-函数重载注意：参数类型和个数相同，参数顺序不同，也可以重载"><a href="#2-函数重载注意：参数类型和个数相同，参数顺序不同，也可以重载" class="headerlink" title="2.函数重载注意：参数类型和个数相同，参数顺序不同，也可以重载"></a>2.函数重载注意：参数类型和个数相同，参数顺序不同，也可以重载</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">double</span> b)</span></span>;<span class="comment">//调用函数在前，定义函数在后，进行原型声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(<span class="keyword">double</span> b,<span class="keyword">int</span> a)</span></span>;<span class="comment">//调用函数在前，定义函数在后，进行原型声明</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">8</span>;</span><br><span class="line">    <span class="keyword">double</span> y=<span class="number">8</span>;</span><br><span class="line">    print(x,y);</span><br><span class="line">    print(y,x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;showpoint&lt;&lt;<span class="string">&quot;1&quot;</span>&lt;&lt;a&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(<span class="keyword">double</span> b,<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;showpoint&lt;&lt;<span class="string">&quot;2&quot;</span>&lt;&lt; a&lt;&lt;b &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="3-C-中cout输出字符型指针地址值的方法"><a href="#3-C-中cout输出字符型指针地址值的方法" class="headerlink" title="3.C++中cout输出字符型指针地址值的方法"></a>3.C++中cout输出字符型指针地址值的方法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++中cout输出字符型指针地址值的方法</span></span><br><span class="line"><span class="comment">//若要打印地址请用void*，否则 p会被认为是字符串。原因：运算符重载的匹配规则</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">char</span> a;</span><br><span class="line">     <span class="keyword">char</span> *p=&amp;a;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;(<span class="keyword">void</span>*)p&lt;&lt;<span class="built_in">endl</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;简介：C++重载注意点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://w.wallhaven.cc/full/g8/wallhaven-g8e98d.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="知识" scheme="https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="面向对象" scheme="https://kelecn.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    <category term="C++" scheme="https://kelecn.top/tags/C/"/>
    
    <category term="代码" scheme="https://kelecn.top/tags/%E4%BB%A3%E7%A0%81/"/>
    
    <category term="编程" scheme="https://kelecn.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++返回对象和返回引用</title>
    <link href="https://kelecn.top/2020/04/19/9%E3%80%81C++%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%BF%94%E5%9B%9E%E5%BC%95%E7%94%A8/"/>
    <id>https://kelecn.top/2020/04/19/9%E3%80%81C++%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%BF%94%E5%9B%9E%E5%BC%95%E7%94%A8/</id>
    <published>2020-04-19T13:20:07.000Z</published>
    <updated>2020-10-15T17:45:32.781Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简介：C++返回对象和返回引用。</p><p><img src="https://w.wallhaven.cc/full/ym/wallhaven-ym181g.jpg"></p><a id="more"></a><p>我们发现，在C++中，有些成员函数返回的是对象，而有些函数返回的又是引用。</p><p>返回对象和返回引用的最主要的区别就是函数原型和函数头。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Car <span class="title">run</span><span class="params">(<span class="keyword">const</span> Car &amp;)</span>   <span class="comment">//返回对象</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Car &amp; <span class="title">run</span><span class="params">(<span class="keyword">const</span> Car &amp;)</span>  <span class="comment">//返回引用</span></span></span><br></pre></td></tr></table></figure><p>​        返回对象会涉及到生成返回对象的副本。因此，返回对象的时间成本包括了调用复制构造函数来生成副本所需的时间和调用析构函数删除副本所需的时间。返回引用可以节省时间和内存。直接返回对象与按值传递对象类似，他们都生成临时副本。同样，返回引用与按引用传递对象类似，调用和被调用的函数对同一个对象进行操作。</p><p>​        并不是总是可以返回引用的。比如函数不能返回在函数中创建的临时对象的引用。因为当函数结束调用时，临时对象将消失，因此这种引用是非法的。在这种情况下，应返回对象，以生成一个调用程序可以使用的副本。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简介：C++返回对象和返回引用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://w.wallhaven.cc/full/ym/wallhaven-ym181g.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="知识" scheme="https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="面向对象" scheme="https://kelecn.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    <category term="C++" scheme="https://kelecn.top/tags/C/"/>
    
    <category term="代码" scheme="https://kelecn.top/tags/%E4%BB%A3%E7%A0%81/"/>
    
    <category term="编程" scheme="https://kelecn.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="嵌入式" scheme="https://kelecn.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>关于free和delete的使用</title>
    <link href="https://kelecn.top/2020/03/29/8%E3%80%81%E5%85%B3%E4%BA%8Efree%E5%92%8Cdelete%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://kelecn.top/2020/03/29/8%E3%80%81%E5%85%B3%E4%BA%8Efree%E5%92%8Cdelete%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2020-03-29T13:10:00.000Z</published>
    <updated>2020-10-15T17:45:21.311Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简介：关于free和delete的使用</p><p><img src="https://w.wallhaven.cc/full/dg/wallhaven-dgy8gg.jpg"></p><a id="more"></a><p>两个同时存在是有它的原因的，free是函数，它只释放内存，但不会调用析构函数，如果用free去释放new申请的空间，会因为无法调用析构函数而出现不必要的错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *point = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="number">100</span>);  </span><br><span class="line"><span class="built_in">strcpy</span>(point, “hello”);  </span><br><span class="line"><span class="built_in">free</span>(point); <span class="comment">// Be careful here，point 所指的内存被释放，but point 所指的地址仍然不变  </span></span><br><span class="line">…  </span><br><span class="line"><span class="keyword">if</span>(point != <span class="literal">NULL</span>) <span class="comment">// 没有起到防错作用  </span></span><br><span class="line">&#123;  </span><br><span class="line"><span class="built_in">strcpy</span>(point, “jackery”); <span class="comment">// error  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段程序中，原来free和delete只是把指针所指的内存给释放掉，<strong>但并没有把指针本身干掉</strong>。指针point被free以后其地址仍然不变（非NULL），只是该地址对应的内存是垃圾，point成了“野指针”。如果此时不把point设置为NULL，会让人误以为point是个合法的指针。如果程序比较长，我们有时记不住 point 所指的内存是否已经被释放，在继续使用point 之前，通常会用语句if (p != NULL)进行防错处理。很遗憾，此时if语句起不到防错作用，因为即便point不是NULL指针，它也不指向合法的内存块。<strong>为了避免失误，最好在free之后或者之前，将指针指向NULL</strong></p><h4 id="new-delete-与-malloc-free-区别"><a href="#new-delete-与-malloc-free-区别" class="headerlink" title="new()/delete()与 malloc()/free() 区别"></a>new()/delete()与 malloc()/free() 区别</h4><p>1.malloc()/free() 是标准库函数， 使用前需调用库头文件 &lt;stdlib.h&gt; 方可使用；而 new/delete 是运算       符，执行效率更高。</p><p>2.malloc() 需要手工计算字节数；而 new 能够自动计算需要分配的内存空间。</p><p>3.malloc() 返回的指针是 void 类型；而 new*返回的指针是它分配空间的类型。</p><p>4.new 时调用构造函数，而 malloc() 不能；delete 时调用析构函数，而 free() 不能。</p><p>5.new 在申请单个类型变量时可以赋初值，而 malloc() 不具备。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简介：关于free和delete的使用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://w.wallhaven.cc/full/dg/wallhaven-dgy8gg.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="知识" scheme="https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="面向对象" scheme="https://kelecn.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    <category term="C++" scheme="https://kelecn.top/tags/C/"/>
    
    <category term="代码" scheme="https://kelecn.top/tags/%E4%BB%A3%E7%A0%81/"/>
    
    <category term="编程" scheme="https://kelecn.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="嵌入式" scheme="https://kelecn.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>常量指针与指针常量</title>
    <link href="https://kelecn.top/2020/03/11/7%E3%80%81%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F/"/>
    <id>https://kelecn.top/2020/03/11/7%E3%80%81%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F/</id>
    <published>2020-03-11T13:07:00.000Z</published>
    <updated>2020-10-15T17:45:09.559Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简介：常量指针与指针常量的区别。</p><p><img src="https://w.wallhaven.cc/full/ym/wallhaven-ymoo2x.jpg"></p><a id="more"></a><h3 id="常量指针-被指向的对象是常量"><a href="#常量指针-被指向的对象是常量" class="headerlink" title="常量指针(被指向的对象是常量)"></a>常量指针(被指向的对象是常量)</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>又叫常指针，可以理解为<strong>常量的指针</strong>，指向的是个常量</p><h4 id="关键点："><a href="#关键点：" class="headerlink" title="关键点："></a>关键点：</h4><ol><li>常量指针指向的对象不能通过这个指针来修改，可是仍然可以通过原来的声明修改；</li><li>常量指针可以被赋值为变量的地址，之所以叫常量指针，是限制了通过这个指针修改变量的值；</li><li>指针还可以指向别处，因为指针本身只是个变量，可以指向任意地址；　</li></ol><h4 id="代码形式："><a href="#代码形式：" class="headerlink" title="代码形式："></a>代码形式：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>* p;  <span class="keyword">const</span> <span class="keyword">int</span>* p;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量指针(被指向的对象是常量)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> i2 = <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);<span class="comment">//10</span></span><br><span class="line">    i = <span class="number">9</span>; <span class="comment">//OK,仍然可以通过原来的声明修改值，</span></span><br><span class="line">    <span class="comment">//Error,*p是const int的，不可修改，即常量指针不可修改其指向地址</span></span><br><span class="line">    <span class="comment">//*p = 11;  //error: assignment of read-only location ‘*p’</span></span><br><span class="line">    p = &amp;i2;<span class="comment">//OK,指针还可以指向别处，因为指针只是个变量，可以随意指向；</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);<span class="comment">//11</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="指针常量-指针本身是常量"><a href="#指针常量-指针本身是常量" class="headerlink" title="指针常量(指针本身是常量)"></a>指针常量(指针本身是常量)</h3><h4 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h4><p>本质是一个常量，而用指针修饰它。指针常量的值是指针，这个值因为是常量，所以不能被赋值。</p><h4 id="关键点：-1"><a href="#关键点：-1" class="headerlink" title="关键点："></a>关键点：</h4><ol><li>它是个常量！</li><li>指针所保存的地址可以改变，然而指针所指向的值却不可以改变；</li><li>指针本身是常量，指向的地址不可以变化,但是指向的地址所对应的内容可以变化；</li></ol><h4 id="代码形式：-1"><a href="#代码形式：-1" class="headerlink" title="代码形式："></a>代码形式：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指针常量(指针本身是常量)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> *<span class="keyword">const</span> p = &amp;i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);<span class="comment">//10</span></span><br><span class="line">    <span class="comment">//Error,因为p是const 指针，因此不能改变p指向的内容</span></span><br><span class="line">    <span class="comment">//p++;//error: increment of read-only variable ‘p’</span></span><br><span class="line">    (*p)++;    <span class="comment">//OK,指针是常量，指向的地址不可以变化,但是指向的地址所对应的内容可以变化</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);<span class="comment">//11</span></span><br><span class="line">    i = <span class="number">9</span>;<span class="comment">//OK,仍然可以通过原来的声明修改值，</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何区分常量指针和指针常量"><a href="#如何区分常量指针和指针常量" class="headerlink" title="如何区分常量指针和指针常量"></a>如何区分常量指针和指针常量</h3><ul><li>一种方式是看 * 和 const 的排列顺序，比如</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>* p;<span class="comment">//const * 即常量指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p;<span class="comment">//const * 即常量指针</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p;<span class="comment">//* const 即指针常量</span></span><br></pre></td></tr></table></figure><ul><li>还一种方式是看const离谁近，即从右往左看，比如</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>* p;<span class="comment">//const修饰的是*p，即*p的内容不可通过p改变，但p不是const，p可以修改，*p不可修改；</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p;<span class="comment">//同上</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p;<span class="comment">//const修饰的是p，p是指针，p指向的地址不能修改，p不能修改，但*p可以修改；</span></span><br></pre></td></tr></table></figure><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">(struct stu * <span class="keyword">const</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//p = NULL; //err</span></span><br><span class="line">p-&gt;age = <span class="number">10</span>; <span class="comment">//ok</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//void fun2(struct stu const*  p)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">(<span class="keyword">const</span> struct stu *  p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p = <span class="literal">NULL</span>; <span class="comment">//ok</span></span><br><span class="line"><span class="comment">//p-&gt;age = 10; //err</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun3</span><span class="params">(<span class="keyword">const</span> struct stu * <span class="keyword">const</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//p = NULL; //err</span></span><br><span class="line"><span class="comment">//p-&gt;age = 10; //err</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;简介：常量指针与指针常量的区别。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://w.wallhaven.cc/full/ym/wallhaven-ymoo2x.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="知识" scheme="https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="面向对象" scheme="https://kelecn.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    <category term="C++" scheme="https://kelecn.top/tags/C/"/>
    
    <category term="代码" scheme="https://kelecn.top/tags/%E4%BB%A3%E7%A0%81/"/>
    
    <category term="编程" scheme="https://kelecn.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="嵌入式" scheme="https://kelecn.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>编程过程中遇到的一些问题总结（C++&amp;Java）</title>
    <link href="https://kelecn.top/2020/02/18/6%E3%80%81%E7%BC%96%E7%A8%8B%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88C++&amp;Java%EF%BC%89/"/>
    <id>https://kelecn.top/2020/02/18/6%E3%80%81%E7%BC%96%E7%A8%8B%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88C++&amp;Java%EF%BC%89/</id>
    <published>2020-02-18T02:05:00.000Z</published>
    <updated>2020-10-12T03:36:48.303Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简介：（C++&amp;Java）问题总结。</p><p><img src="https://w.wallhaven.cc/full/wy/wallhaven-wyw8wr.jpg"></p><a id="more"></a><p>1.Java中的boolean类型变量，只有两个值true ,false；C++也是，不过也可以用 1 0 代替。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java boolean 类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I Love YOU!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ boolean 类型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;I Love YOU!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.Java一个类中的boolean类型变量，一般用isXxx()类型获取私有变量Xxx；</p><p>注：get开头的方法，一般都表示返回某一个属性值；is开头的方法，一般都是用来表示判断某某内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;简介：（C++&amp;amp;Java）问题总结。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://w.wallhaven.cc/full/wy/wallhaven-wyw8wr.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="总结" scheme="https://kelecn.top/categories/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="面向对象" scheme="https://kelecn.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    <category term="C++" scheme="https://kelecn.top/tags/C/"/>
    
    <category term="编程" scheme="https://kelecn.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Java" scheme="https://kelecn.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JAVA测试题</title>
    <link href="https://kelecn.top/2020/02/07/5%E3%80%81JAVA%E6%B5%8B%E8%AF%95%E9%A2%98/"/>
    <id>https://kelecn.top/2020/02/07/5%E3%80%81JAVA%E6%B5%8B%E8%AF%95%E9%A2%98/</id>
    <published>2020-02-07T02:05:00.000Z</published>
    <updated>2020-10-12T03:36:37.841Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简介：JAVA基础测试题。</p><p><img src="https://w.wallhaven.cc/full/d5/wallhaven-d5kj6o.png"></p><a id="more"></a><h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><p>输出9*9口诀表。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> exam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i ++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line"> &#123;</span><br><span class="line"> System.out.print(i +<span class="string">&quot; * &quot;</span>+j+<span class="string">&quot; = &quot;</span>+i*j + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"> System.out.println();<span class="comment">//换行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行截图：</strong></p><p><img src="https://i.loli.net/2020/05/07/HJNRoVQylpuhk7U.png" alt="2020-05-07_102624.png"></p><h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><p>求1+2!+3!+…+20!的和。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> exam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="keyword">float</span> s=<span class="number">0</span>,t=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">for</span> (n=<span class="number">1</span>;n&lt;=<span class="number">20</span>;n++)</span><br><span class="line">  &#123;</span><br><span class="line">    t=t*n;      <span class="comment">// 求n!</span></span><br><span class="line">    s=s+t;      <span class="comment">// 将各项累加</span></span><br><span class="line">  &#125;</span><br><span class="line"> System.out.println(<span class="string">&quot;1+2!+3!+...+20!=&quot;</span>+s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行截图：</strong></p><p><img src="https://i.loli.net/2020/05/07/gqL64Yl3JrIUsxk.png" alt="2020-05-07_104101.png"></p><h2 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h2><p>一个5位数，判断它是不是回文数。即12321是回文数，个位与万位相同，十位与千位相同。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> exam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ge,shi,qian,wan,x;</span><br><span class="line">System.out.println(<span class="string">&quot;请输入您想判断的五位数字：&quot;</span>);</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        x=in.nextInt();</span><br><span class="line">        wan=x/<span class="number">10000</span>;<span class="comment">//万位</span></span><br><span class="line">        qian=x%<span class="number">10000</span>/<span class="number">1000</span>;<span class="comment">//千位</span></span><br><span class="line">        shi=x%<span class="number">100</span>/<span class="number">10</span>;<span class="comment">//十位</span></span><br><span class="line">        ge=x%<span class="number">10</span>;<span class="comment">//个位</span></span><br><span class="line">        <span class="keyword">if</span> (ge==wan&amp;&amp;shi==qian)<span class="comment">//个位等于万位并且十位等于千位</span></span><br><span class="line">        &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;这是回文数\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是不是回文数\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行截图：</strong></p><p><img src="https://i.loli.net/2020/05/07/K7ENjJldHtnqZLs.png" alt="2020-05-07_104434.png"></p><h2 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h2><p>一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在第10次落地时，共经过多少米？第10次反弹多高？</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> exam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="keyword">double</span> sum = <span class="number">0</span>, high = <span class="number">100</span>;<span class="comment">//sum为路径总和，high表示当前高度</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">&#123;</span><br><span class="line">sum = high + high / <span class="number">2</span> + sum;<span class="comment">//一次落地距离+弹起距离+已经过路程</span></span><br><span class="line">high /= <span class="number">2</span>;<span class="comment">//弹起高度为一半</span></span><br><span class="line">&#125;</span><br><span class="line">sum -= high;<span class="comment">//求第10次落地经过路程需减去第10次弹起距离</span></span><br><span class="line">System.out.println(<span class="string">&quot;共经过：&quot;</span>+sum+ <span class="string">&quot;米\n&quot;</span>+<span class="string">&quot;第10次反弹高度为：&quot;</span>+high+<span class="string">&quot;米&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行截图：</strong></p><p><img src="https://i.loli.net/2020/05/07/Cw3UmlFiRcNvjYE.png" alt="2020-05-07_104730.png"></p><h2 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h2><p>猴子吃桃问题：猴子第一天摘下若干个桃子，当即吃了一半，还不过瘾，又多吃了一个; 第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下的一半零一个。到第10天早上想再吃时，见只剩下一个桃子了。求第一天共摘了多少。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> exam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;<span class="comment">//第十天剩余桃子数</span></span><br><span class="line"><span class="keyword">int</span> y;<span class="comment">//天数</span></span><br><span class="line"><span class="keyword">for</span>(y=<span class="number">1</span>;y&lt;=<span class="number">9</span>;y++)</span><br><span class="line">&#123;</span><br><span class="line">x=(x+<span class="number">1</span>)*<span class="number">2</span>;<span class="comment">//前一天的剩余桃子数都是今天剩余桃子数加1后的两倍</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;猴子第一天一共摘了&quot;</span>+x+<span class="string">&quot;个桃子。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行截图：</strong></p><p><img src="https://i.loli.net/2020/05/07/XZBYoMhuvJW7ikd.png" alt="2020-05-07_105048.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简介：JAVA基础测试题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://w.wallhaven.cc/full/d5/wallhaven-d5kj6o.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="知识" scheme="https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="面向对象" scheme="https://kelecn.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    <category term="代码" scheme="https://kelecn.top/tags/%E4%BB%A3%E7%A0%81/"/>
    
    <category term="编程" scheme="https://kelecn.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Java" scheme="https://kelecn.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>面向对象的程序设计实验（C++）</title>
    <link href="https://kelecn.top/2019/12/25/4%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>https://kelecn.top/2019/12/25/4%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</id>
    <published>2019-12-25T02:51:34.000Z</published>
    <updated>2020-10-15T17:44:41.448Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简介：面向对象程序设计（C++）。</p><p><img src="https://w.wallhaven.cc/full/w8/wallhaven-w86gex.png"></p> <a id="more"></a><p>还没写呢^_^</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简介：面向对象程序设计（C++）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://w.wallhaven.cc/full/w8/wallhaven-w86gex.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="知识" scheme="https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="面向对象" scheme="https://kelecn.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    <category term="C++" scheme="https://kelecn.top/tags/C/"/>
    
    <category term="代码" scheme="https://kelecn.top/tags/%E4%BB%A3%E7%A0%81/"/>
    
    <category term="编程" scheme="https://kelecn.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="嵌入式" scheme="https://kelecn.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式开发为什么选择C语言？</title>
    <link href="https://kelecn.top/2019/11/25/3%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9C%E8%AF%AD%E8%A8%80%EF%BC%9F/"/>
    <id>https://kelecn.top/2019/11/25/3%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9C%E8%AF%AD%E8%A8%80%EF%BC%9F/</id>
    <published>2019-11-25T09:08:29.000Z</published>
    <updated>2020-10-12T03:35:46.193Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简介:嵌入式+C语言=？</p><p><img src="https://w.wallhaven.cc/full/j5/wallhaven-j5qgk5.jpg"></p> <a id="more"></a><h3 id="1-从语言特点来说"><a href="#1-从语言特点来说" class="headerlink" title="1.从语言特点来说"></a>1.从语言特点来说</h3><p>①C语言有出色的可移植性，能在多种不同体系结构的软/硬平台上运行。</p><p>②简洁紧凑，使用灵活的语法机制，并能直接访问硬件能够直接访问硬件的语言有：汇编和C语言汇编属于低级语言，难以完成一些复杂的功能，但是汇编比C语言访问硬件的效率更高。所以，一般将硬件初始化的工作交给汇编，比较复杂的操作交给C语言。</p><p>③C语言具有很高的运行效率。</p><h3 id="2-嵌入式开发中的地位——开发工具"><a href="#2-嵌入式开发中的地位——开发工具" class="headerlink" title="2.嵌入式开发中的地位——开发工具"></a>2.嵌入式开发中的地位——开发工具</h3><h3 id="3-高级语言中的低级语言：面向过程VS面向对象"><a href="#3-高级语言中的低级语言：面向过程VS面向对象" class="headerlink" title="3.高级语言中的低级语言：面向过程VS面向对象"></a>3.高级语言中的低级语言：面向过程VS面向对象</h3><h5 id="面向过程："><a href="#面向过程：" class="headerlink" title="面向过程："></a>面向过程：</h5><p>“面向过程”(Procedure Orien<a href="http://www.elecfans.com/tags/te/">te</a>d)是一种以过程为中心的编程思想。“面向过程”也可称之为“面向记录”编程思想，他们不支持丰富的“面向对象”特性(比如继承、多态)，并且它们不允许混合持久化状态和域逻辑。</p><p>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。面向过程其实是最为实际的一种思考方式,就算是面向对象的方法也是含有面向过程的思想。</p><p>可以说面向过程是一种基础的方法，它考虑的是实际地实现。一般的面向过程是从上往下步步求精，所以面向过程最重要的是模块化的思想方法。</p><h5 id="面向对象："><a href="#面向对象：" class="headerlink" title="面向对象："></a>面向对象：</h5><p>面向对象的分析根据抽象关键的问题域来分解系统。面向对象的设计是一种提供符号设计系统的面向对象的实现过程，它用非常接近实际领域术语的方法把系统构造成“现实世界”的对象。</p><p>面向对象程序设计可以看作一种在程序中包含各种独立而又互相调用的对象的思想，这与传统的思想刚好相反：传统的程序设计主张将程序看作一系列函数的集合，或者直接就是一系列对电脑下达的指令。面向对象程序设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象，因此它们都可以被看作一个小型的“机器”，即对象。</p><h5 id="面向过程和面向对象的区别："><a href="#面向过程和面向对象的区别：" class="headerlink" title="面向过程和面向对象的区别："></a>面向过程和面向对象的区别：</h5><p>以一个人从A地到B地为例，面向过程就是需要规划路线，了解路况，自己做好一系列的准备;而面向对象就是坐上一辆出租车，告诉司机我要去B地就可以了，不用关心其他的事情。</p><p>最后，C语言也有他自身的缺陷，比如代码的复用性差，代码的维护性差，扩展性(新增代码时不改变原来的代码)很差。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简介:嵌入式+C语言=？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://w.wallhaven.cc/full/j5/wallhaven-j5qgk5.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="知识" scheme="https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="编程" scheme="https://kelecn.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="嵌入式" scheme="https://kelecn.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="硬件" scheme="https://kelecn.top/tags/%E7%A1%AC%E4%BB%B6/"/>
    
    <category term="C语言" scheme="https://kelecn.top/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Matlab Gui关于edit keypressfcn的响应</title>
    <link href="https://kelecn.top/2019/10/02/2%E3%80%81Matlab%20gui%E5%85%B3%E4%BA%8Eedit%20keypressfcn%E7%9A%84%E5%93%8D%E5%BA%94/"/>
    <id>https://kelecn.top/2019/10/02/2%E3%80%81Matlab%20gui%E5%85%B3%E4%BA%8Eedit%20keypressfcn%E7%9A%84%E5%93%8D%E5%BA%94/</id>
    <published>2019-10-02T04:00:00.000Z</published>
    <updated>2020-10-12T03:43:38.688Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简介：Matlab GUI键盘输入。</p><p><img src="https://w.wallhaven.cc/full/zm/wallhaven-zme9dg.png"></p><a id="more"></a><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">showmap</span></span></span><br><span class="line">  fig=<span class="built_in">figure</span>( <span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Timer&#x27;</span>,<span class="string">&#x27;Position&#x27;</span>,[<span class="number">0</span>,<span class="number">0</span>,<span class="number">500</span>,<span class="number">500</span>] ,<span class="string">&#x27;NumberTitle&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;visible&#x27;</span>,<span class="string">&#x27;off&#x27;</span>);</span><br><span class="line">  movegui(fig,<span class="string">&#x27;center&#x27;</span>);</span><br><span class="line">  set(fig,<span class="string">&#x27;visible&#x27;</span>,<span class="string">&#x27;on&#x27;</span>);</span><br><span class="line">  ttext= uicontrol(<span class="string">&#x27;Style&#x27;</span>,<span class="string">&#x27;edit&#x27;</span>,<span class="string">&#x27;Position&#x27;</span>,[<span class="number">150</span>,<span class="number">250</span>,<span class="number">200</span>,<span class="number">30</span>],<span class="string">&#x27;String&#x27;</span>,<span class="string">&#x27;Press  &quot;Start&quot;&#x27;</span>,...</span><br><span class="line">      <span class="string">&#x27;KeyPressFcn&#x27;</span>,@keyPress);</span><br><span class="line"></span><br><span class="line"> ii=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">keyPress</span><span class="params">(x,y)</span></span></span><br><span class="line">        set(ttext,<span class="string">&#x27;string&#x27;</span>,num2str(ii));</span><br><span class="line">        ii = ii+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><!--more--><p>参考文献：<a href="https://mp.weixin.qq.com/s?__biz=MzU5NTAyMTIzOQ==&mid=2247483991&idx=1&sn=0e50c2faa57464846784ef18d54bd608&chksm=fe791e8fc90e9799d139e3860be2fd02afc183d58858959d0d29eb71cc32ed63b68f6a93edfb&scene=21#wechat_redirect">打浦桥程序员</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简介：Matlab GUI键盘输入。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://w.wallhaven.cc/full/zm/wallhaven-zme9dg.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://kelecn.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="代码" scheme="https://kelecn.top/tags/%E4%BB%A3%E7%A0%81/"/>
    
    <category term="Matlab" scheme="https://kelecn.top/tags/Matlab/"/>
    
    <category term="Gui" scheme="https://kelecn.top/tags/Gui/"/>
    
  </entry>
  
  <entry>
    <title>Kelecn的第一条博客！</title>
    <link href="https://kelecn.top/2019/09/19/1%E3%80%81%E5%8F%AF%E4%B9%90%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9D%A1%E5%8D%9A%E5%AE%A2/"/>
    <id>https://kelecn.top/2019/09/19/1%E3%80%81%E5%8F%AF%E4%B9%90%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9D%A1%E5%8D%9A%E5%AE%A2/</id>
    <published>2019-09-19T09:10:00.000Z</published>
    <updated>2020-10-12T03:35:05.440Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简介：您好！Hexo！</p><p><img src="https://w.wallhaven.cc/full/76/wallhaven-76opry.png"></p><a id="more"></a><p>友情链接：<a href="https://github.com/kelecn">My Github</a>、<a href="https://hexo.io/">Hexo</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简介：您好！Hexo！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://w.wallhaven.cc/full/76/wallhaven-76opry.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="生活" scheme="https://kelecn.top/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="Hexo" scheme="https://kelecn.top/tags/Hexo/"/>
    
    <category term="Kelecn" scheme="https://kelecn.top/tags/Kelecn/"/>
    
    <category term="日记" scheme="https://kelecn.top/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
</feed>
