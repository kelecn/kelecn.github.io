<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kelecn</title>
  
  
  <link href="https://kelecn.top/atom.xml" rel="self"/>
  
  <link href="https://kelecn.top/"/>
  <updated>2020-10-15T04:32:38.659Z</updated>
  <id>https://kelecn.top/</id>
  
  <author>
    <name>kelecn</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一文搞懂TCP与UDP的区别</title>
    <link href="https://kelecn.top/2020/08/26/17%E3%80%81%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82TCP%E4%B8%8EUDP%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://kelecn.top/2020/08/26/17%E3%80%81%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82TCP%E4%B8%8EUDP%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-08-26T13:57:00.000Z</published>
    <updated>2020-10-15T04:32:38.659Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简介：网络协议是每个IT工程师都必须要掌握的知识，TCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP，本文将介绍下这两者以及它们之间的区别。<br><img src="https://i.loli.net/2020/10/15/icOPNUCS2Kgzy7W.jpg"></p><a id="more"></a><h5 id=""><a href="#" class="headerlink" title=""></a><div class="note "><p>一、TCP/IP网络模型</p></div></h5><p>计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（protocol）。</p><p>TCP/IP 是互联网相关的各类协议族的总称，比如：TCP，UDP，IP，FTP，HTTP，ICMP，SMTP 等都属于 TCP/IP 族内的协议。</p><p>TCP/IP模型是互联网的基础，它是一系列网络协议的总称。这些协议可以划分为四层，分别为链路层、网络层、传输层和应用层。</p><ul><li>链路层：负责封装和解封装IP报文，发送和接受ARP/RARP报文等。</li><li>网络层：负责路由以及把分组报文发送给目标网络或主机。</li><li>传输层：负责对报文进行分组和重组，并以TCP或UDP协议格式封装报文。</li><li>应用层：负责向用户提供应用程序，比如HTTP、FTP、Telnet、DNS、SMTP等。</li></ul><p><img src="https://i.loli.net/2020/10/15/1gqV3oWnEi7yZxB.png"></p><p>在网络体系结构中网络通信的建立必须是在通信双方的对等层进行，不能交错。 在整个数据传输过程中，数据在发送端时经过各层时都要附加上相应层的协议头和协议尾（仅数据链路层需要封装协议尾）部分，也就是要对数据进行协议封装，以标识对应层所用的通信协议。接下去介绍TCP/IP 中有两个具有代表性的传输层协议—-TCP 和 UDP。</p><h5 id="-1"><a href="#-1" class="headerlink" title=""></a><div class="note "><p>二、UDP</p></div></h5><p>UDP协议全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。</p><p>它有以下几个特点：</p><p><strong>1. 面向无连接</strong></p><p>首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。</p><p>具体来说就是：</p><ul><li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了</li><li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</li></ul><p><strong>2. 有单播，多播，广播的功能</strong></p><p>UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。</p><p><strong>3. UDP是面向报文的</strong></p><p>发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文</p><p><strong>4. 不可靠性</strong></p><p>首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。</p><p>并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。</p><p>再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。</p><p><img src="https://i.loli.net/2020/10/15/CV5nmJiacTAyQFH.gif"></p><p>从上面的动态图可以得知，UDP只会把想发的数据报文一股脑的丢给对方，并不在意数据有无安全完整到达。</p><p><strong>5. 头部开销小，传输数据报文时是很高效的。</strong></p><p><img src="https://i.loli.net/2020/10/15/xcSuoCbsHUvTgnE.png"></p><p>UDP 头部包含了以下几个数据：</p><ul><li>两个十六位的端口号，分别为源端口（可选字段）和目标端口</li><li>整个数据报文的长度</li><li>整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误</li></ul><p>因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的</p><h5 id="-2"><a href="#-2" class="headerlink" title=""></a><div class="note "><p>三、TCP</p></div></h5><p>当一台计算机想要与另一台计算机通讯时，两台计算机之间的通信需要畅通且可靠，这样才能保证正确收发数据。例如，当你想查看网页或查看电子邮件时，希望完整且按顺序查看网页，而不丢失任何内容。当你下载文件时，希望获得的是完整的文件，而不仅仅是文件的一部分，因为如果数据丢失或乱序，都不是你希望得到的结果，于是就用到了TCP。</p><p>TCP协议全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的RFC 793定义。TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，你可以把它想象成排水管中的水流。</p><p><strong>1. TCP连接过程</strong></p><p>如下图所示，可以看到建立一个TCP连接的过程为（三次握手的过程）:</p><p><img src="https://i.loli.net/2020/10/15/5cVC9ElRnb1jqQZ.png"></p><p><strong>第一次握手</strong></p><p>客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。</p><p><strong>第二次握手</strong></p><p>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。</p><p><strong>第三次握手</strong></p><p>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。</p><p>这里可能大家会有个疑惑：为什么 TCP 建立连接需要三次握手，而不是两次？这是因为这是为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。</p><p><img src="https://i.loli.net/2020/10/15/jzIdoxmeAnbp9HM.gif"></p><p><strong>2. TCP断开链接</strong></p><p><img src="https://i.loli.net/2020/10/15/hgMfjN9XKrvuxUc.png"></p><p>TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK。</p><p><strong>第一次握手</strong></p><p>若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。</p><p><strong>第二次握手</strong></p><p>B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。</p><p><strong>第三次握手</strong></p><p>B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。</p><p><strong>第四次握手</strong></p><p>A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。</p><p><strong>3. TCP协议的特点</strong></p><ul><li><p>面向连接</p><p>面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。</p></li><li><p>仅支持单播传输</p></li></ul><p>每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。</p><ul><li>面向字节流</li></ul><p>TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。</p><ul><li><p>可靠传输</p><p>对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。</p></li><li><p>提供拥塞控制</p></li></ul><p>当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞</p><ul><li>TCP提供全双工通信</li></ul><p>TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）</p><h5 id="-3"><a href="#-3" class="headerlink" title=""></a><div class="note "><p>四、TCP和UDP的比较</p></div></h5><p><strong>1. 对比</strong></p><table><thead><tr><th align="left"></th><th align="left">UDP</th><th>TCP</th></tr></thead><tbody><tr><td align="left">是否连接</td><td align="left">无连接</td><td>面向连接</td></tr><tr><td align="left">是否可靠</td><td align="left">不可靠传输，不使用流量控制和拥塞控制</td><td>可靠传输，使用流量控制和拥塞控制</td></tr><tr><td align="left">连接对象个数</td><td align="left">支持一对一，一对多，多对一和多对多交互通信</td><td>只能是一对一通信</td></tr><tr><td align="left">传输方式</td><td align="left">面向报文</td><td>面向字节流</td></tr><tr><td align="left">首部开销</td><td align="left">首部开销小，仅8字节</td><td>首部最小20字节，最大60字节</td></tr><tr><td align="left">适用场景</td><td align="left">适用于实时应用（IP电话、视频会议、直播等）</td><td>适用于要求可靠传输的应用，例如文件传输</td></tr></tbody></table><p><strong>2. 总结</strong></p><ul><li><p>TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务。</p></li><li><p>虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为</p></li><li><p>对数据准确性要求高，速度可以相对较慢的，可以选用TCP</p><h5 id="-4"><a href="#-4" class="headerlink" title=""></a><div class="note "><p>参考文章：<a href="https://www.cnblogs.com/fundebug/p/differences-of-tcp-and-udp.html">一文搞懂TCP与UDP的区别</a></p></div></h5></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;简介：网络协议是每个IT工程师都必须要掌握的知识，TCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP，本文将介绍下这两者以及它们之间的区别。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2020/10/15/icOPNUCS2Kgzy7W.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="知识" scheme="https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="TCP" scheme="https://kelecn.top/tags/TCP/"/>
    
    <category term="UDP" scheme="https://kelecn.top/tags/UDP/"/>
    
    <category term="计算机网络" scheme="https://kelecn.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>C语言基础知识（复习）</title>
    <link href="https://kelecn.top/2020/08/25/16%E3%80%81C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E5%A4%8D%E4%B9%A0%EF%BC%89/"/>
    <id>https://kelecn.top/2020/08/25/16%E3%80%81C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E5%A4%8D%E4%B9%A0%EF%BC%89/</id>
    <published>2020-08-25T13:57:00.000Z</published>
    <updated>2020-10-15T04:04:46.042Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简介： 嵌入式笔试相关题目、考点。<br><img src="https://w.wallhaven.cc/full/5w/wallhaven-5wr6y9.jpg"></p><a id="more"></a><h5 id=""><a href="#" class="headerlink" title=""></a><div class="note "><p>1、static修饰的局部变量、全局变量、函数</p></div></h5><p>1）、用于声明函数体内的变量为静态局部变量，存储在静态数据存储区，在函数被调用过程中维持其值保持不变。<br>2）、在文件内（函数体外）被声明为静态的变量，可以被文件内的所有函数访问，但不能被其他文件的函数访问，是一个本地的局部变量。<br>3）、在文件内,被声明为静态的函数只可被文件内的其他函数调用，但不能被其他文件的函数调用。</p><h5 id="-1"><a href="#-1" class="headerlink" title=""></a><div class="note "><p>2、关键词const的理解</p></div></h5><p>常类型是指使用类型修饰符const说明的类型，常类型的变量或对象的值是不能被更新的。不管出现在任何上下文都是为这个目的而服务的。<br>注意:非const变量默认为extern。要使const变量能够在其他文件中访问，必须在文件中显式地指定它为extern。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p; <span class="comment">//*p是const,p可变</span></span><br><span class="line"><span class="keyword">const</span> (<span class="keyword">char</span> *) p;<span class="comment">//p是const,*p可变</span></span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> p; <span class="comment">//p是const,*p可变</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> p; <span class="comment">//p和*p都是const</span></span><br><span class="line"><span class="keyword">char</span> <span class="keyword">const</span> * p;<span class="comment">// *p是const,p可变</span></span><br><span class="line">(<span class="keyword">char</span>*) <span class="keyword">const</span> p;<span class="comment">//p是const,*p可变</span></span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> p;<span class="comment">// p是const,*p可变</span></span><br><span class="line"><span class="keyword">char</span> <span class="keyword">const</span>* <span class="keyword">const</span> p;<span class="comment">// p和*p都是const</span></span><br><span class="line"><span class="comment">//例如</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//const修饰一个变量为只读</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//a = 100; //err</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指针变量， 指针指向的内存， 2个不同概念</span></span><br><span class="line"><span class="keyword">char</span> buf[] = <span class="string">&quot;aklgjdlsgjlkds&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从左往右看，跳过类型，看修饰哪个字符</span></span><br><span class="line"><span class="comment">//如果是*， 说明指针指向的内存不能改变</span></span><br><span class="line"><span class="comment">//如果是指针变量，说明指针的指向不能改变，指针的值不能修改</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p = buf;</span><br><span class="line"><span class="comment">// 等价于上面 char const *p1 = buf;</span></span><br><span class="line"><span class="comment">//p[1] = &#x27;2&#x27;; //err</span></span><br><span class="line">p = <span class="string">&quot;agdlsjaglkdsajgl&quot;</span>; <span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> * <span class="keyword">const</span> p2 = buf;</span><br><span class="line">p2[<span class="number">1</span>] = <span class="string">&#x27;3&#x27;</span>;</span><br><span class="line"><span class="comment">//p2 = &quot;salkjgldsjaglk&quot;; //err</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//p3为只读，指向不能变，指向的内存也不能变</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> p3 = buf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="-2"><a href="#-2" class="headerlink" title=""></a><div class="note "><p>3、数组越界问题</p></div></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">string</span>[<span class="number">10</span>];<span class="comment">//应该是char string[11];//字符串数组最后一位是\0</span></span><br><span class="line"><span class="keyword">char</span>*str=<span class="string">&quot;0123456789&quot;</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(<span class="built_in">string</span>,str);<span class="comment">//err</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="-3"><a href="#-3" class="headerlink" title=""></a><div class="note "><p>4、C语言中宏定义的使用</p></div></h5><p>==预处理==命令可以改变程序设计环境,提高编程效率,它们并不是 C 语言本身的组成部分,不能直接对 它们进行编译,必须在对程序进行编译之前,先对程序中这些特殊的命令进行“预处理” 。经过预处理后,程序就不再包括预处理命令了,最后再由编译程序对==预处理==之后的源程序进行==编译==处理,得到可供执行的目标代码。C 语言提供的预处理功能有三种,分别为==宏定义==、文件包含和条件编译。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不带参数的宏定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*带参宏定义*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M(y) y*y+3*y</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*宏调用*/</span></span><br><span class="line">k=M(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//宏定义最大值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) (((a)&gt;(b))?(a):(b))</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; max(<span class="number">1</span>+<span class="number">1</span>,<span class="number">2</span>+<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个面试题主要考查面试者对宏定义的使用，宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对“参数”进行的是一对一的替换。</span></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">#define  MAX( x, y ) ( ((x) &gt; (y)) ? (x) : (y) )//输入a++，a=a+2 调用两次</span></span><br><span class="line"><span class="comment">#define  MIN( x, y ) ( ((x) &lt; (y)) ? (x) : (y) )</span></span><br><span class="line"><span class="comment">#define MAX( a, b )  (&#123;int _a = a;int _b = b;(_a) &gt; (_b)? (_a) :(_b); &#125;)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*程序员对宏定义的使用要非常小心，特别要注意两个问题：</span></span><br><span class="line"><span class="comment">　　（1）谨慎地将宏定义中的“参数”和整个宏用用括弧括起来。所以，严格地讲，下述解答：</span></span><br><span class="line"><span class="comment">#define MIN(A,B) (A) &lt;= (B) ? (A) : (B)</span></span><br><span class="line"><span class="comment">#define MIN(A,B) (A &lt;= B ? A : B )</span></span><br><span class="line"><span class="comment">　　都应判0分；</span></span><br><span class="line"><span class="comment">　　（2）防止宏的副作用。</span></span><br><span class="line"><span class="comment">　　宏定义#define MIN(A,B) ((A) &lt;= (B) ? (A) : (B))对MIN(*p++, b)的作用结果是：</span></span><br><span class="line"><span class="comment">((*p++) &lt;= (b) ? (*p++) : (*p++))</span></span><br><span class="line"><span class="comment">　　这个表达式会产生副作用，指针p会作三次++自增操作。</span></span><br><span class="line"><span class="comment">　　除此之外，另一个应该判0分的解答是：</span></span><br><span class="line"><span class="comment">#define MIN(A,B) ((A) &lt;= (B) ? (A) : (B));  不能在后面加冒号。</span></span><br></pre></td></tr></table></figure><p>参考文章：<a href="https://www.cnblogs.com/emptyYPen/p/7872604.html">宏定义正确处理a++</a></p><h5 id="-4"><a href="#-4" class="headerlink" title=""></a><div class="note "><p>5、递归算N！</p></div></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">long</span> <span class="title">fac</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="keyword">long</span> f;</span><br><span class="line"> <span class="keyword">if</span>(n&lt;<span class="number">0</span>)</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;n&lt;0,data error!&quot;</span>);</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">0</span>,n==<span class="number">1</span>)</span><br><span class="line"> f=<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">else</span> f = fac(n<span class="number">-1</span>)*n;</span><br><span class="line"> <span class="keyword">return</span> (f);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fac</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="keyword">int</span> n,y;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;input an integer number:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">y= fac(n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d!=%ld\n&quot;</span>,n,y);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="-5"><a href="#-5" class="headerlink" title=""></a><div class="note "><p>6、中断服务子程序(ISR)</p></div></h5><p>中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展-让标准C支持中断。其代表事实是，产生了一个新的关键字 interrupt（51即如此）。下面的代码就使用了interrupt关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__interrupt <span class="keyword">double</span> <span class="title">compute_area</span> <span class="params">(<span class="keyword">double</span> radius)</span> </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">double</span> area = PI * radius * radius;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;/nArea = %f&quot;</span>, area);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> area;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">中断服务程序需要满足如下要求： </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">(1)不能返回值； </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">(2)不能向ISR传递参数； （嵌入式中的ISR指的是中断服务处理）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">(3) ISR应该尽可能的短小精悍； </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">(4) printf(char * lpFormatString,…)函数会带来重入和性能问题，不能在ISR中采用。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这个函数有太多的错误了，以至让人不知从何说起了（前提是<strong>非操作系统</strong>下的中断服务函数）：</p><p><strong>1)ISR 不能返回一个值（都应该为void类型）。如果你不懂这个，那么你不会被雇用的。</strong></p><p><strong>2)ISR 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。</strong></p><p>3)在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额外的寄存器入栈，有些处理器/编译器就是不允许在ISR中做浮点运算。此外，ISR应该是<strong>短而有效率</strong>的，在ISR中做浮点运算是不明智的。另外中断服务程序是运行在内核态的（linux），<strong>内核通常是不支持浮点运算的</strong>。</p><h5 id="-6"><a href="#-6" class="headerlink" title=""></a><div class="note "><p>7、排序算法</p></div></h5><p>冒泡排序：基本思想：比较相邻的两个数，如果前者比后者大，则进行交换。每一轮排序结束，选出一个未排序中最大的数放到数组后面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//冒泡排序算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n - <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果前面的数比后面大，进行交换</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j]; arr[j] = arr[j + <span class="number">1</span>]; arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123; <span class="number">10</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    bubbleSort(arr, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后的数组为：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>参考文章：<a href="https://www.cnblogs.com/maluning/p/7944809.html">七大经典排序算法总结(C语言描述)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简介： 嵌入式笔试相关题目、考点。&lt;br&gt;&lt;img src=&quot;https://w.wallhaven.cc/full/5w/wallhaven-5wr6y9.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="知识" scheme="https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="C++" scheme="https://kelecn.top/tags/C/"/>
    
    <category term="编程" scheme="https://kelecn.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="嵌入式" scheme="https://kelecn.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="C" scheme="https://kelecn.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>精简代码：改换运算符</title>
    <link href="https://kelecn.top/2020/08/22/15%E3%80%81%E7%B2%BE%E7%AE%80%E4%BB%A3%E7%A0%81%EF%BC%9A%E6%94%B9%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>https://kelecn.top/2020/08/22/15%E3%80%81%E7%B2%BE%E7%AE%80%E4%BB%A3%E7%A0%81%EF%BC%9A%E6%94%B9%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6/</id>
    <published>2020-08-22T13:57:00.000Z</published>
    <updated>2020-10-15T01:12:28.929Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简介： 精简代码：改换运算符<br><img src="https://w.wallhaven.cc/full/48/wallhaven-48o3ky.jpg"></p><a id="more"></a><h5 id="1、位运算（-amp-）替换取余（-）运算"><a href="#1、位运算（-amp-）替换取余（-）运算" class="headerlink" title="1、位运算（&amp;）替换取余（%）运算"></a>1、位运算（&amp;）替换取余（%）运算</h5><p><strong>即：如果Y =<img src="https://private.codecogs.com/gif.latex?2%5E%7Bn%7D" alt="2^{n}">,则X%Y可以变化为X&amp;(Y-1)</strong><br>由于我们知道位运算比较高效，在某些情况下，当b为2的n次方时，有如下替换公式：<br>a % b = a &amp; (b-1)(b=2^n)<br>即：a % 2^n = a &amp; (2^n-1)<br>例如：14%8，取余数，相当于取出低位，而余数最大为7，14二进制为1110，8的二进制1000，8-1 = 7的二进制为0111，由于现在低位全为1，让其跟14做&amp;运算，正好取出的是其低位上的余数。1110&amp;0111=110即6=14%8；（此公式只适用b=2^n，是因为可以保证b始终只有最高位为1，其他二进制位全部为0，减去1，之后，可以把高位1消除，其他位都为1，而与1做&amp;运算，会保留原来的数。）</p><h5 id="2、左移运算（-lt-lt-）替换乘法（-）运算"><a href="#2、左移运算（-lt-lt-）替换乘法（-）运算" class="headerlink" title="2、左移运算（&lt;&lt;）替换乘法（*）运算"></a>2、左移运算（&lt;&lt;）替换乘法（*）运算</h5><p>a=a8;<br>b=b/8;<br><strong>可以改为：</strong><br>a=a&lt;&lt;3;<br>b=b&gt;&gt;3;<br><strong>说明：</strong><br>除2 = 右移1位； 乘2 = 左移1位<br>除4 = 右移2位； 乘4 = 左移2位<br>除8 = 右移3位； 乘8 = 左移3位<br><strong>通常如果需要乘以或除以2的n次方，都可以用移位的方法代替，大部分的C编译器,用移位的方法得到代码比调用乘除法子程序生成的代码效率高。</strong><br><strong>实际上，只要是乘以或除以一个整数才可以用移位的方法得到结果。</strong><br>如：<br>a=a9 =a(8+1)=a8+a1<br><strong>可以改为：</strong><br>a=(a&lt;&lt;3)+a<br>如：<br>a=a7 =a(8-1)=a8-a1<br><strong>可以改为：</strong><br>a=(a&lt;&lt;3)-a</p><p><strong>总结：a=an; n分解成(2^m + s),则a=an可以改为a=(a&lt;&lt;m)+as;as再同理分解替换。</strong></p><p>例：a=a10 =&gt; a=a(8+2) =&gt; a=a8 + a2 =&gt; a=(a&lt;&lt;3)+(a&lt;&lt;1)</p><h5 id="3、右移运算（-gt-gt-）替换除法（-）运算"><a href="#3、右移运算（-gt-gt-）替换除法（-）运算" class="headerlink" title="3、右移运算（&gt;&gt;）替换除法（/）运算"></a>3、右移运算（&gt;&gt;）替换除法（/）运算</h5><p>a=a*8;<br>b=b/8;<br><strong>可以改为：</strong><br>a=a&lt;&lt;3;<br>b=b&gt;&gt;3;<br><strong>说明：</strong><br>除2 = 右移1位； 乘2 = 左移1位<br>除4 = 右移2位； 乘4 = 左移2位<br>除8 = 右移3位； 乘8 = 左移3位<br><strong>通常如果需要乘以或除以2的n次方，都可以用移位的方法代替，大部分的C编译器,用移位的方法得到代码比调用乘除法子程序生成的代码效率高。</strong><br><strong>实际上，只要是乘以或除以一个整数才可以用移位的方法得到结果。</strong><br>如：<br>a=a/9 =a/(8+1)=a/8+a/1<br><strong>可以改为：</strong><br>a=(a&gt;&gt;3)+a<br>如：<br>a=a/7 =a/(8-1)=a/8-a/1<br><strong>可以改为：</strong><br>a=(a&gt;&gt;3)-a<br><strong>总结：a=a/n; n分解成(2^m + s),则a=a/n可以改为a=(a&gt;&gt;m)+a/s;a/s再同理分解替换。</strong><br>例：a=a/10 =&gt; a=a/(8+2) =&gt; a=a/8 + a/2 =&gt; a=(a&gt;&gt;3)+(a&gt;&gt;1)</p><h5 id="4、C-C-中的移位操作容易出错的情况："><a href="#4、C-C-中的移位操作容易出错的情况：" class="headerlink" title="4、C/C++中的移位操作容易出错的情况："></a>4、C/C++中的移位操作容易出错的情况：</h5><ul><li><strong>什么样的数据类型可以直接移位</strong><br> 只有整型数据才能用移位替代乘除法，如：char、short、int、long、unsigned char、unsigned short、unsigned int、unsigned long。（double、float、bool、long double则不可以进行移位操作。）</li><li><strong>有符号数据类型移位需要注意符号位</strong><br>对于char、short、int、long这些有符号的数据类型：<br>对负数进行左移：符号位始终为1，其他位左移。<br>对正数进行左移：所有位左移，即 &lt;&lt;，可能会变成负数<br>对负数进行右移：取绝对值，然后右移，再取相反数<br>对正数进行右移：所有位右移，即 &gt;&gt;</li><li><strong>无符号数据类型的移位操作</strong><br>对于unsigned char、unsigned short、unsigned int、unsigned long这些无符号数据类型：<br>没有特殊要说明的，使用&lt;&lt; 和 &gt;&gt; 操作符就OK了。<h5 id="5、参考资料："><a href="#5、参考资料：" class="headerlink" title="5、参考资料："></a>5、参考资料：</h5></li><li><a href="https://blog.csdn.net/LZAlgorithm/article/details/101348934">使用位运算替换取余操作</a></li><li><a href="https://blog.csdn.net/qq_34473360/article/details/90547684">移位操作与乘除法的关系</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;简介： 精简代码：改换运算符&lt;br&gt;&lt;img src=&quot;https://w.wallhaven.cc/full/48/wallhaven-48o3ky.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="知识" scheme="https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="C++" scheme="https://kelecn.top/tags/C/"/>
    
    <category term="ARM" scheme="https://kelecn.top/tags/ARM/"/>
    
    <category term="嵌入式" scheme="https://kelecn.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="C" scheme="https://kelecn.top/tags/C/"/>
    
    <category term="单片机" scheme="https://kelecn.top/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>基于PicGo的GitHub图床</title>
    <link href="https://kelecn.top/2020/08/18/14%E3%80%81%E6%88%91%E7%9A%84GitHub%E5%9B%BE%E5%BA%8A%EF%BC%88%E5%9F%BA%E4%BA%8EPicGo%EF%BC%89/"/>
    <id>https://kelecn.top/2020/08/18/14%E3%80%81%E6%88%91%E7%9A%84GitHub%E5%9B%BE%E5%BA%8A%EF%BC%88%E5%9F%BA%E4%BA%8EPicGo%EF%BC%89/</id>
    <published>2020-08-18T13:57:00.000Z</published>
    <updated>2020-10-12T03:38:07.223Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简介：GitHub图床（基于PicGo）</p><p><img src="https://w.wallhaven.cc/full/2e/wallhaven-2ekjlm.png"></p><a id="more"></a><h1 id="GitHub图床（基于PicGo）"><a href="#GitHub图床（基于PicGo）" class="headerlink" title="GitHub图床（基于PicGo）"></a>GitHub图床（基于PicGo）</h1><h5 id="1-首先你得有一个GitHub账号。注册GitHub就不用我多言。"><a href="#1-首先你得有一个GitHub账号。注册GitHub就不用我多言。" class="headerlink" title="1. 首先你得有一个GitHub账号。注册GitHub就不用我多言。"></a><strong>1.</strong> 首先你得有一个GitHub账号。注册GitHub就不用我多言。</h5><h5 id="2-新建一个仓库"><a href="#2-新建一个仓库" class="headerlink" title="2. 新建一个仓库"></a><strong>2.</strong> 新建一个仓库</h5><p><img src="https://i.loli.net/2020/10/11/TsLZEyarxYoVhpj.png"></p><p>记下你取的仓库名。</p><h5 id="3-生成一个token用于PicGo操作你的仓库："><a href="#3-生成一个token用于PicGo操作你的仓库：" class="headerlink" title="3. 生成一个token用于PicGo操作你的仓库："></a><strong>3.</strong> 生成一个token用于PicGo操作你的仓库：</h5><p>访问：<a href="https://github.com/settings/tokens">https://github.com/settings/tokens</a></p><p>然后点击<code>Generate new token</code>。</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/generate_new_token.png"></p><p>把repo的勾打上即可。然后翻到页面最底部，点击<code>Generate token</code>的绿色按钮生成token。</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/20180508210435.png"></p><p><strong>注意：</strong>这个token生成后只会显示一次！你要把这个token复制一下存到其他地方以备以后要用。</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/copy_token.png"></p><h5 id="4-配置PicGo"><a href="#4-配置PicGo" class="headerlink" title="4. 配置PicGo"></a><strong>4.</strong> 配置PicGo</h5><p><strong>注意：</strong>仓库名的格式是<code>用户名/仓库</code>，比如我创建了一个叫做<code>test</code>的仓库，在PicGo里我要设定的仓库名就是<code>kelecn/images</code>。一般我们选择<code>master</code>分支即可。然后记得点击确定以生效，然后可以点击<code>设为默认图床</code>来确保上传的图床是GitHub。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PicGo配置</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;repo&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="comment">// 仓库名，格式是username/reponame</span></span><br><span class="line">  <span class="attr">&quot;token&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="comment">// github token</span></span><br><span class="line">  <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="comment">// 自定义存储路径，比如img/</span></span><br><span class="line">  <span class="attr">&quot;customUrl&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="comment">// 自定义域名，注意要加http://或者https://</span></span><br><span class="line">  <span class="attr">&quot;branch&quot;</span>: <span class="string">&quot;&quot;</span> <span class="comment">// 分支名，默认是master</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/11/MVezNlYvZGSXuId.png"></p><p>至此配置完毕，已经可以使用了。当你上传的时候，你会发现你的仓库里也会增加新的图片了：</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/success.png"></p><p>更多图床设计：请参考<a href="https://picgo.github.io/PicGo-Doc/zh/guide/">PicGo官方手册</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简介：GitHub图床（基于PicGo）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://w.wallhaven.cc/full/2e/wallhaven-2ekjlm.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://kelecn.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Hexo" scheme="https://kelecn.top/tags/Hexo/"/>
    
    <category term="相册" scheme="https://kelecn.top/tags/%E7%9B%B8%E5%86%8C/"/>
    
    <category term="图床" scheme="https://kelecn.top/tags/%E5%9B%BE%E5%BA%8A/"/>
    
    <category term="Github" scheme="https://kelecn.top/tags/Github/"/>
    
    <category term="PicGo" scheme="https://kelecn.top/tags/PicGo/"/>
    
  </entry>
  
  <entry>
    <title>ARM处理器7种工作模式</title>
    <link href="https://kelecn.top/2020/06/11/12%E3%80%81ARM%E5%A4%84%E7%90%86%E5%99%A87%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/"/>
    <id>https://kelecn.top/2020/06/11/12%E3%80%81ARM%E5%A4%84%E7%90%86%E5%99%A87%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-11T13:47:00.000Z</published>
    <updated>2020-10-12T03:37:46.978Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简介：ARM处理器7种工作模式（特权模式，异常模式，用户模式）。</p><p><img src="https://w.wallhaven.cc/full/2k/wallhaven-2kd28x.jpg"></p><a id="more"></a><h3 id="ARM处理器7种工作模式（特权模式，异常模式，用户模式）"><a href="#ARM处理器7种工作模式（特权模式，异常模式，用户模式）" class="headerlink" title="ARM处理器7种工作模式（特权模式，异常模式，用户模式）"></a>ARM处理器7种工作模式（特权模式，异常模式，用户模式）</h3><p><strong>用户模式（USR）：</strong>正常程序执行模式，不能直接切换到其他模式<br><strong>系统模式（SYS）：</strong>运行操作系统的特权任务，与用户模式类似，但具有可以直接切换到其他模式等特权<br><strong>快中断模式（FIQ）：</strong>支持高速数据传输及通道处理，FIQ异常响应时进入此模式<br><strong>中断模式（IRQ）：</strong>用于通用中断处理，IRQ异常响应时进入此模式<br><strong>管理模式（SVC）：</strong>操作系统保护模式，系统复位和软件中断响应时进入此模式（由系统调用执行软中断SWI命令触发）<br><strong>中止模式（ABT）：</strong>用于支持虚拟内存和/或存储器保护，在ARM7TDMI没有大用处<br><strong>未定义模式（UND）：</strong>支持硬件协处理器的软件仿真，未定义指令异常响应时进入此模式 </p><p><strong>7种工作模式分类：</strong></p><ul><li><p>除用户模式外，其余6种工作模式都属于特权模式</p></li><li><p>特权模式中除了系统模式以外的其余5种模式称为异常模式</p></li><li><p>大多数程序运行于用户模式</p></li><li><p>进入特权模式是为了处理中断、异常、或者访问被保护的系统资源</p></li></ul><p><strong>硬件权限级别：</strong>系统模式 &gt; 异常模式 &gt; 用户模式<br><strong>快中断与慢中断区别：</strong>快中断处理时禁止中断</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简介：ARM处理器7种工作模式（特权模式，异常模式，用户模式）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://w.wallhaven.cc/full/2k/wallhaven-2kd28x.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="知识" scheme="https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="ARM" scheme="https://kelecn.top/tags/ARM/"/>
    
    <category term="嵌入式" scheme="https://kelecn.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="处理器" scheme="https://kelecn.top/tags/%E5%A4%84%E7%90%86%E5%99%A8/"/>
    
    <category term="硬件" scheme="https://kelecn.top/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>测试相册功能</title>
    <link href="https://kelecn.top/2020/06/09/13%E3%80%81%E6%B5%8B%E8%AF%95/"/>
    <id>https://kelecn.top/2020/06/09/13%E3%80%81%E6%B5%8B%E8%AF%95/</id>
    <published>2020-06-09T13:57:00.000Z</published>
    <updated>2020-10-15T01:07:06.312Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="tabs" id="tab-id"><ul class="nav-tabs"><li class="tab active"><a href="#tab-id-1">二次元</a></li><li class="tab"><a href="#tab-id-2">壁纸</a></li><li class="tab"><a href="#tab-id-3">日常</a></li><li class="tab"><a href="#tab-id-4">旅游</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tab-id-1"><div class="gallery stretch" col='2'>              <p><img src="https://w.wallhaven.cc/full/4g/wallhaven-4g789d.png"><br><img src="https://w.wallhaven.cc/full/70/wallhaven-70pz34.jpg"><br><img src="https://w.wallhaven.cc/full/0q/wallhaven-0q2637.jpg"><br><img src="https://w.wallhaven.cc/full/5w/wallhaven-5wr6y9.jpg"><br><img src="https://w.wallhaven.cc/full/nz/wallhaven-nz8mqw.png"><br><img src="https://w.wallhaven.cc/full/1j/wallhaven-1j292g.png"><br><img src="https://w.wallhaven.cc/full/43/wallhaven-43zow3.jpg"><br><img src="https://w.wallhaven.cc/full/8x/wallhaven-8x67go.jpg"></p>            </div></div><div class="tab-pane" id="tab-id-2"><div class="gallery stretch" col='4'>              <p><img src="https://raw.githubusercontent.com/kelecn/images/master/001.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/002.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/003.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/004.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/005.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/006.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/007.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/008.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/009.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/010.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/011.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/012.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/013.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/014.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/015.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/016.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/017.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/018.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/019.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/020.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/021.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/022.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/023.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/024.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/025.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/026.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/027.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/028.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/029.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/030.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/031.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/032.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/033.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/034.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/035.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/036.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/037.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/038.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/039.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/040.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/041.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/042.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/043.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/044.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/045.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/046.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/047.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/048.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/049.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/050.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/051.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/052.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/053.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/054.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/055.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/056.jpg"><br><img src="https://raw.githubusercontent.com/kelecn/images/master/057.jpg"></p>            </div></div><div class="tab-pane" id="tab-id-3"><div class="gallery ">              <p><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/B18FCBB3-67FD-48CC-B4F3-457BA145F17A.jpeg" alt="图片描述"><br><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/67239FBB-E15D-4F4F-8EE8-0F1C9F3C4E7C.jpeg" alt="图片描述"><br><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/00E0F0ED-9F1C-407A-9AA6-545649D919F4.jpeg" alt="图片描述"></p>            </div></div><div class="tab-pane" id="tab-id-4"><div class="gallery ">              <p><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg" alt="图片描述"></p>            </div></div></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="日记" scheme="https://kelecn.top/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="Hexo" scheme="https://kelecn.top/tags/Hexo/"/>
    
    <category term="相册" scheme="https://kelecn.top/tags/%E7%9B%B8%E5%86%8C/"/>
    
    <category term="Kelecn" scheme="https://kelecn.top/tags/Kelecn/"/>
    
  </entry>
  
  <entry>
    <title>C++与Java多态的区别</title>
    <link href="https://kelecn.top/2020/06/06/11%E3%80%81C++%E4%B8%8EJava%E5%A4%9A%E6%80%81%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://kelecn.top/2020/06/06/11%E3%80%81C++%E4%B8%8EJava%E5%A4%9A%E6%80%81%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-06-06T13:40:00.000Z</published>
    <updated>2020-10-03T07:49:41.989Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简介：C++与Java多态的区别。</p><p><img src="https://w.wallhaven.cc/full/6k/wallhaven-6k35rl.jpg"></p><a id="more"></a><h3 id="多态是指用父指针指向不同子类对象时，调用其共有的函数，不同的子类会有不同的行为。虽然C-和Java都具有多态机制，但是他们的实现不同，使用时的效果也会略有不同。"><a href="#多态是指用父指针指向不同子类对象时，调用其共有的函数，不同的子类会有不同的行为。虽然C-和Java都具有多态机制，但是他们的实现不同，使用时的效果也会略有不同。" class="headerlink" title="多态是指用父指针指向不同子类对象时，调用其共有的函数，不同的子类会有不同的行为。虽然C++和Java都具有多态机制，但是他们的实现不同，使用时的效果也会略有不同。"></a>多态是指用父指针指向不同子类对象时，调用其共有的函数，不同的子类会有不同的行为。虽然C++和Java都具有多态机制，但是他们的实现不同，使用时的效果也会略有不同。</h3><h4 id="在C-中"><a href="#在C-中" class="headerlink" title="在C++中"></a>在C++中</h4><ul><li>普通函数调用：具体调用哪个方法在编译时就可以决定(通过查找编译器的符号表)，同时在使用标准过程调用机制基础上增加一个表示对象身份的指针(this指针)。</li><li>虚函数调用：函数调用依赖于对象的实际类型，一般地说，对象的实际类型只能在运行时间才能确定。实现机制是使用virtual table(vtbls)和virtual table pointers(vptrs)。<ol><li>vtbl 是由函数指针构成的数组或链表，程序中每一个class凡声明(或继承)虚函数者，都有一个自己的vtbl，其中的条目就是该class的各个虚函数实现的指针。因此必须为每一个class消耗一个vtbl空间，其大小视虚函数的个数确定。</li><li>凡声明有虚函数的class，其对象都有一个隐藏的data member，用来指向class的vtbl。</li><li>当多态发生时，编译器首先根据对象vptr找出其vtbl，然后找出vtbl内对应的函数指针，最后调用函数指针指向的函数。从而实现多态。</li></ol></li></ul><h4 id="在Java中"><a href="#在Java中" class="headerlink" title="在Java中"></a>在Java中</h4><p>1.C++中VTable和vptr是在编译阶段由编译器自动生成的，也就是说，在C++程序载入内存以前，在.obj（.o）文件中已经有这些结构的信 息；Java中的方法表是由JVM生成的，因此，使用javac命令编译后生成的.class文件中并没有方法表的信息。只有等JVM把.class文件 载入到内存中时，才会为该.class文件动态生成一个与之关联的方法表，放置在JVM的方法区中。</p><p>2.C++中某个方法在VTable的索引号是在编译阶段已经明确知道的，并不需要在运行过程中动态获知；Java中的方法初始时都只是一个符号，并不是 一个明确的地址，只有等到该方法被第一次调用时，才会被解析成一个方法表中的偏移量，也就是说，只有在这个时候，实例方法才明确知道自己在方发表中的偏移 量了，在这之前必须经历一个解析的过程。</p><p>因此在构造函数是Java会发生多态，即使子类此时还没有构造完全（一个极难发现的bug）。而C++则不会发生多态，待父类构造完全，在构造子类。<br><strong>Java代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.fun();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            fun();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] argv)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            B b = <span class="keyword">new</span> B();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//B</span></span><br><span class="line"><span class="comment">//B</span></span><br></pre></td></tr></table></figure><p><strong>C++代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;A&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        A()</span><br><span class="line">        &#123;</span><br><span class="line">            fun();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;B&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        B()</span><br><span class="line">    &#123;</span><br><span class="line">        fun();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//A</span></span><br><span class="line"><span class="comment">//B</span></span><br></pre></td></tr></table></figure><p>可以发现，C++构造子类时，先构造父类，输出A，然后在构造自身，输出B。而Java在构造子类时，父类并未构造完成，但已经可以发生多态输出B，然后再构造自身，输出B。Java一般为了避免这种情况，会把fun等init()函数声明为private或者finial。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简介：C++与Java多态的区别。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://w.wallhaven.cc/full/6k/wallhaven-6k35rl.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="知识" scheme="https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="面向对象" scheme="https://kelecn.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    <category term="C++" scheme="https://kelecn.top/tags/C/"/>
    
    <category term="代码" scheme="https://kelecn.top/tags/%E4%BB%A3%E7%A0%81/"/>
    
    <category term="编程" scheme="https://kelecn.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Java" scheme="https://kelecn.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>C++重载注意点</title>
    <link href="https://kelecn.top/2020/05/20/10%E3%80%81%E9%87%8D%E8%BD%BD%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
    <id>https://kelecn.top/2020/05/20/10%E3%80%81%E9%87%8D%E8%BD%BD%E6%B3%A8%E6%84%8F%E7%82%B9/</id>
    <published>2020-05-20T13:30:00.000Z</published>
    <updated>2020-10-12T03:37:34.274Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简介：C++重载注意点。</p><p><img src="https://w.wallhaven.cc/full/g8/wallhaven-g8e98d.png"></p><a id="more"></a><h4 id="1-调用函数在前，定义函数在后，进行原型声明"><a href="#1-调用函数在前，定义函数在后，进行原型声明" class="headerlink" title="1.调用函数在前，定义函数在后，进行原型声明"></a>1.调用函数在前，定义函数在后，进行原型声明</h4><h4 id="2-函数重载注意：参数类型和个数相同，参数顺序不同，也可以重载"><a href="#2-函数重载注意：参数类型和个数相同，参数顺序不同，也可以重载" class="headerlink" title="2.函数重载注意：参数类型和个数相同，参数顺序不同，也可以重载"></a>2.函数重载注意：参数类型和个数相同，参数顺序不同，也可以重载</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">double</span> b)</span></span>;<span class="comment">//调用函数在前，定义函数在后，进行原型声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(<span class="keyword">double</span> b,<span class="keyword">int</span> a)</span></span>;<span class="comment">//调用函数在前，定义函数在后，进行原型声明</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">8</span>;</span><br><span class="line">    <span class="keyword">double</span> y=<span class="number">8</span>;</span><br><span class="line">    print(x,y);</span><br><span class="line">    print(y,x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;showpoint&lt;&lt;<span class="string">&quot;1&quot;</span>&lt;&lt;a&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(<span class="keyword">double</span> b,<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;showpoint&lt;&lt;<span class="string">&quot;2&quot;</span>&lt;&lt; a&lt;&lt;b &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="3-C-中cout输出字符型指针地址值的方法"><a href="#3-C-中cout输出字符型指针地址值的方法" class="headerlink" title="3.C++中cout输出字符型指针地址值的方法"></a>3.C++中cout输出字符型指针地址值的方法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++中cout输出字符型指针地址值的方法</span></span><br><span class="line"><span class="comment">//若要打印地址请用void*，否则 p会被认为是字符串。原因：运算符重载的匹配规则</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">char</span> a;</span><br><span class="line">     <span class="keyword">char</span> *p=&amp;a;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;(<span class="keyword">void</span>*)p&lt;&lt;<span class="built_in">endl</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;简介：C++重载注意点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://w.wallhaven.cc/full/g8/wallhaven-g8e98d.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="知识" scheme="https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="面向对象" scheme="https://kelecn.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    <category term="C++" scheme="https://kelecn.top/tags/C/"/>
    
    <category term="代码" scheme="https://kelecn.top/tags/%E4%BB%A3%E7%A0%81/"/>
    
    <category term="编程" scheme="https://kelecn.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++返回对象和返回引用</title>
    <link href="https://kelecn.top/2020/04/19/9%E3%80%81C++%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%BF%94%E5%9B%9E%E5%BC%95%E7%94%A8/"/>
    <id>https://kelecn.top/2020/04/19/9%E3%80%81C++%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%BF%94%E5%9B%9E%E5%BC%95%E7%94%A8/</id>
    <published>2020-04-19T13:20:07.000Z</published>
    <updated>2020-10-12T03:37:21.578Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简介：C++返回对象和返回引用。</p><p><img src="https://w.wallhaven.cc/full/ym/wallhaven-ym181g.jpg"></p><a id="more"></a><p>我们发现，在C++中，有些成员函数返回的是对象，而有些函数返回的又是引用。</p><p>返回对象和返回引用的最主要的区别就是函数原型和函数头。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Car <span class="title">run</span><span class="params">(<span class="keyword">const</span> Car &amp;)</span>   <span class="comment">//返回对象</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Car &amp; <span class="title">run</span><span class="params">(<span class="keyword">const</span> Car &amp;)</span>  <span class="comment">//返回引用</span></span></span><br></pre></td></tr></table></figure><p>​        返回对象会涉及到生成返回对象的副本。因此，返回对象的时间成本包括了调用复制构造函数来生成副本所需的时间和调用析构函数删除副本所需的时间。返回引用可以节省时间和内存。直接返回对象与按值传递对象类似，他们都生成临时副本。同样，返回引用与按引用传递对象类似，调用和被调用的函数对同一个对象进行操作。</p><p>​        并不是总是可以返回引用的。比如函数不能返回在函数中创建的临时对象的引用。因为当函数结束调用时，临时对象将消失，因此这种引用是非法的。在这种情况下，应返回对象，以生成一个调用程序可以使用的副本。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简介：C++返回对象和返回引用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://w.wallhaven.cc/full/ym/wallhaven-ym181g.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="知识" scheme="https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="面向对象" scheme="https://kelecn.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    <category term="C++" scheme="https://kelecn.top/tags/C/"/>
    
    <category term="代码" scheme="https://kelecn.top/tags/%E4%BB%A3%E7%A0%81/"/>
    
    <category term="编程" scheme="https://kelecn.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>关于free和delete的使用</title>
    <link href="https://kelecn.top/2020/03/29/8%E3%80%81%E5%85%B3%E4%BA%8Efree%E5%92%8Cdelete%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://kelecn.top/2020/03/29/8%E3%80%81%E5%85%B3%E4%BA%8Efree%E5%92%8Cdelete%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2020-03-29T13:10:00.000Z</published>
    <updated>2020-10-12T03:37:06.416Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简介：关于free和delete的使用</p><p><img src="https://w.wallhaven.cc/full/dg/wallhaven-dgy8gg.jpg"></p><a id="more"></a><p>两个同时存在是有它的原因的，free是函数，它只释放内存，但不会调用析构函数，如果用free去释放new申请的空间，会因为无法调用析构函数而出现不必要的错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *point = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="number">100</span>);  </span><br><span class="line"><span class="built_in">strcpy</span>(point, “hello”);  </span><br><span class="line"><span class="built_in">free</span>(point); <span class="comment">// Be careful here，point 所指的内存被释放，but point 所指的地址仍然不变  </span></span><br><span class="line">…  </span><br><span class="line"><span class="keyword">if</span>(point != <span class="literal">NULL</span>) <span class="comment">// 没有起到防错作用  </span></span><br><span class="line">&#123;  </span><br><span class="line"><span class="built_in">strcpy</span>(point, “jackery”); <span class="comment">// error  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段程序中，原来free和delete只是把指针所指的内存给释放掉，<strong>但并没有把指针本身干掉</strong>。指针point被free以后其地址仍然不变（非NULL），只是该地址对应的内存是垃圾，point成了“野指针”。如果此时不把point设置为NULL，会让人误以为point是个合法的指针。如果程序比较长，我们有时记不住 point 所指的内存是否已经被释放，在继续使用point 之前，通常会用语句if (p != NULL)进行防错处理。很遗憾，此时if语句起不到防错作用，因为即便point不是NULL指针，它也不指向合法的内存块。<strong>为了避免失误，最好在free之后或者之前，将指针指向NULL</strong></p><h4 id="new-delete-与-malloc-free-区别"><a href="#new-delete-与-malloc-free-区别" class="headerlink" title="new()/delete()与 malloc()/free() 区别"></a>new()/delete()与 malloc()/free() 区别</h4><p>1.malloc()/free() 是标准库函数， 使用前需调用库头文件 &lt;stdlib.h&gt; 方可使用；而 new/delete 是运算       符，执行效率更高。</p><p>2.malloc() 需要手工计算字节数；而 new 能够自动计算需要分配的内存空间。</p><p>3.malloc() 返回的指针是 void 类型；而 new*返回的指针是它分配空间的类型。</p><p>4.new 时调用构造函数，而 malloc() 不能；delete 时调用析构函数，而 free() 不能。</p><p>5.new 在申请单个类型变量时可以赋初值，而 malloc() 不具备。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简介：关于free和delete的使用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://w.wallhaven.cc/full/dg/wallhaven-dgy8gg.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="知识" scheme="https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="面向对象" scheme="https://kelecn.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    <category term="C++" scheme="https://kelecn.top/tags/C/"/>
    
    <category term="代码" scheme="https://kelecn.top/tags/%E4%BB%A3%E7%A0%81/"/>
    
    <category term="编程" scheme="https://kelecn.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>常量指针与指针常量</title>
    <link href="https://kelecn.top/2020/03/11/7%E3%80%81%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F/"/>
    <id>https://kelecn.top/2020/03/11/7%E3%80%81%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F/</id>
    <published>2020-03-11T13:07:00.000Z</published>
    <updated>2020-10-13T05:48:50.882Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简介：常量指针与指针常量的区别。</p><p><img src="https://w.wallhaven.cc/full/ym/wallhaven-ymoo2x.jpg"></p><a id="more"></a><h3 id="常量指针-被指向的对象是常量"><a href="#常量指针-被指向的对象是常量" class="headerlink" title="常量指针(被指向的对象是常量)"></a>常量指针(被指向的对象是常量)</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>又叫常指针，可以理解为<strong>常量的指针</strong>，指向的是个常量</p><h4 id="关键点："><a href="#关键点：" class="headerlink" title="关键点："></a>关键点：</h4><ol><li>常量指针指向的对象不能通过这个指针来修改，可是仍然可以通过原来的声明修改；</li><li>常量指针可以被赋值为变量的地址，之所以叫常量指针，是限制了通过这个指针修改变量的值；</li><li>指针还可以指向别处，因为指针本身只是个变量，可以指向任意地址；　</li></ol><h4 id="代码形式："><a href="#代码形式：" class="headerlink" title="代码形式："></a>代码形式：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>* p;  <span class="keyword">const</span> <span class="keyword">int</span>* p;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量指针(被指向的对象是常量)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> i2 = <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);<span class="comment">//10</span></span><br><span class="line">    i = <span class="number">9</span>; <span class="comment">//OK,仍然可以通过原来的声明修改值，</span></span><br><span class="line">    <span class="comment">//Error,*p是const int的，不可修改，即常量指针不可修改其指向地址</span></span><br><span class="line">    <span class="comment">//*p = 11;  //error: assignment of read-only location ‘*p’</span></span><br><span class="line">    p = &amp;i2;<span class="comment">//OK,指针还可以指向别处，因为指针只是个变量，可以随意指向；</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);<span class="comment">//11</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="指针常量-指针本身是常量"><a href="#指针常量-指针本身是常量" class="headerlink" title="指针常量(指针本身是常量)"></a>指针常量(指针本身是常量)</h3><h4 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h4><p>本质是一个常量，而用指针修饰它。指针常量的值是指针，这个值因为是常量，所以不能被赋值。</p><h4 id="关键点：-1"><a href="#关键点：-1" class="headerlink" title="关键点："></a>关键点：</h4><ol><li>它是个常量！</li><li>指针所保存的地址可以改变，然而指针所指向的值却不可以改变；</li><li>指针本身是常量，指向的地址不可以变化,但是指向的地址所对应的内容可以变化；</li></ol><h4 id="代码形式：-1"><a href="#代码形式：-1" class="headerlink" title="代码形式："></a>代码形式：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指针常量(指针本身是常量)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> *<span class="keyword">const</span> p = &amp;i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);<span class="comment">//10</span></span><br><span class="line">    <span class="comment">//Error,因为p是const 指针，因此不能改变p指向的内容</span></span><br><span class="line">    <span class="comment">//p++;//error: increment of read-only variable ‘p’</span></span><br><span class="line">    (*p)++;    <span class="comment">//OK,指针是常量，指向的地址不可以变化,但是指向的地址所对应的内容可以变化</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);<span class="comment">//11</span></span><br><span class="line">    i = <span class="number">9</span>;<span class="comment">//OK,仍然可以通过原来的声明修改值，</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何区分常量指针和指针常量"><a href="#如何区分常量指针和指针常量" class="headerlink" title="如何区分常量指针和指针常量"></a>如何区分常量指针和指针常量</h3><ul><li>一种方式是看 * 和 const 的排列顺序，比如</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>* p;<span class="comment">//const * 即常量指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p;<span class="comment">//const * 即常量指针</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p;<span class="comment">//* const 即指针常量</span></span><br></pre></td></tr></table></figure><ul><li>还一种方式是看const离谁近，即从右往左看，比如</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>* p;<span class="comment">//const修饰的是*p，即*p的内容不可通过p改变，但p不是const，p可以修改，*p不可修改；</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p;<span class="comment">//同上</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p;<span class="comment">//const修饰的是p，p是指针，p指向的地址不能修改，p不能修改，但*p可以修改；</span></span><br></pre></td></tr></table></figure><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">(struct stu * <span class="keyword">const</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//p = NULL; //err</span></span><br><span class="line">p-&gt;age = <span class="number">10</span>; <span class="comment">//ok</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//void fun2(struct stu const*  p)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">(<span class="keyword">const</span> struct stu *  p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p = <span class="literal">NULL</span>; <span class="comment">//ok</span></span><br><span class="line"><span class="comment">//p-&gt;age = 10; //err</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun3</span><span class="params">(<span class="keyword">const</span> struct stu * <span class="keyword">const</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//p = NULL; //err</span></span><br><span class="line"><span class="comment">//p-&gt;age = 10; //err</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;简介：常量指针与指针常量的区别。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://w.wallhaven.cc/full/ym/wallhaven-ymoo2x.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="知识" scheme="https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="面向对象" scheme="https://kelecn.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    <category term="C++" scheme="https://kelecn.top/tags/C/"/>
    
    <category term="代码" scheme="https://kelecn.top/tags/%E4%BB%A3%E7%A0%81/"/>
    
    <category term="编程" scheme="https://kelecn.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>编程过程中遇到的一些问题总结（C++&amp;Java）</title>
    <link href="https://kelecn.top/2020/02/18/6%E3%80%81%E7%BC%96%E7%A8%8B%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88C++&amp;Java%EF%BC%89/"/>
    <id>https://kelecn.top/2020/02/18/6%E3%80%81%E7%BC%96%E7%A8%8B%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88C++&amp;Java%EF%BC%89/</id>
    <published>2020-02-18T02:05:00.000Z</published>
    <updated>2020-10-12T03:36:48.303Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简介：（C++&amp;Java）问题总结。</p><p><img src="https://w.wallhaven.cc/full/wy/wallhaven-wyw8wr.jpg"></p><a id="more"></a><p>1.Java中的boolean类型变量，只有两个值true ,false；C++也是，不过也可以用 1 0 代替。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java boolean 类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I Love YOU!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ boolean 类型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;I Love YOU!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.Java一个类中的boolean类型变量，一般用isXxx()类型获取私有变量Xxx；</p><p>注：get开头的方法，一般都表示返回某一个属性值；is开头的方法，一般都是用来表示判断某某内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;简介：（C++&amp;amp;Java）问题总结。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://w.wallhaven.cc/full/wy/wallhaven-wyw8wr.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="总结" scheme="https://kelecn.top/categories/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="面向对象" scheme="https://kelecn.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    <category term="C++" scheme="https://kelecn.top/tags/C/"/>
    
    <category term="编程" scheme="https://kelecn.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Java" scheme="https://kelecn.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JAVA测试题</title>
    <link href="https://kelecn.top/2020/02/07/5%E3%80%81JAVA%E6%B5%8B%E8%AF%95%E9%A2%98/"/>
    <id>https://kelecn.top/2020/02/07/5%E3%80%81JAVA%E6%B5%8B%E8%AF%95%E9%A2%98/</id>
    <published>2020-02-07T02:05:00.000Z</published>
    <updated>2020-10-12T03:36:37.841Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简介：JAVA基础测试题。</p><p><img src="https://w.wallhaven.cc/full/d5/wallhaven-d5kj6o.png"></p><a id="more"></a><h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><p>输出9*9口诀表。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> exam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i ++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line"> &#123;</span><br><span class="line"> System.out.print(i +<span class="string">&quot; * &quot;</span>+j+<span class="string">&quot; = &quot;</span>+i*j + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"> System.out.println();<span class="comment">//换行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行截图：</strong></p><p><img src="https://i.loli.net/2020/05/07/HJNRoVQylpuhk7U.png" alt="2020-05-07_102624.png"></p><h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><p>求1+2!+3!+…+20!的和。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> exam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="keyword">float</span> s=<span class="number">0</span>,t=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">for</span> (n=<span class="number">1</span>;n&lt;=<span class="number">20</span>;n++)</span><br><span class="line">  &#123;</span><br><span class="line">    t=t*n;      <span class="comment">// 求n!</span></span><br><span class="line">    s=s+t;      <span class="comment">// 将各项累加</span></span><br><span class="line">  &#125;</span><br><span class="line"> System.out.println(<span class="string">&quot;1+2!+3!+...+20!=&quot;</span>+s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行截图：</strong></p><p><img src="https://i.loli.net/2020/05/07/gqL64Yl3JrIUsxk.png" alt="2020-05-07_104101.png"></p><h2 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h2><p>一个5位数，判断它是不是回文数。即12321是回文数，个位与万位相同，十位与千位相同。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> exam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ge,shi,qian,wan,x;</span><br><span class="line">System.out.println(<span class="string">&quot;请输入您想判断的五位数字：&quot;</span>);</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        x=in.nextInt();</span><br><span class="line">        wan=x/<span class="number">10000</span>;<span class="comment">//万位</span></span><br><span class="line">        qian=x%<span class="number">10000</span>/<span class="number">1000</span>;<span class="comment">//千位</span></span><br><span class="line">        shi=x%<span class="number">100</span>/<span class="number">10</span>;<span class="comment">//十位</span></span><br><span class="line">        ge=x%<span class="number">10</span>;<span class="comment">//个位</span></span><br><span class="line">        <span class="keyword">if</span> (ge==wan&amp;&amp;shi==qian)<span class="comment">//个位等于万位并且十位等于千位</span></span><br><span class="line">        &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;这是回文数\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是不是回文数\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行截图：</strong></p><p><img src="https://i.loli.net/2020/05/07/K7ENjJldHtnqZLs.png" alt="2020-05-07_104434.png"></p><h2 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h2><p>一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在第10次落地时，共经过多少米？第10次反弹多高？</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> exam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="keyword">double</span> sum = <span class="number">0</span>, high = <span class="number">100</span>;<span class="comment">//sum为路径总和，high表示当前高度</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">&#123;</span><br><span class="line">sum = high + high / <span class="number">2</span> + sum;<span class="comment">//一次落地距离+弹起距离+已经过路程</span></span><br><span class="line">high /= <span class="number">2</span>;<span class="comment">//弹起高度为一半</span></span><br><span class="line">&#125;</span><br><span class="line">sum -= high;<span class="comment">//求第10次落地经过路程需减去第10次弹起距离</span></span><br><span class="line">System.out.println(<span class="string">&quot;共经过：&quot;</span>+sum+ <span class="string">&quot;米\n&quot;</span>+<span class="string">&quot;第10次反弹高度为：&quot;</span>+high+<span class="string">&quot;米&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行截图：</strong></p><p><img src="https://i.loli.net/2020/05/07/Cw3UmlFiRcNvjYE.png" alt="2020-05-07_104730.png"></p><h2 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h2><p>猴子吃桃问题：猴子第一天摘下若干个桃子，当即吃了一半，还不过瘾，又多吃了一个; 第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下的一半零一个。到第10天早上想再吃时，见只剩下一个桃子了。求第一天共摘了多少。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> exam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;<span class="comment">//第十天剩余桃子数</span></span><br><span class="line"><span class="keyword">int</span> y;<span class="comment">//天数</span></span><br><span class="line"><span class="keyword">for</span>(y=<span class="number">1</span>;y&lt;=<span class="number">9</span>;y++)</span><br><span class="line">&#123;</span><br><span class="line">x=(x+<span class="number">1</span>)*<span class="number">2</span>;<span class="comment">//前一天的剩余桃子数都是今天剩余桃子数加1后的两倍</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;猴子第一天一共摘了&quot;</span>+x+<span class="string">&quot;个桃子。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行截图：</strong></p><p><img src="https://i.loli.net/2020/05/07/XZBYoMhuvJW7ikd.png" alt="2020-05-07_105048.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简介：JAVA基础测试题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://w.wallhaven.cc/full/d5/wallhaven-d5kj6o.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="知识" scheme="https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="面向对象" scheme="https://kelecn.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    <category term="代码" scheme="https://kelecn.top/tags/%E4%BB%A3%E7%A0%81/"/>
    
    <category term="编程" scheme="https://kelecn.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Java" scheme="https://kelecn.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>面向对象的程序设计实验（C++）</title>
    <link href="https://kelecn.top/2019/12/25/4%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>https://kelecn.top/2019/12/25/4%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</id>
    <published>2019-12-25T02:51:34.000Z</published>
    <updated>2020-10-12T03:36:26.619Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简介：面向对象程序设计（C++）。</p><p><img src="https://w.wallhaven.cc/full/w8/wallhaven-w86gex.png"></p> <a id="more"></a><p>还没写呢^_^</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简介：面向对象程序设计（C++）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://w.wallhaven.cc/full/w8/wallhaven-w86gex.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="知识" scheme="https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="面向对象" scheme="https://kelecn.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    <category term="C++" scheme="https://kelecn.top/tags/C/"/>
    
    <category term="代码" scheme="https://kelecn.top/tags/%E4%BB%A3%E7%A0%81/"/>
    
    <category term="编程" scheme="https://kelecn.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式开发为什么选择C语言？</title>
    <link href="https://kelecn.top/2019/11/25/3%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9C%E8%AF%AD%E8%A8%80%EF%BC%9F/"/>
    <id>https://kelecn.top/2019/11/25/3%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9C%E8%AF%AD%E8%A8%80%EF%BC%9F/</id>
    <published>2019-11-25T09:08:29.000Z</published>
    <updated>2020-10-12T03:35:46.193Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简介:嵌入式+C语言=？</p><p><img src="https://w.wallhaven.cc/full/j5/wallhaven-j5qgk5.jpg"></p> <a id="more"></a><h3 id="1-从语言特点来说"><a href="#1-从语言特点来说" class="headerlink" title="1.从语言特点来说"></a>1.从语言特点来说</h3><p>①C语言有出色的可移植性，能在多种不同体系结构的软/硬平台上运行。</p><p>②简洁紧凑，使用灵活的语法机制，并能直接访问硬件能够直接访问硬件的语言有：汇编和C语言汇编属于低级语言，难以完成一些复杂的功能，但是汇编比C语言访问硬件的效率更高。所以，一般将硬件初始化的工作交给汇编，比较复杂的操作交给C语言。</p><p>③C语言具有很高的运行效率。</p><h3 id="2-嵌入式开发中的地位——开发工具"><a href="#2-嵌入式开发中的地位——开发工具" class="headerlink" title="2.嵌入式开发中的地位——开发工具"></a>2.嵌入式开发中的地位——开发工具</h3><h3 id="3-高级语言中的低级语言：面向过程VS面向对象"><a href="#3-高级语言中的低级语言：面向过程VS面向对象" class="headerlink" title="3.高级语言中的低级语言：面向过程VS面向对象"></a>3.高级语言中的低级语言：面向过程VS面向对象</h3><h5 id="面向过程："><a href="#面向过程：" class="headerlink" title="面向过程："></a>面向过程：</h5><p>“面向过程”(Procedure Orien<a href="http://www.elecfans.com/tags/te/">te</a>d)是一种以过程为中心的编程思想。“面向过程”也可称之为“面向记录”编程思想，他们不支持丰富的“面向对象”特性(比如继承、多态)，并且它们不允许混合持久化状态和域逻辑。</p><p>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。面向过程其实是最为实际的一种思考方式,就算是面向对象的方法也是含有面向过程的思想。</p><p>可以说面向过程是一种基础的方法，它考虑的是实际地实现。一般的面向过程是从上往下步步求精，所以面向过程最重要的是模块化的思想方法。</p><h5 id="面向对象："><a href="#面向对象：" class="headerlink" title="面向对象："></a>面向对象：</h5><p>面向对象的分析根据抽象关键的问题域来分解系统。面向对象的设计是一种提供符号设计系统的面向对象的实现过程，它用非常接近实际领域术语的方法把系统构造成“现实世界”的对象。</p><p>面向对象程序设计可以看作一种在程序中包含各种独立而又互相调用的对象的思想，这与传统的思想刚好相反：传统的程序设计主张将程序看作一系列函数的集合，或者直接就是一系列对电脑下达的指令。面向对象程序设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象，因此它们都可以被看作一个小型的“机器”，即对象。</p><h5 id="面向过程和面向对象的区别："><a href="#面向过程和面向对象的区别：" class="headerlink" title="面向过程和面向对象的区别："></a>面向过程和面向对象的区别：</h5><p>以一个人从A地到B地为例，面向过程就是需要规划路线，了解路况，自己做好一系列的准备;而面向对象就是坐上一辆出租车，告诉司机我要去B地就可以了，不用关心其他的事情。</p><p>最后，C语言也有他自身的缺陷，比如代码的复用性差，代码的维护性差，扩展性(新增代码时不改变原来的代码)很差。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简介:嵌入式+C语言=？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://w.wallhaven.cc/full/j5/wallhaven-j5qgk5.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="知识" scheme="https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="编程" scheme="https://kelecn.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="嵌入式" scheme="https://kelecn.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="硬件" scheme="https://kelecn.top/tags/%E7%A1%AC%E4%BB%B6/"/>
    
    <category term="C语言" scheme="https://kelecn.top/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Matlab Gui关于edit keypressfcn的响应</title>
    <link href="https://kelecn.top/2019/10/02/2%E3%80%81Matlab%20gui%E5%85%B3%E4%BA%8Eedit%20keypressfcn%E7%9A%84%E5%93%8D%E5%BA%94/"/>
    <id>https://kelecn.top/2019/10/02/2%E3%80%81Matlab%20gui%E5%85%B3%E4%BA%8Eedit%20keypressfcn%E7%9A%84%E5%93%8D%E5%BA%94/</id>
    <published>2019-10-02T04:00:00.000Z</published>
    <updated>2020-10-12T03:43:38.688Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简介：Matlab GUI键盘输入。</p><p><img src="https://w.wallhaven.cc/full/zm/wallhaven-zme9dg.png"></p><a id="more"></a><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">showmap</span></span></span><br><span class="line">  fig=<span class="built_in">figure</span>( <span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Timer&#x27;</span>,<span class="string">&#x27;Position&#x27;</span>,[<span class="number">0</span>,<span class="number">0</span>,<span class="number">500</span>,<span class="number">500</span>] ,<span class="string">&#x27;NumberTitle&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;visible&#x27;</span>,<span class="string">&#x27;off&#x27;</span>);</span><br><span class="line">  movegui(fig,<span class="string">&#x27;center&#x27;</span>);</span><br><span class="line">  set(fig,<span class="string">&#x27;visible&#x27;</span>,<span class="string">&#x27;on&#x27;</span>);</span><br><span class="line">  ttext= uicontrol(<span class="string">&#x27;Style&#x27;</span>,<span class="string">&#x27;edit&#x27;</span>,<span class="string">&#x27;Position&#x27;</span>,[<span class="number">150</span>,<span class="number">250</span>,<span class="number">200</span>,<span class="number">30</span>],<span class="string">&#x27;String&#x27;</span>,<span class="string">&#x27;Press  &quot;Start&quot;&#x27;</span>,...</span><br><span class="line">      <span class="string">&#x27;KeyPressFcn&#x27;</span>,@keyPress);</span><br><span class="line"></span><br><span class="line"> ii=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">keyPress</span><span class="params">(x,y)</span></span></span><br><span class="line">        set(ttext,<span class="string">&#x27;string&#x27;</span>,num2str(ii));</span><br><span class="line">        ii = ii+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><!--more--><p>参考文献：<a href="https://mp.weixin.qq.com/s?__biz=MzU5NTAyMTIzOQ==&mid=2247483991&idx=1&sn=0e50c2faa57464846784ef18d54bd608&chksm=fe791e8fc90e9799d139e3860be2fd02afc183d58858959d0d29eb71cc32ed63b68f6a93edfb&scene=21#wechat_redirect">打浦桥程序员</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简介：Matlab GUI键盘输入。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://w.wallhaven.cc/full/zm/wallhaven-zme9dg.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://kelecn.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="代码" scheme="https://kelecn.top/tags/%E4%BB%A3%E7%A0%81/"/>
    
    <category term="Matlab" scheme="https://kelecn.top/tags/Matlab/"/>
    
    <category term="Gui" scheme="https://kelecn.top/tags/Gui/"/>
    
  </entry>
  
  <entry>
    <title>Kelecn的第一条博客！</title>
    <link href="https://kelecn.top/2019/09/19/1%E3%80%81%E5%8F%AF%E4%B9%90%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9D%A1%E5%8D%9A%E5%AE%A2/"/>
    <id>https://kelecn.top/2019/09/19/1%E3%80%81%E5%8F%AF%E4%B9%90%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9D%A1%E5%8D%9A%E5%AE%A2/</id>
    <published>2019-09-19T09:10:00.000Z</published>
    <updated>2020-10-12T03:35:05.440Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简介：您好！Hexo！</p><p><img src="https://w.wallhaven.cc/full/76/wallhaven-76opry.png"></p><a id="more"></a><p>友情链接：<a href="https://github.com/kelecn">My Github</a>、<a href="https://hexo.io/">Hexo</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简介：您好！Hexo！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://w.wallhaven.cc/full/76/wallhaven-76opry.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="生活" scheme="https://kelecn.top/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="Hexo" scheme="https://kelecn.top/tags/Hexo/"/>
    
    <category term="Kelecn" scheme="https://kelecn.top/tags/Kelecn/"/>
    
    <category term="日记" scheme="https://kelecn.top/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
</feed>
