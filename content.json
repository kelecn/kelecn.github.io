{"meta":{"title":"kelecn","subtitle":"","description":"","author":"kelecn","url":"https://kelecn.top","root":"/"},"pages":[{"title":"","date":"2020-10-05T08:38:07.556Z","updated":"2020-09-20T09:47:45.997Z","comments":true,"path":"404.html","permalink":"https://kelecn.top/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2020-10-11T04:37:15.059Z","updated":"2020-09-24T08:50:25.168Z","comments":true,"path":"about/index.html","permalink":"https://kelecn.top/about/index.html","excerpt":"","text":"主要涉及技术：嵌入式开发、电子设计、集成电路、通信、安卓开发、爬虫。一条普通的大四狗联系QQ:1572535194 很惭愧 只做了一点微小的工作 谢谢大家"},{"title":"所有分类","date":"2020-10-11T04:37:07.717Z","updated":"2020-09-20T09:38:42.299Z","comments":true,"path":"categories/index.html","permalink":"https://kelecn.top/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-10-11T04:37:01.734Z","updated":"2020-09-20T09:40:11.246Z","comments":true,"path":"examples/index.html","permalink":"https://kelecn.top/examples/index.html","excerpt":"","text":""},{"title":"","date":"2020-10-11T04:36:53.594Z","updated":"2020-09-20T09:40:11.246Z","comments":true,"path":"faqs/index.html","permalink":"https://kelecn.top/faqs/index.html","excerpt":"","text":""},{"title":"","date":"2020-10-13T05:27:34.508Z","updated":"2020-10-13T05:27:34.508Z","comments":true,"path":"friends/index.html","permalink":"https://kelecn.top/friends/index.html","excerpt":"友链","text":"友链 主题作者+文档 XAOXUU山重水复疑无路，柳暗花明又一村 Volantis主题文档 技术大佬 XU'S BLOG银河小徐"},{"title":"","date":"2020-10-05T08:38:07.566Z","updated":"2020-09-23T10:47:25.648Z","comments":true,"path":"getting-started/index.html","permalink":"https://kelecn.top/getting-started/index.html","excerpt":"","text":""},{"title":"","date":"2020-10-13T05:30:57.409Z","updated":"2020-10-13T05:30:57.409Z","comments":true,"path":"image/index.html","permalink":"https://kelecn.top/image/index.html","excerpt":"","text":"相册 二次元壁纸日常旅游"},{"title":"","date":"2020-10-05T08:38:07.576Z","updated":"2020-09-20T09:40:11.246Z","comments":true,"path":"mylist/index.html","permalink":"https://kelecn.top/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-10-07T12:47:58.846Z","updated":"2020-10-07T12:47:41.342Z","comments":true,"path":"tags/index.html","permalink":"https://kelecn.top/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-10-13T05:28:03.696Z","updated":"2020-10-13T05:28:03.696Z","comments":true,"path":"tool/index.html","permalink":"https://kelecn.top/tool/index.html","excerpt":"工具","text":"工具 视频 真不卡影院真不卡电影网是一个免费看电影的网站 片库每日收集全网最新的电影、电视剧、动漫高清资源 蓝光影视蓝光影视 热门美剧 字幕分享 最好用的影视资源站 樱花动漫专注动漫的门户网站"},{"title":"","date":"2020-10-12T14:46:46.468Z","updated":"2020-10-12T11:29:19.586Z","comments":true,"path":"friends/friends.html","permalink":"https://kelecn.top/friends/friends.html","excerpt":"友链","text":"友链 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"}],"posts":[{"title":"精简代码：改换运算符","slug":"15、精简代码：改换运算符","date":"2020-08-22T13:57:00.000Z","updated":"2020-10-12T08:37:56.436Z","comments":true,"path":"2020/08/22/15、精简代码：改换运算符/","link":"","permalink":"https://kelecn.top/2020/08/22/15%E3%80%81%E7%B2%BE%E7%AE%80%E4%BB%A3%E7%A0%81%EF%BC%9A%E6%94%B9%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"简介： 精简代码：改换运算符","text":"简介： 精简代码：改换运算符 1、位运算（&amp;）替换取余（%）运算即：如果Y =,则X%Y可以变化为X&amp;(Y-1)由于我们知道位运算比较高效，在某些情况下，当b为2的n次方时，有如下替换公式：a % b = a &amp; (b-1)(b=2^n)即：a % 2^n = a &amp; (2^n-1)例如：14%8，取余数，相当于取出低位，而余数最大为7，14二进制为1110，8的二进制1000，8-1 = 7的二进制为0111，由于现在低位全为1，让其跟14做&amp;运算，正好取出的是其低位上的余数。1110&amp;0111=110即6=14%8；（此公式只适用b=2^n，是因为可以保证b始终只有最高位为1，其他二进制位全部为0，减去1，之后，可以把高位1消除，其他位都为1，而与1做&amp;运算，会保留原来的数。） 2、左移运算（&lt;&lt;）替换乘法（*）运算a=a8;b=b/8;可以改为：a=a&lt;&lt;3;b=b&gt;&gt;3;说明：除2 = 右移1位； 乘2 = 左移1位除4 = 右移2位； 乘4 = 左移2位除8 = 右移3位； 乘8 = 左移3位通常如果需要乘以或除以2的n次方，都可以用移位的方法代替，大部分的C编译器,用移位的方法得到代码比调用乘除法子程序生成的代码效率高。实际上，只要是乘以或除以一个整数才可以用移位的方法得到结果。如：a=a9 =a(8+1)=a8+a1可以改为：a=(a&lt;&lt;3)+a如：a=a7 =a(8-1)=a8-a1**可以改为：**a=(a&lt;&lt;3)-a**总结：a=an; n分解成(2^m + s),则a=an可以改为a=(a&lt;&lt;m)+as;as再同理分解替换。**例：a=a10 =&gt; a=a(8+2) =&gt; a=a8 + a2 =&gt; a=(a&lt;&lt;3)+(a&lt;&lt;1) 3、右移运算（&gt;&gt;）替换除法（/）运算a=a*8;b=b/8;可以改为：a=a&lt;&lt;3;b=b&gt;&gt;3;说明：除2 = 右移1位； 乘2 = 左移1位除4 = 右移2位； 乘4 = 左移2位除8 = 右移3位； 乘8 = 左移3位通常如果需要乘以或除以2的n次方，都可以用移位的方法代替，大部分的C编译器,用移位的方法得到代码比调用乘除法子程序生成的代码效率高。实际上，只要是乘以或除以一个整数才可以用移位的方法得到结果。如：a=a/9 =a/(8+1)=a/8+a/1可以改为：a=(a&gt;&gt;3)+a如：a=a/7 =a/(8-1)=a/8-a/1可以改为：a=(a&gt;&gt;3)-a总结：a=a/n; n分解成(2^m + s),则a=a/n可以改为a=(a&gt;&gt;m)+a/s;a/s再同理分解替换。例：a=a/10 =&gt; a=a/(8+2) =&gt; a=a/8 + a/2 =&gt; a=(a&gt;&gt;3)+(a&gt;&gt;1) 4、C/C++中的移位操作容易出错的情况： 什么样的数据类型可以直接移位 只有整型数据才能用移位替代乘除法，如：char、short、int、long、unsigned char、unsigned short、unsigned int、unsigned long。（double、float、bool、long double则不可以进行移位操作。） 有符号数据类型移位需要注意符号位对于char、short、int、long这些有符号的数据类型：对负数进行左移：符号位始终为1，其他位左移。对正数进行左移：所有位左移，即 &lt;&lt;，可能会变成负数对负数进行右移：取绝对值，然后右移，再取相反数对正数进行右移：所有位右移，即 &gt;&gt; 无符号数据类型的移位操作对于unsigned char、unsigned short、unsigned int、unsigned long这些无符号数据类型：没有特殊要说明的，使用&lt;&lt; 和 &gt;&gt; 操作符就OK了。5、参考资料： 使用位运算替换取余操作 移位操作与乘除法的关系","categories":[{"name":"知识","slug":"知识","permalink":"https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://kelecn.top/tags/C/"},{"name":"ARM","slug":"ARM","permalink":"https://kelecn.top/tags/ARM/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://kelecn.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"C","slug":"C","permalink":"https://kelecn.top/tags/C/"},{"name":"单片机","slug":"单片机","permalink":"https://kelecn.top/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"}]},{"title":"基于PicGo的GitHub图床","slug":"14、我的GitHub图床（基于PicGo）","date":"2020-08-18T13:57:00.000Z","updated":"2020-10-12T03:38:07.223Z","comments":true,"path":"2020/08/18/14、我的GitHub图床（基于PicGo）/","link":"","permalink":"https://kelecn.top/2020/08/18/14%E3%80%81%E6%88%91%E7%9A%84GitHub%E5%9B%BE%E5%BA%8A%EF%BC%88%E5%9F%BA%E4%BA%8EPicGo%EF%BC%89/","excerpt":"简介：GitHub图床（基于PicGo）","text":"简介：GitHub图床（基于PicGo） GitHub图床（基于PicGo）1. 首先你得有一个GitHub账号。注册GitHub就不用我多言。2. 新建一个仓库 记下你取的仓库名。 3. 生成一个token用于PicGo操作你的仓库：访问：https://github.com/settings/tokens 然后点击Generate new token。 把repo的勾打上即可。然后翻到页面最底部，点击Generate token的绿色按钮生成token。 注意：这个token生成后只会显示一次！你要把这个token复制一下存到其他地方以备以后要用。 4. 配置PicGo注意：仓库名的格式是用户名/仓库，比如我创建了一个叫做test的仓库，在PicGo里我要设定的仓库名就是kelecn/images。一般我们选择master分支即可。然后记得点击确定以生效，然后可以点击设为默认图床来确保上传的图床是GitHub。 12345678//PicGo配置&#123; &quot;repo&quot;: &quot;&quot;, // 仓库名，格式是username/reponame &quot;token&quot;: &quot;&quot;, // github token &quot;path&quot;: &quot;&quot;, // 自定义存储路径，比如img/ &quot;customUrl&quot;: &quot;&quot;, // 自定义域名，注意要加http://或者https:// &quot;branch&quot;: &quot;&quot; // 分支名，默认是master&#125; 至此配置完毕，已经可以使用了。当你上传的时候，你会发现你的仓库里也会增加新的图片了： 更多图床设计：请参考PicGo官方手册","categories":[{"name":"技术","slug":"技术","permalink":"https://kelecn.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://kelecn.top/tags/Hexo/"},{"name":"相册","slug":"相册","permalink":"https://kelecn.top/tags/%E7%9B%B8%E5%86%8C/"},{"name":"图床","slug":"图床","permalink":"https://kelecn.top/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"Github","slug":"Github","permalink":"https://kelecn.top/tags/Github/"},{"name":"PicGo","slug":"PicGo","permalink":"https://kelecn.top/tags/PicGo/"}]},{"title":"测试相册功能","slug":"13、测试","date":"2020-07-10T13:57:00.000Z","updated":"2020-10-13T05:36:19.476Z","comments":true,"path":"2020/07/10/13、测试/","link":"","permalink":"https://kelecn.top/2020/07/10/13%E3%80%81%E6%B5%8B%E8%AF%95/","excerpt":"","text":"二次元壁纸日常旅游","categories":[{"name":"日记","slug":"日记","permalink":"https://kelecn.top/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://kelecn.top/tags/Hexo/"},{"name":"相册","slug":"相册","permalink":"https://kelecn.top/tags/%E7%9B%B8%E5%86%8C/"},{"name":"Kelecn","slug":"Kelecn","permalink":"https://kelecn.top/tags/Kelecn/"}]},{"title":"ARM处理器7种工作模式","slug":"12、ARM处理器7种工作模式","date":"2020-06-11T13:47:00.000Z","updated":"2020-10-12T03:37:46.978Z","comments":true,"path":"2020/06/11/12、ARM处理器7种工作模式/","link":"","permalink":"https://kelecn.top/2020/06/11/12%E3%80%81ARM%E5%A4%84%E7%90%86%E5%99%A87%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/","excerpt":"简介：ARM处理器7种工作模式（特权模式，异常模式，用户模式）。","text":"简介：ARM处理器7种工作模式（特权模式，异常模式，用户模式）。 ARM处理器7种工作模式（特权模式，异常模式，用户模式）用户模式（USR）：正常程序执行模式，不能直接切换到其他模式系统模式（SYS）：运行操作系统的特权任务，与用户模式类似，但具有可以直接切换到其他模式等特权快中断模式（FIQ）：支持高速数据传输及通道处理，FIQ异常响应时进入此模式中断模式（IRQ）：用于通用中断处理，IRQ异常响应时进入此模式管理模式（SVC）：操作系统保护模式，系统复位和软件中断响应时进入此模式（由系统调用执行软中断SWI命令触发）中止模式（ABT）：用于支持虚拟内存和/或存储器保护，在ARM7TDMI没有大用处未定义模式（UND）：支持硬件协处理器的软件仿真，未定义指令异常响应时进入此模式 7种工作模式分类： 除用户模式外，其余6种工作模式都属于特权模式 特权模式中除了系统模式以外的其余5种模式称为异常模式 大多数程序运行于用户模式 进入特权模式是为了处理中断、异常、或者访问被保护的系统资源 硬件权限级别：系统模式 &gt; 异常模式 &gt; 用户模式快中断与慢中断区别：快中断处理时禁止中断","categories":[{"name":"知识","slug":"知识","permalink":"https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"ARM","slug":"ARM","permalink":"https://kelecn.top/tags/ARM/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://kelecn.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"处理器","slug":"处理器","permalink":"https://kelecn.top/tags/%E5%A4%84%E7%90%86%E5%99%A8/"},{"name":"硬件","slug":"硬件","permalink":"https://kelecn.top/tags/%E7%A1%AC%E4%BB%B6/"}]},{"title":"C++与Java多态的区别","slug":"11、C++与Java多态的区别","date":"2020-06-06T13:40:00.000Z","updated":"2020-10-03T07:49:41.989Z","comments":true,"path":"2020/06/06/11、C++与Java多态的区别/","link":"","permalink":"https://kelecn.top/2020/06/06/11%E3%80%81C++%E4%B8%8EJava%E5%A4%9A%E6%80%81%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"简介：C++与Java多态的区别。","text":"简介：C++与Java多态的区别。 多态是指用父指针指向不同子类对象时，调用其共有的函数，不同的子类会有不同的行为。虽然C++和Java都具有多态机制，但是他们的实现不同，使用时的效果也会略有不同。在C++中 普通函数调用：具体调用哪个方法在编译时就可以决定(通过查找编译器的符号表)，同时在使用标准过程调用机制基础上增加一个表示对象身份的指针(this指针)。 虚函数调用：函数调用依赖于对象的实际类型，一般地说，对象的实际类型只能在运行时间才能确定。实现机制是使用virtual table(vtbls)和virtual table pointers(vptrs)。 vtbl 是由函数指针构成的数组或链表，程序中每一个class凡声明(或继承)虚函数者，都有一个自己的vtbl，其中的条目就是该class的各个虚函数实现的指针。因此必须为每一个class消耗一个vtbl空间，其大小视虚函数的个数确定。 凡声明有虚函数的class，其对象都有一个隐藏的data member，用来指向class的vtbl。 当多态发生时，编译器首先根据对象vptr找出其vtbl，然后找出vtbl内对应的函数指针，最后调用函数指针指向的函数。从而实现多态。 在Java中1.C++中VTable和vptr是在编译阶段由编译器自动生成的，也就是说，在C++程序载入内存以前，在.obj（.o）文件中已经有这些结构的信 息；Java中的方法表是由JVM生成的，因此，使用javac命令编译后生成的.class文件中并没有方法表的信息。只有等JVM把.class文件 载入到内存中时，才会为该.class文件动态生成一个与之关联的方法表，放置在JVM的方法区中。 2.C++中某个方法在VTable的索引号是在编译阶段已经明确知道的，并不需要在运行过程中动态获知；Java中的方法初始时都只是一个符号，并不是 一个明确的地址，只有等到该方法被第一次调用时，才会被解析成一个方法表中的偏移量，也就是说，只有在这个时候，实例方法才明确知道自己在方发表中的偏移 量了，在这之前必须经历一个解析的过程。 因此在构造函数是Java会发生多态，即使子类此时还没有构造完全（一个极难发现的bug）。而C++则不会发生多态，待父类构造完全，在构造子类。Java代码如下： 123456789101112131415161718192021222324252627public class A &#123; public void fun() &#123; System.out.println(&quot;A&quot;); &#125; public A() &#123; this.fun(); &#125;&#125;public class B extends A&#123; public void fun() &#123; System.out.println(&quot;B&quot;); &#125; public B() &#123; fun(); &#125; public static void main(String [] argv) &#123; B b = new B(); &#125;&#125;//B//B C++代码如下： 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;using namespace std;class A&#123; public: virtual void fun() &#123; cout&lt;&lt;&quot;A&quot;&lt;&lt;endl; &#125; A() &#123; fun(); &#125;&#125;;class B : A&#123; public: virtual void fun() &#123; cout&lt;&lt;&quot;B&quot;&lt;&lt;endl; &#125; B() &#123; fun(); &#125; &#125;;int main(int argc, char *argv[])&#123; B b;&#125;//A//B 可以发现，C++构造子类时，先构造父类，输出A，然后在构造自身，输出B。而Java在构造子类时，父类并未构造完成，但已经可以发生多态输出B，然后再构造自身，输出B。Java一般为了避免这种情况，会把fun等init()函数声明为private或者finial。","categories":[{"name":"知识","slug":"知识","permalink":"https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"https://kelecn.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"C++","slug":"C","permalink":"https://kelecn.top/tags/C/"},{"name":"代码","slug":"代码","permalink":"https://kelecn.top/tags/%E4%BB%A3%E7%A0%81/"},{"name":"编程","slug":"编程","permalink":"https://kelecn.top/tags/%E7%BC%96%E7%A8%8B/"},{"name":"Java","slug":"Java","permalink":"https://kelecn.top/tags/Java/"}]},{"title":"C++重载注意点","slug":"10、重载注意点","date":"2020-05-20T13:30:00.000Z","updated":"2020-10-12T03:37:34.274Z","comments":true,"path":"2020/05/20/10、重载注意点/","link":"","permalink":"https://kelecn.top/2020/05/20/10%E3%80%81%E9%87%8D%E8%BD%BD%E6%B3%A8%E6%84%8F%E7%82%B9/","excerpt":"简介：C++重载注意点。","text":"简介：C++重载注意点。 1.调用函数在前，定义函数在后，进行原型声明2.函数重载注意：参数类型和个数相同，参数顺序不同，也可以重载12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;iomanip&gt; using namespace std; void print(int a,double b);//调用函数在前，定义函数在后，进行原型声明void print (double b,int a);//调用函数在前，定义函数在后，进行原型声明 int main()&#123; int x=8; double y=8; print(x,y); print(y,x); return 0;&#125;void print(int a,double b)&#123; cout&lt;&lt;showpoint&lt;&lt;&quot;1&quot;&lt;&lt;a&lt;&lt;b&lt;&lt;endl;&#125; void print (double b,int a)&#123; cout&lt;&lt;showpoint&lt;&lt;&quot;2&quot;&lt;&lt; a&lt;&lt;b &lt;&lt;endl; &#125; 3.C++中cout输出字符型指针地址值的方法1234567891011//C++中cout输出字符型指针地址值的方法//若要打印地址请用void*，否则 p会被认为是字符串。原因：运算符重载的匹配规则 #include&lt;iostream&gt; using namespace std; int main() &#123; char a; char *p=&amp;a; cout&lt;&lt;(void*)p&lt;&lt;endl&lt;&lt;a&lt;&lt;endl; &#125;","categories":[{"name":"知识","slug":"知识","permalink":"https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"https://kelecn.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"C++","slug":"C","permalink":"https://kelecn.top/tags/C/"},{"name":"代码","slug":"代码","permalink":"https://kelecn.top/tags/%E4%BB%A3%E7%A0%81/"},{"name":"编程","slug":"编程","permalink":"https://kelecn.top/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"C++返回对象和返回引用","slug":"9、C++返回对象和返回引用","date":"2020-04-19T13:20:07.000Z","updated":"2020-10-12T03:37:21.578Z","comments":true,"path":"2020/04/19/9、C++返回对象和返回引用/","link":"","permalink":"https://kelecn.top/2020/04/19/9%E3%80%81C++%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%BF%94%E5%9B%9E%E5%BC%95%E7%94%A8/","excerpt":"简介：C++返回对象和返回引用。","text":"简介：C++返回对象和返回引用。 我们发现，在C++中，有些成员函数返回的是对象，而有些函数返回的又是引用。 返回对象和返回引用的最主要的区别就是函数原型和函数头。 123Car run(const Car &amp;) //返回对象Car &amp; run(const Car &amp;) //返回引用 ​ 返回对象会涉及到生成返回对象的副本。因此，返回对象的时间成本包括了调用复制构造函数来生成副本所需的时间和调用析构函数删除副本所需的时间。返回引用可以节省时间和内存。直接返回对象与按值传递对象类似，他们都生成临时副本。同样，返回引用与按引用传递对象类似，调用和被调用的函数对同一个对象进行操作。 ​ 并不是总是可以返回引用的。比如函数不能返回在函数中创建的临时对象的引用。因为当函数结束调用时，临时对象将消失，因此这种引用是非法的。在这种情况下，应返回对象，以生成一个调用程序可以使用的副本。","categories":[{"name":"知识","slug":"知识","permalink":"https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"https://kelecn.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"C++","slug":"C","permalink":"https://kelecn.top/tags/C/"},{"name":"代码","slug":"代码","permalink":"https://kelecn.top/tags/%E4%BB%A3%E7%A0%81/"},{"name":"编程","slug":"编程","permalink":"https://kelecn.top/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"关于free和delete的使用","slug":"8、关于free和delete的使用","date":"2020-03-29T13:10:00.000Z","updated":"2020-10-12T03:37:06.416Z","comments":true,"path":"2020/03/29/8、关于free和delete的使用/","link":"","permalink":"https://kelecn.top/2020/03/29/8%E3%80%81%E5%85%B3%E4%BA%8Efree%E5%92%8Cdelete%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"简介：关于free和delete的使用","text":"简介：关于free和delete的使用 两个同时存在是有它的原因的，free是函数，它只释放内存，但不会调用析构函数，如果用free去释放new申请的空间，会因为无法调用析构函数而出现不必要的错误。 12345678char *point = (char *) malloc(100); strcpy(point, “hello”); free(point); // Be careful here，point 所指的内存被释放，but point 所指的地址仍然不变 … if(point != NULL) // 没有起到防错作用 &#123; strcpy(point, “jackery”); // error &#125; 这段程序中，原来free和delete只是把指针所指的内存给释放掉，但并没有把指针本身干掉。指针point被free以后其地址仍然不变（非NULL），只是该地址对应的内存是垃圾，point成了“野指针”。如果此时不把point设置为NULL，会让人误以为point是个合法的指针。如果程序比较长，我们有时记不住 point 所指的内存是否已经被释放，在继续使用point 之前，通常会用语句if (p != NULL)进行防错处理。很遗憾，此时if语句起不到防错作用，因为即便point不是NULL指针，它也不指向合法的内存块。为了避免失误，最好在free之后或者之前，将指针指向NULL new()/delete()与 malloc()/free() 区别1.malloc()/free() 是标准库函数， 使用前需调用库头文件 &lt;stdlib.h&gt; 方可使用；而 new/delete 是运算 符，执行效率更高。 2.malloc() 需要手工计算字节数；而 new 能够自动计算需要分配的内存空间。 3.malloc() 返回的指针是 void 类型；而 new*返回的指针是它分配空间的类型。 4.new 时调用构造函数，而 malloc() 不能；delete 时调用析构函数，而 free() 不能。 5.new 在申请单个类型变量时可以赋初值，而 malloc() 不具备。","categories":[{"name":"知识","slug":"知识","permalink":"https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"https://kelecn.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"C++","slug":"C","permalink":"https://kelecn.top/tags/C/"},{"name":"代码","slug":"代码","permalink":"https://kelecn.top/tags/%E4%BB%A3%E7%A0%81/"},{"name":"编程","slug":"编程","permalink":"https://kelecn.top/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"常量指针与指针常量","slug":"7、常量指针与指针常量","date":"2020-03-11T13:07:00.000Z","updated":"2020-10-12T03:36:55.408Z","comments":true,"path":"2020/03/11/7、常量指针与指针常量/","link":"","permalink":"https://kelecn.top/2020/03/11/7%E3%80%81%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F/","excerpt":"简介：常量指针与指针常量的区别。","text":"简介：常量指针与指针常量的区别。 常量指针(被指向的对象是常量)定义：又叫常指针，可以理解为常量的指针，指向的是个常量 关键点： 常量指针指向的对象不能通过这个指针来修改，可是仍然可以通过原来的声明修改； 常量指针可以被赋值为变量的地址，之所以叫常量指针，是限制了通过这个指针修改变量的值； 指针还可以指向别处，因为指针本身只是个变量，可以指向任意地址； 代码形式：1int const* p; const int* p; 12345678910111213141516#include &lt;stdio.h&gt;// 常量指针(被指向的对象是常量)int main() &#123; int i = 10; int i2 = 11; const int *p = &amp;i; printf(&quot;%d\\n&quot;, *p);//10 i = 9; //OK,仍然可以通过原来的声明修改值， //Error,*p是const int的，不可修改，即常量指针不可修改其指向地址 //*p = 11; //error: assignment of read-only location ‘*p’ p = &amp;i2;//OK,指针还可以指向别处，因为指针只是个变量，可以随意指向； printf(&quot;%d\\n&quot;, *p);//11 return 0;&#125; 指针常量(指针本身是常量)定义：本质是一个常量，而用指针修饰它。指针常量的值是指针，这个值因为是常量，所以不能被赋值。 关键点： 它是个常量！ 指针所保存的地址可以改变，然而指针所指向的值却不可以改变； 指针本身是常量，指向的地址不可以变化,但是指向的地址所对应的内容可以变化； 代码形式：1int* const p; 1234567891011121314//指针常量(指针本身是常量)#include &lt;stdio.h&gt;int main() &#123; int i = 10; int *const p = &amp;i; printf(&quot;%d\\n&quot;, *p);//10 //Error,因为p是const 指针，因此不能改变p指向的内容 //p++;//error: increment of read-only variable ‘p’ (*p)++; //OK,指针是常量，指向的地址不可以变化,但是指向的地址所对应的内容可以变化 printf(&quot;%d\\n&quot;, *p);//11 i = 9;//OK,仍然可以通过原来的声明修改值， return 0;&#125; 如何区分常量指针和指针常量 一种方式是看 * 和 const 的排列顺序，比如 123int const* p; //const * 即常量指针const int* p; //const * 即常量指针int* const p; //* const 即指针常量 还一种方式是看const离谁近，即从右往左看，比如 123int const* p; //const修饰的是*p，即*p的内容不可通过p改变，但p不是const，p可以修改，*p不可修改；const int* p; //同上int* const p; //const修饰的是p，p是指针，p指向的地址不能修改，p不能修改，但*p可以修改；","categories":[{"name":"知识","slug":"知识","permalink":"https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"https://kelecn.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"C++","slug":"C","permalink":"https://kelecn.top/tags/C/"},{"name":"代码","slug":"代码","permalink":"https://kelecn.top/tags/%E4%BB%A3%E7%A0%81/"},{"name":"编程","slug":"编程","permalink":"https://kelecn.top/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"编程过程中遇到的一些问题总结（C++&Java）","slug":"6、编程过程中遇到的一些问题总结（C++&Java）","date":"2020-02-18T02:05:00.000Z","updated":"2020-10-12T03:36:48.303Z","comments":true,"path":"2020/02/18/6、编程过程中遇到的一些问题总结（C++&Java）/","link":"","permalink":"https://kelecn.top/2020/02/18/6%E3%80%81%E7%BC%96%E7%A8%8B%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88C++&Java%EF%BC%89/","excerpt":"简介：（C++&amp;Java）问题总结。","text":"简介：（C++&amp;Java）问题总结。 1.Java中的boolean类型变量，只有两个值true ,false；C++也是，不过也可以用 1 0 代替。 12345678//Java boolean 类型public class HelloWorld &#123; public static void main(String[] args) &#123; while (true) &#123; System.out.println(&quot;I Love YOU!&quot;); &#125; &#125;&#125; 1234567891011//C++ boolean 类型#include &lt;iostream&gt;using namespace std;int main(int argc, char *argv[])&#123; while (1) &#123; cout&lt;&lt;&quot;I Love YOU!&quot;&lt;&lt;endl; &#125; return 0;&#125; 2.Java一个类中的boolean类型变量，一般用isXxx()类型获取私有变量Xxx； 注：get开头的方法，一般都表示返回某一个属性值；is开头的方法，一般都是用来表示判断某某内容。 123public boolean isSex() &#123; return sex; &#125;","categories":[{"name":"总结","slug":"总结","permalink":"https://kelecn.top/categories/%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"https://kelecn.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"C++","slug":"C","permalink":"https://kelecn.top/tags/C/"},{"name":"编程","slug":"编程","permalink":"https://kelecn.top/tags/%E7%BC%96%E7%A8%8B/"},{"name":"Java","slug":"Java","permalink":"https://kelecn.top/tags/Java/"}]},{"title":"JAVA测试题","slug":"5、JAVA测试题","date":"2020-02-07T02:05:00.000Z","updated":"2020-10-12T03:36:37.841Z","comments":true,"path":"2020/02/07/5、JAVA测试题/","link":"","permalink":"https://kelecn.top/2020/02/07/5%E3%80%81JAVA%E6%B5%8B%E8%AF%95%E9%A2%98/","excerpt":"简介：JAVA基础测试题。","text":"简介：JAVA基础测试题。 第一题输出9*9口诀表。 代码： 12345678910111213141516package exam;public class Exam &#123; public static void main(String[] args) &#123; for(int i = 1; i &lt; 10; i ++) &#123; for( int j = 1; j &lt;= i; j++) &#123; System.out.print(i +&quot; * &quot;+j+&quot; = &quot;+i*j + &quot; &quot;); &#125; System.out.println();//换行 &#125; &#125;&#125; 运行截图： 第二题求1+2!+3!+…+20!的和。 代码： 12345678910111213141516package exam;public class Exam &#123; public static void main(String[] args) &#123; float s=0,t=1; int n; for (n=1;n&lt;=20;n++) &#123; t=t*n; // 求n! s=s+t; // 将各项累加 &#125; System.out.println(&quot;1+2!+3!+...+20!=&quot;+s); &#125; &#125; 运行截图： 第三题一个5位数，判断它是不是回文数。即12321是回文数，个位与万位相同，十位与千位相同。 代码： 123456789101112131415161718192021222324package exam;import java.util.Scanner;public class Exam &#123; public static void main(String[] args) &#123; int ge,shi,qian,wan,x; System.out.println(&quot;请输入您想判断的五位数字：&quot;); Scanner in = new Scanner(System.in); x=in.nextInt(); wan=x/10000;//万位 qian=x%10000/1000;//千位 shi=x%100/10;//十位 ge=x%10;//个位 if (ge==wan&amp;&amp;shi==qian)//个位等于万位并且十位等于千位 &#123; System.out.println(&quot;这是回文数\\n&quot;); &#125; else &#123; System.out.println(&quot;这是不是回文数\\n&quot;); &#125; &#125; &#125; 运行截图： 第四题一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在第10次落地时，共经过多少米？第10次反弹多高？ 代码： 1234567891011121314151617package exam;public class Exam &#123; public static void main(String[] args) &#123; double sum = 0, high = 100;//sum为路径总和，high表示当前高度 for (int i = 0; i &lt; 10; i++) &#123; sum = high + high / 2 + sum;//一次落地距离+弹起距离+已经过路程 high /= 2;//弹起高度为一半 &#125; sum -= high;//求第10次落地经过路程需减去第10次弹起距离 System.out.println(&quot;共经过：&quot;+sum+ &quot;米\\n&quot;+&quot;第10次反弹高度为：&quot;+high+&quot;米&quot;); &#125; &#125; 运行截图： 第五题猴子吃桃问题：猴子第一天摘下若干个桃子，当即吃了一半，还不过瘾，又多吃了一个; 第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下的一半零一个。到第10天早上想再吃时，见只剩下一个桃子了。求第一天共摘了多少。 代码： 123456789101112131415package exam;public class Exam &#123; public static void main(String[] args) &#123; int x = 1;//第十天剩余桃子数 int y;//天数 for(y=1;y&lt;=9;y++) &#123; x=(x+1)*2;//前一天的剩余桃子数都是今天剩余桃子数加1后的两倍 &#125; System.out.println(&quot;猴子第一天一共摘了&quot;+x+&quot;个桃子。&quot;); &#125; &#125; 运行截图：","categories":[{"name":"知识","slug":"知识","permalink":"https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"https://kelecn.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"代码","slug":"代码","permalink":"https://kelecn.top/tags/%E4%BB%A3%E7%A0%81/"},{"name":"编程","slug":"编程","permalink":"https://kelecn.top/tags/%E7%BC%96%E7%A8%8B/"},{"name":"Java","slug":"Java","permalink":"https://kelecn.top/tags/Java/"}]},{"title":"面向对象的程序设计实验（C++）","slug":"4、面向对象的程序设计","date":"2019-12-25T02:51:34.000Z","updated":"2020-10-12T03:36:26.619Z","comments":true,"path":"2019/12/25/4、面向对象的程序设计/","link":"","permalink":"https://kelecn.top/2019/12/25/4%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/","excerpt":"简介：面向对象程序设计（C++）。","text":"简介：面向对象程序设计（C++）。 还没写呢^_^","categories":[{"name":"知识","slug":"知识","permalink":"https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"https://kelecn.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"C++","slug":"C","permalink":"https://kelecn.top/tags/C/"},{"name":"代码","slug":"代码","permalink":"https://kelecn.top/tags/%E4%BB%A3%E7%A0%81/"},{"name":"编程","slug":"编程","permalink":"https://kelecn.top/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"嵌入式开发为什么选择C语言？","slug":"3、嵌入式开发为什么选择C语言？","date":"2019-11-25T09:08:29.000Z","updated":"2020-10-12T03:35:46.193Z","comments":true,"path":"2019/11/25/3、嵌入式开发为什么选择C语言？/","link":"","permalink":"https://kelecn.top/2019/11/25/3%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9C%E8%AF%AD%E8%A8%80%EF%BC%9F/","excerpt":"简介:嵌入式+C语言=？","text":"简介:嵌入式+C语言=？ 1.从语言特点来说①C语言有出色的可移植性，能在多种不同体系结构的软/硬平台上运行。 ②简洁紧凑，使用灵活的语法机制，并能直接访问硬件能够直接访问硬件的语言有：汇编和C语言汇编属于低级语言，难以完成一些复杂的功能，但是汇编比C语言访问硬件的效率更高。所以，一般将硬件初始化的工作交给汇编，比较复杂的操作交给C语言。 ③C语言具有很高的运行效率。 2.嵌入式开发中的地位——开发工具3.高级语言中的低级语言：面向过程VS面向对象面向过程：“面向过程”(Procedure Oriented)是一种以过程为中心的编程思想。“面向过程”也可称之为“面向记录”编程思想，他们不支持丰富的“面向对象”特性(比如继承、多态)，并且它们不允许混合持久化状态和域逻辑。 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。面向过程其实是最为实际的一种思考方式,就算是面向对象的方法也是含有面向过程的思想。 可以说面向过程是一种基础的方法，它考虑的是实际地实现。一般的面向过程是从上往下步步求精，所以面向过程最重要的是模块化的思想方法。 面向对象：面向对象的分析根据抽象关键的问题域来分解系统。面向对象的设计是一种提供符号设计系统的面向对象的实现过程，它用非常接近实际领域术语的方法把系统构造成“现实世界”的对象。 面向对象程序设计可以看作一种在程序中包含各种独立而又互相调用的对象的思想，这与传统的思想刚好相反：传统的程序设计主张将程序看作一系列函数的集合，或者直接就是一系列对电脑下达的指令。面向对象程序设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象，因此它们都可以被看作一个小型的“机器”，即对象。 面向过程和面向对象的区别：以一个人从A地到B地为例，面向过程就是需要规划路线，了解路况，自己做好一系列的准备;而面向对象就是坐上一辆出租车，告诉司机我要去B地就可以了，不用关心其他的事情。 最后，C语言也有他自身的缺陷，比如代码的复用性差，代码的维护性差，扩展性(新增代码时不改变原来的代码)很差。","categories":[{"name":"知识","slug":"知识","permalink":"https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://kelecn.top/tags/%E7%BC%96%E7%A8%8B/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://kelecn.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"硬件","slug":"硬件","permalink":"https://kelecn.top/tags/%E7%A1%AC%E4%BB%B6/"},{"name":"C语言","slug":"C语言","permalink":"https://kelecn.top/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"Matlab Gui关于edit keypressfcn的响应","slug":"2、Matlab gui关于edit keypressfcn的响应","date":"2019-10-02T04:00:00.000Z","updated":"2020-10-12T03:43:38.688Z","comments":true,"path":"2019/10/02/2、Matlab gui关于edit keypressfcn的响应/","link":"","permalink":"https://kelecn.top/2019/10/02/2%E3%80%81Matlab%20gui%E5%85%B3%E4%BA%8Eedit%20keypressfcn%E7%9A%84%E5%93%8D%E5%BA%94/","excerpt":"简介：Matlab GUI键盘输入。","text":"简介：Matlab GUI键盘输入。 1234567891011121314 function showmap fig=figure( &#x27;Name&#x27;,&#x27;Timer&#x27;,&#x27;Position&#x27;,[0,0,500,500] ,&#x27;NumberTitle&#x27;,&#x27;off&#x27;,&#x27;visible&#x27;,&#x27;off&#x27;); movegui(fig,&#x27;center&#x27;); set(fig,&#x27;visible&#x27;,&#x27;on&#x27;); ttext= uicontrol(&#x27;Style&#x27;,&#x27;edit&#x27;,&#x27;Position&#x27;,[150,250,200,30],&#x27;String&#x27;,&#x27;Press &quot;Start&quot;&#x27;,... &#x27;KeyPressFcn&#x27;,@keyPress); ii=0; function keyPress(x,y) set(ttext,&#x27;string&#x27;,num2str(ii)); ii = ii+1; endend 参考文献：打浦桥程序员","categories":[{"name":"技术","slug":"技术","permalink":"https://kelecn.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"代码","slug":"代码","permalink":"https://kelecn.top/tags/%E4%BB%A3%E7%A0%81/"},{"name":"Matlab","slug":"Matlab","permalink":"https://kelecn.top/tags/Matlab/"},{"name":"Gui","slug":"Gui","permalink":"https://kelecn.top/tags/Gui/"}]},{"title":"Kelecn的第一条博客！","slug":"1、可乐的第一条博客","date":"2019-09-19T09:10:00.000Z","updated":"2020-10-12T03:35:05.440Z","comments":true,"path":"2019/09/19/1、可乐的第一条博客/","link":"","permalink":"https://kelecn.top/2019/09/19/1%E3%80%81%E5%8F%AF%E4%B9%90%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9D%A1%E5%8D%9A%E5%AE%A2/","excerpt":"简介：您好！Hexo！","text":"简介：您好！Hexo！ 友情链接：My Github、Hexo","categories":[{"name":"生活","slug":"生活","permalink":"https://kelecn.top/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://kelecn.top/tags/Hexo/"},{"name":"Kelecn","slug":"Kelecn","permalink":"https://kelecn.top/tags/Kelecn/"},{"name":"日记","slug":"日记","permalink":"https://kelecn.top/tags/%E6%97%A5%E8%AE%B0/"}]}],"categories":[{"name":"知识","slug":"知识","permalink":"https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"},{"name":"技术","slug":"技术","permalink":"https://kelecn.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"日记","slug":"日记","permalink":"https://kelecn.top/categories/%E6%97%A5%E8%AE%B0/"},{"name":"总结","slug":"总结","permalink":"https://kelecn.top/categories/%E6%80%BB%E7%BB%93/"},{"name":"生活","slug":"生活","permalink":"https://kelecn.top/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://kelecn.top/tags/C/"},{"name":"ARM","slug":"ARM","permalink":"https://kelecn.top/tags/ARM/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://kelecn.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"C","slug":"C","permalink":"https://kelecn.top/tags/C/"},{"name":"单片机","slug":"单片机","permalink":"https://kelecn.top/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"Hexo","slug":"Hexo","permalink":"https://kelecn.top/tags/Hexo/"},{"name":"相册","slug":"相册","permalink":"https://kelecn.top/tags/%E7%9B%B8%E5%86%8C/"},{"name":"图床","slug":"图床","permalink":"https://kelecn.top/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"Github","slug":"Github","permalink":"https://kelecn.top/tags/Github/"},{"name":"PicGo","slug":"PicGo","permalink":"https://kelecn.top/tags/PicGo/"},{"name":"Kelecn","slug":"Kelecn","permalink":"https://kelecn.top/tags/Kelecn/"},{"name":"处理器","slug":"处理器","permalink":"https://kelecn.top/tags/%E5%A4%84%E7%90%86%E5%99%A8/"},{"name":"硬件","slug":"硬件","permalink":"https://kelecn.top/tags/%E7%A1%AC%E4%BB%B6/"},{"name":"面向对象","slug":"面向对象","permalink":"https://kelecn.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"代码","slug":"代码","permalink":"https://kelecn.top/tags/%E4%BB%A3%E7%A0%81/"},{"name":"编程","slug":"编程","permalink":"https://kelecn.top/tags/%E7%BC%96%E7%A8%8B/"},{"name":"Java","slug":"Java","permalink":"https://kelecn.top/tags/Java/"},{"name":"C语言","slug":"C语言","permalink":"https://kelecn.top/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"Matlab","slug":"Matlab","permalink":"https://kelecn.top/tags/Matlab/"},{"name":"Gui","slug":"Gui","permalink":"https://kelecn.top/tags/Gui/"},{"name":"日记","slug":"日记","permalink":"https://kelecn.top/tags/%E6%97%A5%E8%AE%B0/"}]}