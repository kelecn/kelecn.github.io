{"meta":{"title":"kelecn","subtitle":"","description":"","author":"kelecn","url":"https://kelecn.top","root":"/"},"pages":[{"title":"","date":"2020-10-05T08:38:07.556Z","updated":"2020-09-20T09:47:45.997Z","comments":true,"path":"404.html","permalink":"https://kelecn.top/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2020-10-14T04:17:17.581Z","updated":"2020-10-14T04:17:17.581Z","comments":true,"path":"about/index.html","permalink":"https://kelecn.top/about/index.html","excerpt":"","text":"关于 关于我 姓名：谢青桦 学校：广东工业大学 专业：电子信息科学与技术 地址：广东省--广州 QQ：1572535194 微信：kelecn_wx Github： kelecnhttps://github.com/kelecn BiliBili： kelecnhttps://space.bilibili.com/68452018 个人博客： kelecnhttps://kelecn.top/ 项目经历 基于ARM的无线数据采集系统--2020年08月-2020年09月 PIC超声波避障小车--2019年11月-2019年12月 纸张计数显示装置--2019年07月-2020年08月 专业技能 PIC单片机 STM32 模电+数电 EDA FPGA Matlab 编程能力 C：90% C++：80% Java ：60% Python ：20% 找工作中 ，应届生QAQ 期望工作：嵌入式软件工程师 期望薪酬：10K以上 期望工作地点：最好是广东省内，要是在珠海就再好不过了^_^"},{"title":"","date":"2020-10-13T05:56:04.201Z","updated":"2020-09-24T08:50:25.168Z","comments":true,"path":"about/me.html","permalink":"https://kelecn.top/about/me.html","excerpt":"","text":"主要涉及技术：嵌入式开发、电子设计、集成电路、通信、安卓开发、爬虫。一条普通的大四狗联系QQ:1572535194 很惭愧 只做了一点微小的工作 谢谢大家"},{"title":"","date":"2020-10-11T04:37:01.734Z","updated":"2020-09-20T09:40:11.246Z","comments":true,"path":"examples/index.html","permalink":"https://kelecn.top/examples/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2020-10-11T04:37:07.717Z","updated":"2020-09-20T09:38:42.299Z","comments":true,"path":"categories/index.html","permalink":"https://kelecn.top/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-10-11T04:36:53.594Z","updated":"2020-09-20T09:40:11.246Z","comments":true,"path":"faqs/index.html","permalink":"https://kelecn.top/faqs/index.html","excerpt":"","text":""},{"title":"","date":"2020-10-12T14:46:46.468Z","updated":"2020-10-12T11:29:19.586Z","comments":true,"path":"friends/friends.html","permalink":"https://kelecn.top/friends/friends.html","excerpt":"友链","text":"友链 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"","date":"2020-10-13T05:27:34.508Z","updated":"2020-10-13T05:27:34.508Z","comments":true,"path":"friends/index.html","permalink":"https://kelecn.top/friends/index.html","excerpt":"友链","text":"友链 主题作者+文档 XAOXUU山重水复疑无路，柳暗花明又一村 Volantis主题文档 技术大佬 XU'S BLOG银河小徐"},{"title":"","date":"2020-10-05T08:38:07.566Z","updated":"2020-09-23T10:47:25.648Z","comments":true,"path":"getting-started/index.html","permalink":"https://kelecn.top/getting-started/index.html","excerpt":"","text":""},{"title":"","date":"2020-10-13T05:30:57.409Z","updated":"2020-10-13T05:30:57.409Z","comments":true,"path":"image/index.html","permalink":"https://kelecn.top/image/index.html","excerpt":"","text":"相册 二次元壁纸日常旅游"},{"title":"","date":"2020-10-05T08:38:07.576Z","updated":"2020-09-20T09:40:11.246Z","comments":true,"path":"mylist/index.html","permalink":"https://kelecn.top/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-10-07T12:47:58.846Z","updated":"2020-10-07T12:47:41.342Z","comments":true,"path":"tags/index.html","permalink":"https://kelecn.top/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-10-13T05:28:03.696Z","updated":"2020-10-13T05:28:03.696Z","comments":true,"path":"tool/index.html","permalink":"https://kelecn.top/tool/index.html","excerpt":"工具","text":"工具 视频 真不卡影院真不卡电影网是一个免费看电影的网站 片库每日收集全网最新的电影、电视剧、动漫高清资源 蓝光影视蓝光影视 热门美剧 字幕分享 最好用的影视资源站 樱花动漫专注动漫的门户网站"}],"posts":[{"title":"几种常见的DCDC拓扑","slug":"18、几种常见的DCDC拓扑","date":"2020-08-28T13:50:00.000Z","updated":"2020-10-15T17:36:01.760Z","comments":true,"path":"2020/08/28/18、几种常见的DCDC拓扑/","link":"","permalink":"https://kelecn.top/2020/08/28/18%E3%80%81%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84DCDC%E6%8B%93%E6%89%91/","excerpt":"简介：开关电源三大基础拓扑解析：BUCK/BOOST/BUCK-BOOST","text":"简介：开关电源三大基础拓扑解析：BUCK/BOOST/BUCK-BOOST 1、Buck 拓扑电路 Buck电路是一个降压电路，Uin=Ul+Uo。因Uin&gt;Uo,故具有降压作用。 2、Boost拓扑电路 Boost电路是一个升压电路，Uo=Uin+Ul-Ud ,由于Ud值较小，忽略不计，Uin+Ui&gt;Uo,故具有升压作用。 3、Buck-Boost拓扑电路 其中的器件和Buck电路完全一致，只是开关SW，二极管和电感的位置发生了改变 Buck-Boost变换器输出的是相对地的负压 4、参考文献开关电源学习笔记1 — Buck变换器的基本原理 开关电源学习笔记2 — Boost变换器的基本原理 开关电源学习笔记3 — Buck-Boost变换器的基本原理开关电源三大基础拓扑解析：BUCK/BOOST/BUCK-BOOST","categories":[{"name":"知识","slug":"知识","permalink":"https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"Boost","slug":"Boost","permalink":"https://kelecn.top/tags/Boost/"},{"name":"Buck","slug":"Buck","permalink":"https://kelecn.top/tags/Buck/"},{"name":"DCDC","slug":"DCDC","permalink":"https://kelecn.top/tags/DCDC/"}]},{"title":"一文搞懂TCP与UDP的区别","slug":"17、一文搞懂TCP与UDP的区别","date":"2020-08-26T13:57:00.000Z","updated":"2020-10-15T04:57:03.253Z","comments":true,"path":"2020/08/26/17、一文搞懂TCP与UDP的区别/","link":"","permalink":"https://kelecn.top/2020/08/26/17%E3%80%81%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82TCP%E4%B8%8EUDP%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"简介：网络协议是每个IT工程师都必须要掌握的知识，TCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP，本文将介绍下这两者以及它们之间的区别。","text":"简介：网络协议是每个IT工程师都必须要掌握的知识，TCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP，本文将介绍下这两者以及它们之间的区别。 一、TCP/IP网络模型计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（protocol）。 TCP/IP 是互联网相关的各类协议族的总称，比如：TCP，UDP，IP，FTP，HTTP，ICMP，SMTP 等都属于 TCP/IP 族内的协议。 TCP/IP模型是互联网的基础，它是一系列网络协议的总称。这些协议可以划分为四层，分别为链路层、网络层、传输层和应用层。 链路层：负责封装和解封装IP报文，发送和接受ARP/RARP报文等。 网络层：负责路由以及把分组报文发送给目标网络或主机。 传输层：负责对报文进行分组和重组，并以TCP或UDP协议格式封装报文。 应用层：负责向用户提供应用程序，比如HTTP、FTP、Telnet、DNS、SMTP等。 在网络体系结构中网络通信的建立必须是在通信双方的对等层进行，不能交错。 在整个数据传输过程中，数据在发送端时经过各层时都要附加上相应层的协议头和协议尾（仅数据链路层需要封装协议尾）部分，也就是要对数据进行协议封装，以标识对应层所用的通信协议。接下去介绍TCP/IP 中有两个具有代表性的传输层协议—-TCP 和 UDP。 二、UDPUDP协议全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。 它有以下几个特点： 1. 面向无连接 首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。 具体来说就是： 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了 在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作 2. 有单播，多播，广播的功能 UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。 3. UDP是面向报文的 发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文 4. 不可靠性 首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。 并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。 再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。 从上面的动态图可以得知，UDP只会把想发的数据报文一股脑的丢给对方，并不在意数据有无安全完整到达。 5. 头部开销小，传输数据报文时是很高效的。 UDP 头部包含了以下几个数据： 两个十六位的端口号，分别为源端口（可选字段）和目标端口 整个数据报文的长度 整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误 因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的 三、TCP当一台计算机想要与另一台计算机通讯时，两台计算机之间的通信需要畅通且可靠，这样才能保证正确收发数据。例如，当你想查看网页或查看电子邮件时，希望完整且按顺序查看网页，而不丢失任何内容。当你下载文件时，希望获得的是完整的文件，而不仅仅是文件的一部分，因为如果数据丢失或乱序，都不是你希望得到的结果，于是就用到了TCP。 TCP协议全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的RFC 793定义。TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，你可以把它想象成排水管中的水流。 1. TCP连接过程 如下图所示，可以看到建立一个TCP连接的过程为（三次握手的过程）: 第一次握手 客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。 第二次握手 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。 第三次握手 当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。 这里可能大家会有个疑惑：为什么 TCP 建立连接需要三次握手，而不是两次？这是因为这是为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。 2. TCP断开链接 TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK。 第一次握手 若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。 第二次握手 B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。 第三次握手 B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。 第四次握手 A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。 3. TCP协议的特点 面向连接 面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。 仅支持单播传输 每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。 面向字节流 TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。 可靠传输 对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。 提供拥塞控制 当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞 TCP提供全双工通信 TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS） 四、TCP和UDP的比较1. 对比 UDP TCP 是否连接 无连接 面向连接 是否可靠 不可靠传输，不使用流量控制和拥塞控制 可靠传输，使用流量控制和拥塞控制 连接对象个数 支持一对一，一对多，多对一和多对多交互通信 只能是一对一通信 传输方式 面向报文 面向字节流 首部开销 首部开销小，仅8字节 首部最小20字节，最大60字节 适用场景 适用于实时应用（IP电话、视频会议、直播等） 适用于要求可靠传输的应用，例如文件传输 2. 总结 TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务。 虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为 对数据准确性要求高，速度可以相对较慢的，可以选用TCP 参考文章：一文搞懂TCP与UDP的区别 ​ TCP的三次握手与四次挥手理解及面试题（很全面）","categories":[{"name":"知识","slug":"知识","permalink":"https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"TCP","slug":"TCP","permalink":"https://kelecn.top/tags/TCP/"},{"name":"UDP","slug":"UDP","permalink":"https://kelecn.top/tags/UDP/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://kelecn.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"C语言基础知识（复习）","slug":"16、C语言基础知识（复习）","date":"2020-08-25T13:57:00.000Z","updated":"2020-10-15T17:07:18.462Z","comments":true,"path":"2020/08/25/16、C语言基础知识（复习）/","link":"","permalink":"https://kelecn.top/2020/08/25/16%E3%80%81C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E5%A4%8D%E4%B9%A0%EF%BC%89/","excerpt":"简介： 嵌入式笔试相关题目、考点。","text":"简介： 嵌入式笔试相关题目、考点。 1、static修饰的局部变量、全局变量、函数1）、用于声明函数体内的变量为静态局部变量，存储在静态数据存储区，在函数被调用过程中维持其值保持不变。2）、在文件内（函数体外）被声明为静态的变量，可以被文件内的所有函数访问，但不能被其他文件的函数访问，是一个本地的局部变量。3）、在文件内,被声明为静态的函数只可被文件内的其他函数调用，但不能被其他文件的函数调用。 2、关键词const的理解常类型是指使用类型修饰符const说明的类型，常类型的变量或对象的值是不能被更新的。不管出现在任何上下文都是为这个目的而服务的。注意:非const变量默认为extern。要使const变量能够在其他文件中访问，必须在文件中显式地指定它为extern。 1234567891011121314151617const int a;//同上面的代码行是等价的，都表示一个常整形数。int const a;/* const具有&quot;左结合&quot;性，即const修饰*，那么，不难理解，该句表示一个指向整数的常指针， a指向的整数可以修改，但指针a不能修改。*/int *const a;/* 同理，下面的这两行，根据&quot;左结合&quot;性，const修饰的是(*a)，也即是一个整数， 所以，这两句表示指针指向一个常整数。*/const int *a;int const *a;//根据&quot;左结合&quot;性质，第一个const修饰(*)，第二个const修饰(a)，因此，这句话表示一个指向常整数的常指针。int const *a const; 123456789101112131415161718192021222324252627282930313233343536373839const char *p; //*p是const,p可变const (char *) p;//p是const,*p可变char* const p; //p是const,*p可变const char* const p; //p和*p都是constchar const * p;// *p是const,p可变(char*) const p;//p是const,*p可变char* const p;// p是const,*p可变char const* const p;// p和*p都是const//例如#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(void)&#123; //const修饰一个变量为只读 const int a = 10; //a = 100; //err //指针变量， 指针指向的内存， 2个不同概念 char buf[] = &quot;aklgjdlsgjlkds&quot;; //从左往右看，跳过类型，看修饰哪个字符 //如果是*， 说明指针指向的内存不能改变 //如果是指针变量，说明指针的指向不能改变，指针的值不能修改 const char *p = buf; // 等价于上面 char const *p1 = buf; //p[1] = &#x27;2&#x27;; //err p = &quot;agdlsjaglkdsajgl&quot;; //ok char * const p2 = buf; p2[1] = &#x27;3&#x27;; //p2 = &quot;salkjgldsjaglk&quot;; //err //p3为只读，指向不能变，指向的内存也不能变 const char * const p3 = buf; return 0;&#125; 3、数组越界问题123456void test()&#123; char string[10];//应该是char string[11];//字符串数组最后一位是\\0 char*str=&quot;0123456789&quot;; strcpy(string,str);//err&#125; 4、C语言中宏定义的使用==预处理==命令可以改变程序设计环境,提高编程效率,它们并不是 C 语言本身的组成部分,不能直接对 它们进行编译,必须在对程序进行编译之前,先对程序中这些特殊的命令进行“预处理” 。经过预处理后,程序就不再包括预处理命令了,最后再由编译程序对==预处理==之后的源程序进行==编译==处理,得到可供执行的目标代码。C 语言提供的预处理功能有三种,分别为==宏定义==、文件包含和条件编译。 12345678910111213141516171819202122232425262728293031323334353637// 不带参数的宏定义#define MAX 10/*带参宏定义*/#define M(y) y*y+3*y/*宏调用*/k=M(5);//宏定义最大值#include &lt;iostream&gt; using namespace std; #define max(a,b) (((a)&gt;(b))?(a):(b)) int main()&#123; cout &lt;&lt; max(1+1,2+2) &lt;&lt; endl; return 0;&#125;//这个面试题主要考查面试者对宏定义的使用，宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对“参数”进行的是一对一的替换。/* #define MAX( x, y ) ( ((x) &gt; (y)) ? (x) : (y) )//输入a++，a=a+2 调用两次#define MIN( x, y ) ( ((x) &lt; (y)) ? (x) : (y) )#define MAX( a, b ) (&#123;int _a = a;int _b = b;(_a) &gt; (_b)? (_a) :(_b); &#125;)*//*程序员对宏定义的使用要非常小心，特别要注意两个问题： （1）谨慎地将宏定义中的“参数”和整个宏用用括弧括起来。所以，严格地讲，下述解答：#define MIN(A,B) (A) &lt;= (B) ? (A) : (B)#define MIN(A,B) (A &lt;= B ? A : B ) 都应判0分； （2）防止宏的副作用。 宏定义#define MIN(A,B) ((A) &lt;= (B) ? (A) : (B))对MIN(*p++, b)的作用结果是：((*p++) &lt;= (b) ? (*p++) : (*p++)) 这个表达式会产生副作用，指针p会作三次++自增操作。 除此之外，另一个应该判0分的解答是：#define MIN(A,B) ((A) &lt;= (B) ? (A) : (B)); 不能在后面加冒号。 参考文章：宏定义正确处理a++ 5、递归算N！12345678910111213141516171819202122#include &lt;stdio.h&gt; long fac(int n) &#123; long f; if(n&lt;0) printf(&quot;n&lt;0,data error!&quot;); else if(n==0,n==1) f=1; else f = fac(n-1)*n; return (f); &#125; int main()&#123; long fac(int n); int n,y; printf(&quot;input an integer number:&quot;); scanf(&quot;%d&quot;,&amp;n); y= fac(n); printf(&quot;%d!=%ld\\n&quot;,n,y); return 0; &#125; 6、中断服务子程序(ISR)中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展-让标准C支持中断。其代表事实是，产生了一个新的关键字 interrupt（51即如此）。下面的代码就使用了interrupt关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码的。 12345678910111213141516171819202122__interrupt double compute_area (double radius) &#123; double area = PI * radius * radius; printf(&quot;/nArea = %f&quot;, area); return area; &#125;/*中断服务程序需要满足如下要求： (1)不能返回值； (2)不能向ISR传递参数； （嵌入式中的ISR指的是中断服务处理）(3) ISR应该尽可能的短小精悍； (4) printf(char * lpFormatString,…)函数会带来重入和性能问题，不能在ISR中采用。*/ 这个函数有太多的错误了，以至让人不知从何说起了（前提是非操作系统下的中断服务函数）： 1)ISR 不能返回一个值（都应该为void类型）。如果你不懂这个，那么你不会被雇用的。 2)ISR 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。 3)在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额外的寄存器入栈，有些处理器/编译器就是不允许在ISR中做浮点运算。此外，ISR应该是短而有效率的，在ISR中做浮点运算是不明智的。另外中断服务程序是运行在内核态的（linux），内核通常是不支持浮点运算的。 7、位运算符123456789101112//5=&gt;0101，7=&gt;01111)&amp; 按位与//5&amp;7==&gt;0101，也就是52)| 按位或//5|7==&gt;0111，也就是73)^ 按位异或//5^7==&gt;0010，也就是24)~ 按位取反5)&lt;&lt; 左移6)&gt;&gt; 右移 8、register关键词寄存器存在于CPU内部，运算速度非常快， 因为内存中的数据必须载入寄存器才能计算。如果直接定义一个变量为寄存器变量，则少了载入等过程自然会快。对于频繁使用的变量可以把它放在寄存器中来提速度。 1.寄存器变量可以用来优化加速c语言程序 2.声名只需在类型前多加register 即可，eg register int quick; （quick 就是一个整形的寄存器变量） 3.register只是一个建议型关键字，能不能声名成功还取决于编译器（建议型的关键字还有c++中的 inline），若不幸没有请求成功，则变量变成一个普通的自动变量。 4.是无法对一个register变量取地址的（因为寄存器变量多放在寄存器而非内存中，内存有地址，而寄存器是无地址的） 12345//全局变量最好不要占用寄存器，会影响程序的速度register int num = 1000;//err//只有局部自动变量和形参才可以定义为寄存器变量。因为寄存器变量属于动态存储方式，凡需要采用静态存储方式的量都不能定义为寄存器变量，包括：模块间全局变量、模块内全局变量、局部static变量。 //静态变量无法定义为寄存器变量,静态变量存在静态区register static double res = 0.0;//err 9、volatile 关键词volatile的作用是告知编译器，它修饰的变量随时都可能被改变，因此，编译后的程序每次在使用该变量的值时，都会从变量的地址中读取数据，而不是从寄存器中获取。 12345678910111213141516171819/*volatile的本意是“易变的”由于访问寄存器的速度要快过RAM，所以编译器一般都会作减少存取外部RAM的优化。比如：*/static int i=0;int main(void)&#123;...while (1)&#123;if (i) do_something();&#125;&#125;/* Interrupt service routine. */void ISR_2(void)&#123;i=1;&#125;/*程序的本意是希望ISR_2中断产生时，在main当中调用do_something函数，但是，由于编译器判断在main函数里面没有修改过i，因此可能只执行一次对从i到某寄存器的读操作，然后每次if判断都只使用这个寄存器里面的“i副本”，导致do_something永远也不会被调用。如果变量加上volatile修饰，则编译器保证对此变量的读写操作都不会被优化（肯定执行）。此例中i也应该如此说明。*/ 一般说来，volatile用在如下的几个地方：1、中断服务程序中修改的供其它程序检测的变量需要加volatile；2、多任务环境下各任务间共享的标志应该加volatile；3、存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；另外，以上这几种情况经常还要同时考虑数据的完整性（相互关联的几个标志读了一半被打断了重写），在1中可以通过关中断来实现，2中可以禁止任务调度，3中则只能依靠硬件的良好设计了。 10、排序算法冒泡排序：基本思想：比较相邻的两个数，如果前者比后者大，则进行交换。每一轮排序结束，选出一个未排序中最大的数放到数组后面。 123456789101112131415161718192021#include&lt;stdio.h&gt;//冒泡排序算法void bubbleSort(int *arr, int n) &#123; for (int i = 0; i&lt;n - 1; i++) for (int j = 0; j &lt; n - i - 1; j++) &#123; //如果前面的数比后面大，进行交换 if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125;&#125;int main() &#123; int arr[] = &#123; 10,6,5,2,3,8,7,4,9,1 &#125;; int n = sizeof(arr) / sizeof(int); bubbleSort(arr, n); printf(&quot;排序后的数组为：\\n&quot;); for (int j = 0; j&lt;n; j++) printf(&quot;%d &quot;, arr[j]); printf(&quot;\\n&quot;); return 0; 参考文章：七大经典排序算法总结(C语言描述)","categories":[{"name":"知识","slug":"知识","permalink":"https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://kelecn.top/tags/C/"},{"name":"编程","slug":"编程","permalink":"https://kelecn.top/tags/%E7%BC%96%E7%A8%8B/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://kelecn.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"C","slug":"C","permalink":"https://kelecn.top/tags/C/"}]},{"title":"精简代码：改换运算符","slug":"15、精简代码：改换运算符","date":"2020-08-22T13:57:00.000Z","updated":"2020-10-15T01:12:28.929Z","comments":true,"path":"2020/08/22/15、精简代码：改换运算符/","link":"","permalink":"https://kelecn.top/2020/08/22/15%E3%80%81%E7%B2%BE%E7%AE%80%E4%BB%A3%E7%A0%81%EF%BC%9A%E6%94%B9%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"简介： 精简代码：改换运算符","text":"简介： 精简代码：改换运算符 1、位运算（&amp;）替换取余（%）运算即：如果Y =,则X%Y可以变化为X&amp;(Y-1)由于我们知道位运算比较高效，在某些情况下，当b为2的n次方时，有如下替换公式：a % b = a &amp; (b-1)(b=2^n)即：a % 2^n = a &amp; (2^n-1)例如：14%8，取余数，相当于取出低位，而余数最大为7，14二进制为1110，8的二进制1000，8-1 = 7的二进制为0111，由于现在低位全为1，让其跟14做&amp;运算，正好取出的是其低位上的余数。1110&amp;0111=110即6=14%8；（此公式只适用b=2^n，是因为可以保证b始终只有最高位为1，其他二进制位全部为0，减去1，之后，可以把高位1消除，其他位都为1，而与1做&amp;运算，会保留原来的数。） 2、左移运算（&lt;&lt;）替换乘法（*）运算a=a8;b=b/8;可以改为：a=a&lt;&lt;3;b=b&gt;&gt;3;说明：除2 = 右移1位； 乘2 = 左移1位除4 = 右移2位； 乘4 = 左移2位除8 = 右移3位； 乘8 = 左移3位通常如果需要乘以或除以2的n次方，都可以用移位的方法代替，大部分的C编译器,用移位的方法得到代码比调用乘除法子程序生成的代码效率高。实际上，只要是乘以或除以一个整数才可以用移位的方法得到结果。如：a=a9 =a(8+1)=a8+a1可以改为：a=(a&lt;&lt;3)+a如：a=a7 =a(8-1)=a8-a1可以改为：a=(a&lt;&lt;3)-a 总结：a=an; n分解成(2^m + s),则a=an可以改为a=(a&lt;&lt;m)+as;as再同理分解替换。 例：a=a10 =&gt; a=a(8+2) =&gt; a=a8 + a2 =&gt; a=(a&lt;&lt;3)+(a&lt;&lt;1) 3、右移运算（&gt;&gt;）替换除法（/）运算a=a*8;b=b/8;可以改为：a=a&lt;&lt;3;b=b&gt;&gt;3;说明：除2 = 右移1位； 乘2 = 左移1位除4 = 右移2位； 乘4 = 左移2位除8 = 右移3位； 乘8 = 左移3位通常如果需要乘以或除以2的n次方，都可以用移位的方法代替，大部分的C编译器,用移位的方法得到代码比调用乘除法子程序生成的代码效率高。实际上，只要是乘以或除以一个整数才可以用移位的方法得到结果。如：a=a/9 =a/(8+1)=a/8+a/1可以改为：a=(a&gt;&gt;3)+a如：a=a/7 =a/(8-1)=a/8-a/1可以改为：a=(a&gt;&gt;3)-a总结：a=a/n; n分解成(2^m + s),则a=a/n可以改为a=(a&gt;&gt;m)+a/s;a/s再同理分解替换。例：a=a/10 =&gt; a=a/(8+2) =&gt; a=a/8 + a/2 =&gt; a=(a&gt;&gt;3)+(a&gt;&gt;1) 4、C/C++中的移位操作容易出错的情况： 什么样的数据类型可以直接移位 只有整型数据才能用移位替代乘除法，如：char、short、int、long、unsigned char、unsigned short、unsigned int、unsigned long。（double、float、bool、long double则不可以进行移位操作。） 有符号数据类型移位需要注意符号位对于char、short、int、long这些有符号的数据类型：对负数进行左移：符号位始终为1，其他位左移。对正数进行左移：所有位左移，即 &lt;&lt;，可能会变成负数对负数进行右移：取绝对值，然后右移，再取相反数对正数进行右移：所有位右移，即 &gt;&gt; 无符号数据类型的移位操作对于unsigned char、unsigned short、unsigned int、unsigned long这些无符号数据类型：没有特殊要说明的，使用&lt;&lt; 和 &gt;&gt; 操作符就OK了。5、参考资料： 使用位运算替换取余操作 移位操作与乘除法的关系","categories":[{"name":"知识","slug":"知识","permalink":"https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://kelecn.top/tags/C/"},{"name":"ARM","slug":"ARM","permalink":"https://kelecn.top/tags/ARM/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://kelecn.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"C","slug":"C","permalink":"https://kelecn.top/tags/C/"},{"name":"单片机","slug":"单片机","permalink":"https://kelecn.top/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"}]},{"title":"基于PicGo的GitHub图床","slug":"14、我的GitHub图床（基于PicGo）","date":"2020-08-18T13:57:00.000Z","updated":"2020-10-12T03:38:07.223Z","comments":true,"path":"2020/08/18/14、我的GitHub图床（基于PicGo）/","link":"","permalink":"https://kelecn.top/2020/08/18/14%E3%80%81%E6%88%91%E7%9A%84GitHub%E5%9B%BE%E5%BA%8A%EF%BC%88%E5%9F%BA%E4%BA%8EPicGo%EF%BC%89/","excerpt":"简介：GitHub图床（基于PicGo）","text":"简介：GitHub图床（基于PicGo） GitHub图床（基于PicGo）1. 首先你得有一个GitHub账号。注册GitHub就不用我多言。2. 新建一个仓库 记下你取的仓库名。 3. 生成一个token用于PicGo操作你的仓库：访问：https://github.com/settings/tokens 然后点击Generate new token。 把repo的勾打上即可。然后翻到页面最底部，点击Generate token的绿色按钮生成token。 注意：这个token生成后只会显示一次！你要把这个token复制一下存到其他地方以备以后要用。 4. 配置PicGo注意：仓库名的格式是用户名/仓库，比如我创建了一个叫做test的仓库，在PicGo里我要设定的仓库名就是kelecn/images。一般我们选择master分支即可。然后记得点击确定以生效，然后可以点击设为默认图床来确保上传的图床是GitHub。 12345678//PicGo配置&#123; &quot;repo&quot;: &quot;&quot;, // 仓库名，格式是username/reponame &quot;token&quot;: &quot;&quot;, // github token &quot;path&quot;: &quot;&quot;, // 自定义存储路径，比如img/ &quot;customUrl&quot;: &quot;&quot;, // 自定义域名，注意要加http://或者https:// &quot;branch&quot;: &quot;&quot; // 分支名，默认是master&#125; 至此配置完毕，已经可以使用了。当你上传的时候，你会发现你的仓库里也会增加新的图片了： 更多图床设计：请参考PicGo官方手册","categories":[{"name":"技术","slug":"技术","permalink":"https://kelecn.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://kelecn.top/tags/Hexo/"},{"name":"相册","slug":"相册","permalink":"https://kelecn.top/tags/%E7%9B%B8%E5%86%8C/"},{"name":"图床","slug":"图床","permalink":"https://kelecn.top/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"Github","slug":"Github","permalink":"https://kelecn.top/tags/Github/"},{"name":"PicGo","slug":"PicGo","permalink":"https://kelecn.top/tags/PicGo/"}]},{"title":"ARM处理器7种工作模式","slug":"12、ARM处理器7种工作模式","date":"2020-06-11T13:47:00.000Z","updated":"2020-10-12T03:37:46.978Z","comments":true,"path":"2020/06/11/12、ARM处理器7种工作模式/","link":"","permalink":"https://kelecn.top/2020/06/11/12%E3%80%81ARM%E5%A4%84%E7%90%86%E5%99%A87%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/","excerpt":"简介：ARM处理器7种工作模式（特权模式，异常模式，用户模式）。","text":"简介：ARM处理器7种工作模式（特权模式，异常模式，用户模式）。 ARM处理器7种工作模式（特权模式，异常模式，用户模式）用户模式（USR）：正常程序执行模式，不能直接切换到其他模式系统模式（SYS）：运行操作系统的特权任务，与用户模式类似，但具有可以直接切换到其他模式等特权快中断模式（FIQ）：支持高速数据传输及通道处理，FIQ异常响应时进入此模式中断模式（IRQ）：用于通用中断处理，IRQ异常响应时进入此模式管理模式（SVC）：操作系统保护模式，系统复位和软件中断响应时进入此模式（由系统调用执行软中断SWI命令触发）中止模式（ABT）：用于支持虚拟内存和/或存储器保护，在ARM7TDMI没有大用处未定义模式（UND）：支持硬件协处理器的软件仿真，未定义指令异常响应时进入此模式 7种工作模式分类： 除用户模式外，其余6种工作模式都属于特权模式 特权模式中除了系统模式以外的其余5种模式称为异常模式 大多数程序运行于用户模式 进入特权模式是为了处理中断、异常、或者访问被保护的系统资源 硬件权限级别：系统模式 &gt; 异常模式 &gt; 用户模式快中断与慢中断区别：快中断处理时禁止中断","categories":[{"name":"知识","slug":"知识","permalink":"https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"ARM","slug":"ARM","permalink":"https://kelecn.top/tags/ARM/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://kelecn.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"处理器","slug":"处理器","permalink":"https://kelecn.top/tags/%E5%A4%84%E7%90%86%E5%99%A8/"},{"name":"硬件","slug":"硬件","permalink":"https://kelecn.top/tags/%E7%A1%AC%E4%BB%B6/"}]},{"title":"测试相册功能","slug":"13、测试","date":"2020-06-09T13:57:00.000Z","updated":"2020-10-15T01:07:06.312Z","comments":true,"path":"2020/06/09/13、测试/","link":"","permalink":"https://kelecn.top/2020/06/09/13%E3%80%81%E6%B5%8B%E8%AF%95/","excerpt":"","text":"二次元壁纸日常旅游","categories":[{"name":"日记","slug":"日记","permalink":"https://kelecn.top/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://kelecn.top/tags/Hexo/"},{"name":"相册","slug":"相册","permalink":"https://kelecn.top/tags/%E7%9B%B8%E5%86%8C/"},{"name":"Kelecn","slug":"Kelecn","permalink":"https://kelecn.top/tags/Kelecn/"}]},{"title":"C++与Java多态的区别","slug":"11、C++与Java多态的区别","date":"2020-06-06T13:40:00.000Z","updated":"2020-10-03T07:49:41.989Z","comments":true,"path":"2020/06/06/11、C++与Java多态的区别/","link":"","permalink":"https://kelecn.top/2020/06/06/11%E3%80%81C++%E4%B8%8EJava%E5%A4%9A%E6%80%81%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"简介：C++与Java多态的区别。","text":"简介：C++与Java多态的区别。 多态是指用父指针指向不同子类对象时，调用其共有的函数，不同的子类会有不同的行为。虽然C++和Java都具有多态机制，但是他们的实现不同，使用时的效果也会略有不同。在C++中 普通函数调用：具体调用哪个方法在编译时就可以决定(通过查找编译器的符号表)，同时在使用标准过程调用机制基础上增加一个表示对象身份的指针(this指针)。 虚函数调用：函数调用依赖于对象的实际类型，一般地说，对象的实际类型只能在运行时间才能确定。实现机制是使用virtual table(vtbls)和virtual table pointers(vptrs)。 vtbl 是由函数指针构成的数组或链表，程序中每一个class凡声明(或继承)虚函数者，都有一个自己的vtbl，其中的条目就是该class的各个虚函数实现的指针。因此必须为每一个class消耗一个vtbl空间，其大小视虚函数的个数确定。 凡声明有虚函数的class，其对象都有一个隐藏的data member，用来指向class的vtbl。 当多态发生时，编译器首先根据对象vptr找出其vtbl，然后找出vtbl内对应的函数指针，最后调用函数指针指向的函数。从而实现多态。 在Java中1.C++中VTable和vptr是在编译阶段由编译器自动生成的，也就是说，在C++程序载入内存以前，在.obj（.o）文件中已经有这些结构的信 息；Java中的方法表是由JVM生成的，因此，使用javac命令编译后生成的.class文件中并没有方法表的信息。只有等JVM把.class文件 载入到内存中时，才会为该.class文件动态生成一个与之关联的方法表，放置在JVM的方法区中。 2.C++中某个方法在VTable的索引号是在编译阶段已经明确知道的，并不需要在运行过程中动态获知；Java中的方法初始时都只是一个符号，并不是 一个明确的地址，只有等到该方法被第一次调用时，才会被解析成一个方法表中的偏移量，也就是说，只有在这个时候，实例方法才明确知道自己在方发表中的偏移 量了，在这之前必须经历一个解析的过程。 因此在构造函数是Java会发生多态，即使子类此时还没有构造完全（一个极难发现的bug）。而C++则不会发生多态，待父类构造完全，在构造子类。Java代码如下： 123456789101112131415161718192021222324252627public class A &#123; public void fun() &#123; System.out.println(&quot;A&quot;); &#125; public A() &#123; this.fun(); &#125;&#125;public class B extends A&#123; public void fun() &#123; System.out.println(&quot;B&quot;); &#125; public B() &#123; fun(); &#125; public static void main(String [] argv) &#123; B b = new B(); &#125;&#125;//B//B C++代码如下： 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;using namespace std;class A&#123; public: virtual void fun() &#123; cout&lt;&lt;&quot;A&quot;&lt;&lt;endl; &#125; A() &#123; fun(); &#125;&#125;;class B : A&#123; public: virtual void fun() &#123; cout&lt;&lt;&quot;B&quot;&lt;&lt;endl; &#125; B() &#123; fun(); &#125; &#125;;int main(int argc, char *argv[])&#123; B b;&#125;//A//B 可以发现，C++构造子类时，先构造父类，输出A，然后在构造自身，输出B。而Java在构造子类时，父类并未构造完成，但已经可以发生多态输出B，然后再构造自身，输出B。Java一般为了避免这种情况，会把fun等init()函数声明为private或者finial。","categories":[{"name":"知识","slug":"知识","permalink":"https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"https://kelecn.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"C++","slug":"C","permalink":"https://kelecn.top/tags/C/"},{"name":"代码","slug":"代码","permalink":"https://kelecn.top/tags/%E4%BB%A3%E7%A0%81/"},{"name":"编程","slug":"编程","permalink":"https://kelecn.top/tags/%E7%BC%96%E7%A8%8B/"},{"name":"Java","slug":"Java","permalink":"https://kelecn.top/tags/Java/"}]},{"title":"C++重载注意点","slug":"10、重载注意点","date":"2020-05-20T13:30:00.000Z","updated":"2020-10-12T03:37:34.274Z","comments":true,"path":"2020/05/20/10、重载注意点/","link":"","permalink":"https://kelecn.top/2020/05/20/10%E3%80%81%E9%87%8D%E8%BD%BD%E6%B3%A8%E6%84%8F%E7%82%B9/","excerpt":"简介：C++重载注意点。","text":"简介：C++重载注意点。 1.调用函数在前，定义函数在后，进行原型声明2.函数重载注意：参数类型和个数相同，参数顺序不同，也可以重载12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;iomanip&gt; using namespace std; void print(int a,double b);//调用函数在前，定义函数在后，进行原型声明void print (double b,int a);//调用函数在前，定义函数在后，进行原型声明 int main()&#123; int x=8; double y=8; print(x,y); print(y,x); return 0;&#125;void print(int a,double b)&#123; cout&lt;&lt;showpoint&lt;&lt;&quot;1&quot;&lt;&lt;a&lt;&lt;b&lt;&lt;endl;&#125; void print (double b,int a)&#123; cout&lt;&lt;showpoint&lt;&lt;&quot;2&quot;&lt;&lt; a&lt;&lt;b &lt;&lt;endl; &#125; 3.C++中cout输出字符型指针地址值的方法1234567891011//C++中cout输出字符型指针地址值的方法//若要打印地址请用void*，否则 p会被认为是字符串。原因：运算符重载的匹配规则 #include&lt;iostream&gt; using namespace std; int main() &#123; char a; char *p=&amp;a; cout&lt;&lt;(void*)p&lt;&lt;endl&lt;&lt;a&lt;&lt;endl; &#125;","categories":[{"name":"知识","slug":"知识","permalink":"https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"https://kelecn.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"C++","slug":"C","permalink":"https://kelecn.top/tags/C/"},{"name":"代码","slug":"代码","permalink":"https://kelecn.top/tags/%E4%BB%A3%E7%A0%81/"},{"name":"编程","slug":"编程","permalink":"https://kelecn.top/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"C++返回对象和返回引用","slug":"9、C++返回对象和返回引用","date":"2020-04-19T13:20:07.000Z","updated":"2020-10-12T03:37:21.578Z","comments":true,"path":"2020/04/19/9、C++返回对象和返回引用/","link":"","permalink":"https://kelecn.top/2020/04/19/9%E3%80%81C++%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%BF%94%E5%9B%9E%E5%BC%95%E7%94%A8/","excerpt":"简介：C++返回对象和返回引用。","text":"简介：C++返回对象和返回引用。 我们发现，在C++中，有些成员函数返回的是对象，而有些函数返回的又是引用。 返回对象和返回引用的最主要的区别就是函数原型和函数头。 123Car run(const Car &amp;) //返回对象Car &amp; run(const Car &amp;) //返回引用 ​ 返回对象会涉及到生成返回对象的副本。因此，返回对象的时间成本包括了调用复制构造函数来生成副本所需的时间和调用析构函数删除副本所需的时间。返回引用可以节省时间和内存。直接返回对象与按值传递对象类似，他们都生成临时副本。同样，返回引用与按引用传递对象类似，调用和被调用的函数对同一个对象进行操作。 ​ 并不是总是可以返回引用的。比如函数不能返回在函数中创建的临时对象的引用。因为当函数结束调用时，临时对象将消失，因此这种引用是非法的。在这种情况下，应返回对象，以生成一个调用程序可以使用的副本。","categories":[{"name":"知识","slug":"知识","permalink":"https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"https://kelecn.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"C++","slug":"C","permalink":"https://kelecn.top/tags/C/"},{"name":"代码","slug":"代码","permalink":"https://kelecn.top/tags/%E4%BB%A3%E7%A0%81/"},{"name":"编程","slug":"编程","permalink":"https://kelecn.top/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"关于free和delete的使用","slug":"8、关于free和delete的使用","date":"2020-03-29T13:10:00.000Z","updated":"2020-10-12T03:37:06.416Z","comments":true,"path":"2020/03/29/8、关于free和delete的使用/","link":"","permalink":"https://kelecn.top/2020/03/29/8%E3%80%81%E5%85%B3%E4%BA%8Efree%E5%92%8Cdelete%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"简介：关于free和delete的使用","text":"简介：关于free和delete的使用 两个同时存在是有它的原因的，free是函数，它只释放内存，但不会调用析构函数，如果用free去释放new申请的空间，会因为无法调用析构函数而出现不必要的错误。 12345678char *point = (char *) malloc(100); strcpy(point, “hello”); free(point); // Be careful here，point 所指的内存被释放，but point 所指的地址仍然不变 … if(point != NULL) // 没有起到防错作用 &#123; strcpy(point, “jackery”); // error &#125; 这段程序中，原来free和delete只是把指针所指的内存给释放掉，但并没有把指针本身干掉。指针point被free以后其地址仍然不变（非NULL），只是该地址对应的内存是垃圾，point成了“野指针”。如果此时不把point设置为NULL，会让人误以为point是个合法的指针。如果程序比较长，我们有时记不住 point 所指的内存是否已经被释放，在继续使用point 之前，通常会用语句if (p != NULL)进行防错处理。很遗憾，此时if语句起不到防错作用，因为即便point不是NULL指针，它也不指向合法的内存块。为了避免失误，最好在free之后或者之前，将指针指向NULL new()/delete()与 malloc()/free() 区别1.malloc()/free() 是标准库函数， 使用前需调用库头文件 &lt;stdlib.h&gt; 方可使用；而 new/delete 是运算 符，执行效率更高。 2.malloc() 需要手工计算字节数；而 new 能够自动计算需要分配的内存空间。 3.malloc() 返回的指针是 void 类型；而 new*返回的指针是它分配空间的类型。 4.new 时调用构造函数，而 malloc() 不能；delete 时调用析构函数，而 free() 不能。 5.new 在申请单个类型变量时可以赋初值，而 malloc() 不具备。","categories":[{"name":"知识","slug":"知识","permalink":"https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"https://kelecn.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"C++","slug":"C","permalink":"https://kelecn.top/tags/C/"},{"name":"代码","slug":"代码","permalink":"https://kelecn.top/tags/%E4%BB%A3%E7%A0%81/"},{"name":"编程","slug":"编程","permalink":"https://kelecn.top/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"常量指针与指针常量","slug":"7、常量指针与指针常量","date":"2020-03-11T13:07:00.000Z","updated":"2020-10-13T05:48:50.882Z","comments":true,"path":"2020/03/11/7、常量指针与指针常量/","link":"","permalink":"https://kelecn.top/2020/03/11/7%E3%80%81%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F/","excerpt":"简介：常量指针与指针常量的区别。","text":"简介：常量指针与指针常量的区别。 常量指针(被指向的对象是常量)定义：又叫常指针，可以理解为常量的指针，指向的是个常量 关键点： 常量指针指向的对象不能通过这个指针来修改，可是仍然可以通过原来的声明修改； 常量指针可以被赋值为变量的地址，之所以叫常量指针，是限制了通过这个指针修改变量的值； 指针还可以指向别处，因为指针本身只是个变量，可以指向任意地址； 代码形式：1int const* p; const int* p; 12345678910111213141516#include &lt;stdio.h&gt;// 常量指针(被指向的对象是常量)int main() &#123; int i = 10; int i2 = 11; const int *p = &amp;i; printf(&quot;%d\\n&quot;, *p);//10 i = 9; //OK,仍然可以通过原来的声明修改值， //Error,*p是const int的，不可修改，即常量指针不可修改其指向地址 //*p = 11; //error: assignment of read-only location ‘*p’ p = &amp;i2;//OK,指针还可以指向别处，因为指针只是个变量，可以随意指向； printf(&quot;%d\\n&quot;, *p);//11 return 0;&#125; 指针常量(指针本身是常量)定义：本质是一个常量，而用指针修饰它。指针常量的值是指针，这个值因为是常量，所以不能被赋值。 关键点： 它是个常量！ 指针所保存的地址可以改变，然而指针所指向的值却不可以改变； 指针本身是常量，指向的地址不可以变化,但是指向的地址所对应的内容可以变化； 代码形式：1int* const p; 1234567891011121314//指针常量(指针本身是常量)#include &lt;stdio.h&gt;int main() &#123; int i = 10; int *const p = &amp;i; printf(&quot;%d\\n&quot;, *p);//10 //Error,因为p是const 指针，因此不能改变p指向的内容 //p++;//error: increment of read-only variable ‘p’ (*p)++; //OK,指针是常量，指向的地址不可以变化,但是指向的地址所对应的内容可以变化 printf(&quot;%d\\n&quot;, *p);//11 i = 9;//OK,仍然可以通过原来的声明修改值， return 0;&#125; 如何区分常量指针和指针常量 一种方式是看 * 和 const 的排列顺序，比如 123int const* p; //const * 即常量指针const int* p; //const * 即常量指针int* const p; //* const 即指针常量 还一种方式是看const离谁近，即从右往左看，比如 123int const* p; //const修饰的是*p，即*p的内容不可通过p改变，但p不是const，p可以修改，*p不可修改；const int* p; //同上int* const p; //const修饰的是p，p是指针，p指向的地址不能修改，p不能修改，但*p可以修改； 例子12345678910111213141516171819202122232425//结构体类型的定义struct stu&#123; char name[50]; int age;&#125;;void fun1(struct stu * const p)&#123; //p = NULL; //err p-&gt;age = 10; //ok&#125;//void fun2(struct stu const* p)void fun2(const struct stu * p)&#123; p = NULL; //ok //p-&gt;age = 10; //err&#125;void fun3(const struct stu * const p)&#123; //p = NULL; //err //p-&gt;age = 10; //err&#125;","categories":[{"name":"知识","slug":"知识","permalink":"https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"https://kelecn.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"C++","slug":"C","permalink":"https://kelecn.top/tags/C/"},{"name":"代码","slug":"代码","permalink":"https://kelecn.top/tags/%E4%BB%A3%E7%A0%81/"},{"name":"编程","slug":"编程","permalink":"https://kelecn.top/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"编程过程中遇到的一些问题总结（C++&Java）","slug":"6、编程过程中遇到的一些问题总结（C++&Java）","date":"2020-02-18T02:05:00.000Z","updated":"2020-10-12T03:36:48.303Z","comments":true,"path":"2020/02/18/6、编程过程中遇到的一些问题总结（C++&Java）/","link":"","permalink":"https://kelecn.top/2020/02/18/6%E3%80%81%E7%BC%96%E7%A8%8B%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88C++&Java%EF%BC%89/","excerpt":"简介：（C++&amp;Java）问题总结。","text":"简介：（C++&amp;Java）问题总结。 1.Java中的boolean类型变量，只有两个值true ,false；C++也是，不过也可以用 1 0 代替。 12345678//Java boolean 类型public class HelloWorld &#123; public static void main(String[] args) &#123; while (true) &#123; System.out.println(&quot;I Love YOU!&quot;); &#125; &#125;&#125; 1234567891011//C++ boolean 类型#include &lt;iostream&gt;using namespace std;int main(int argc, char *argv[])&#123; while (1) &#123; cout&lt;&lt;&quot;I Love YOU!&quot;&lt;&lt;endl; &#125; return 0;&#125; 2.Java一个类中的boolean类型变量，一般用isXxx()类型获取私有变量Xxx； 注：get开头的方法，一般都表示返回某一个属性值；is开头的方法，一般都是用来表示判断某某内容。 123public boolean isSex() &#123; return sex; &#125;","categories":[{"name":"总结","slug":"总结","permalink":"https://kelecn.top/categories/%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"https://kelecn.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"C++","slug":"C","permalink":"https://kelecn.top/tags/C/"},{"name":"编程","slug":"编程","permalink":"https://kelecn.top/tags/%E7%BC%96%E7%A8%8B/"},{"name":"Java","slug":"Java","permalink":"https://kelecn.top/tags/Java/"}]},{"title":"JAVA测试题","slug":"5、JAVA测试题","date":"2020-02-07T02:05:00.000Z","updated":"2020-10-12T03:36:37.841Z","comments":true,"path":"2020/02/07/5、JAVA测试题/","link":"","permalink":"https://kelecn.top/2020/02/07/5%E3%80%81JAVA%E6%B5%8B%E8%AF%95%E9%A2%98/","excerpt":"简介：JAVA基础测试题。","text":"简介：JAVA基础测试题。 第一题输出9*9口诀表。 代码： 12345678910111213141516package exam;public class Exam &#123; public static void main(String[] args) &#123; for(int i = 1; i &lt; 10; i ++) &#123; for( int j = 1; j &lt;= i; j++) &#123; System.out.print(i +&quot; * &quot;+j+&quot; = &quot;+i*j + &quot; &quot;); &#125; System.out.println();//换行 &#125; &#125;&#125; 运行截图： 第二题求1+2!+3!+…+20!的和。 代码： 12345678910111213141516package exam;public class Exam &#123; public static void main(String[] args) &#123; float s=0,t=1; int n; for (n=1;n&lt;=20;n++) &#123; t=t*n; // 求n! s=s+t; // 将各项累加 &#125; System.out.println(&quot;1+2!+3!+...+20!=&quot;+s); &#125; &#125; 运行截图： 第三题一个5位数，判断它是不是回文数。即12321是回文数，个位与万位相同，十位与千位相同。 代码： 123456789101112131415161718192021222324package exam;import java.util.Scanner;public class Exam &#123; public static void main(String[] args) &#123; int ge,shi,qian,wan,x; System.out.println(&quot;请输入您想判断的五位数字：&quot;); Scanner in = new Scanner(System.in); x=in.nextInt(); wan=x/10000;//万位 qian=x%10000/1000;//千位 shi=x%100/10;//十位 ge=x%10;//个位 if (ge==wan&amp;&amp;shi==qian)//个位等于万位并且十位等于千位 &#123; System.out.println(&quot;这是回文数\\n&quot;); &#125; else &#123; System.out.println(&quot;这是不是回文数\\n&quot;); &#125; &#125; &#125; 运行截图： 第四题一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在第10次落地时，共经过多少米？第10次反弹多高？ 代码： 1234567891011121314151617package exam;public class Exam &#123; public static void main(String[] args) &#123; double sum = 0, high = 100;//sum为路径总和，high表示当前高度 for (int i = 0; i &lt; 10; i++) &#123; sum = high + high / 2 + sum;//一次落地距离+弹起距离+已经过路程 high /= 2;//弹起高度为一半 &#125; sum -= high;//求第10次落地经过路程需减去第10次弹起距离 System.out.println(&quot;共经过：&quot;+sum+ &quot;米\\n&quot;+&quot;第10次反弹高度为：&quot;+high+&quot;米&quot;); &#125; &#125; 运行截图： 第五题猴子吃桃问题：猴子第一天摘下若干个桃子，当即吃了一半，还不过瘾，又多吃了一个; 第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下的一半零一个。到第10天早上想再吃时，见只剩下一个桃子了。求第一天共摘了多少。 代码： 123456789101112131415package exam;public class Exam &#123; public static void main(String[] args) &#123; int x = 1;//第十天剩余桃子数 int y;//天数 for(y=1;y&lt;=9;y++) &#123; x=(x+1)*2;//前一天的剩余桃子数都是今天剩余桃子数加1后的两倍 &#125; System.out.println(&quot;猴子第一天一共摘了&quot;+x+&quot;个桃子。&quot;); &#125; &#125; 运行截图：","categories":[{"name":"知识","slug":"知识","permalink":"https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"https://kelecn.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"代码","slug":"代码","permalink":"https://kelecn.top/tags/%E4%BB%A3%E7%A0%81/"},{"name":"编程","slug":"编程","permalink":"https://kelecn.top/tags/%E7%BC%96%E7%A8%8B/"},{"name":"Java","slug":"Java","permalink":"https://kelecn.top/tags/Java/"}]},{"title":"面向对象的程序设计实验（C++）","slug":"4、面向对象的程序设计","date":"2019-12-25T02:51:34.000Z","updated":"2020-10-12T03:36:26.619Z","comments":true,"path":"2019/12/25/4、面向对象的程序设计/","link":"","permalink":"https://kelecn.top/2019/12/25/4%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/","excerpt":"简介：面向对象程序设计（C++）。","text":"简介：面向对象程序设计（C++）。 还没写呢^_^","categories":[{"name":"知识","slug":"知识","permalink":"https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"https://kelecn.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"C++","slug":"C","permalink":"https://kelecn.top/tags/C/"},{"name":"代码","slug":"代码","permalink":"https://kelecn.top/tags/%E4%BB%A3%E7%A0%81/"},{"name":"编程","slug":"编程","permalink":"https://kelecn.top/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"嵌入式开发为什么选择C语言？","slug":"3、嵌入式开发为什么选择C语言？","date":"2019-11-25T09:08:29.000Z","updated":"2020-10-12T03:35:46.193Z","comments":true,"path":"2019/11/25/3、嵌入式开发为什么选择C语言？/","link":"","permalink":"https://kelecn.top/2019/11/25/3%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9C%E8%AF%AD%E8%A8%80%EF%BC%9F/","excerpt":"简介:嵌入式+C语言=？","text":"简介:嵌入式+C语言=？ 1.从语言特点来说①C语言有出色的可移植性，能在多种不同体系结构的软/硬平台上运行。 ②简洁紧凑，使用灵活的语法机制，并能直接访问硬件能够直接访问硬件的语言有：汇编和C语言汇编属于低级语言，难以完成一些复杂的功能，但是汇编比C语言访问硬件的效率更高。所以，一般将硬件初始化的工作交给汇编，比较复杂的操作交给C语言。 ③C语言具有很高的运行效率。 2.嵌入式开发中的地位——开发工具3.高级语言中的低级语言：面向过程VS面向对象面向过程：“面向过程”(Procedure Oriented)是一种以过程为中心的编程思想。“面向过程”也可称之为“面向记录”编程思想，他们不支持丰富的“面向对象”特性(比如继承、多态)，并且它们不允许混合持久化状态和域逻辑。 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。面向过程其实是最为实际的一种思考方式,就算是面向对象的方法也是含有面向过程的思想。 可以说面向过程是一种基础的方法，它考虑的是实际地实现。一般的面向过程是从上往下步步求精，所以面向过程最重要的是模块化的思想方法。 面向对象：面向对象的分析根据抽象关键的问题域来分解系统。面向对象的设计是一种提供符号设计系统的面向对象的实现过程，它用非常接近实际领域术语的方法把系统构造成“现实世界”的对象。 面向对象程序设计可以看作一种在程序中包含各种独立而又互相调用的对象的思想，这与传统的思想刚好相反：传统的程序设计主张将程序看作一系列函数的集合，或者直接就是一系列对电脑下达的指令。面向对象程序设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象，因此它们都可以被看作一个小型的“机器”，即对象。 面向过程和面向对象的区别：以一个人从A地到B地为例，面向过程就是需要规划路线，了解路况，自己做好一系列的准备;而面向对象就是坐上一辆出租车，告诉司机我要去B地就可以了，不用关心其他的事情。 最后，C语言也有他自身的缺陷，比如代码的复用性差，代码的维护性差，扩展性(新增代码时不改变原来的代码)很差。","categories":[{"name":"知识","slug":"知识","permalink":"https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://kelecn.top/tags/%E7%BC%96%E7%A8%8B/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://kelecn.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"硬件","slug":"硬件","permalink":"https://kelecn.top/tags/%E7%A1%AC%E4%BB%B6/"},{"name":"C语言","slug":"C语言","permalink":"https://kelecn.top/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"Matlab Gui关于edit keypressfcn的响应","slug":"2、Matlab gui关于edit keypressfcn的响应","date":"2019-10-02T04:00:00.000Z","updated":"2020-10-12T03:43:38.688Z","comments":true,"path":"2019/10/02/2、Matlab gui关于edit keypressfcn的响应/","link":"","permalink":"https://kelecn.top/2019/10/02/2%E3%80%81Matlab%20gui%E5%85%B3%E4%BA%8Eedit%20keypressfcn%E7%9A%84%E5%93%8D%E5%BA%94/","excerpt":"简介：Matlab GUI键盘输入。","text":"简介：Matlab GUI键盘输入。 1234567891011121314 function showmap fig=figure( &#x27;Name&#x27;,&#x27;Timer&#x27;,&#x27;Position&#x27;,[0,0,500,500] ,&#x27;NumberTitle&#x27;,&#x27;off&#x27;,&#x27;visible&#x27;,&#x27;off&#x27;); movegui(fig,&#x27;center&#x27;); set(fig,&#x27;visible&#x27;,&#x27;on&#x27;); ttext= uicontrol(&#x27;Style&#x27;,&#x27;edit&#x27;,&#x27;Position&#x27;,[150,250,200,30],&#x27;String&#x27;,&#x27;Press &quot;Start&quot;&#x27;,... &#x27;KeyPressFcn&#x27;,@keyPress); ii=0; function keyPress(x,y) set(ttext,&#x27;string&#x27;,num2str(ii)); ii = ii+1; endend 参考文献：打浦桥程序员","categories":[{"name":"技术","slug":"技术","permalink":"https://kelecn.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"代码","slug":"代码","permalink":"https://kelecn.top/tags/%E4%BB%A3%E7%A0%81/"},{"name":"Matlab","slug":"Matlab","permalink":"https://kelecn.top/tags/Matlab/"},{"name":"Gui","slug":"Gui","permalink":"https://kelecn.top/tags/Gui/"}]},{"title":"Kelecn的第一条博客！","slug":"1、可乐的第一条博客","date":"2019-09-19T09:10:00.000Z","updated":"2020-10-12T03:35:05.440Z","comments":true,"path":"2019/09/19/1、可乐的第一条博客/","link":"","permalink":"https://kelecn.top/2019/09/19/1%E3%80%81%E5%8F%AF%E4%B9%90%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9D%A1%E5%8D%9A%E5%AE%A2/","excerpt":"简介：您好！Hexo！","text":"简介：您好！Hexo！ 友情链接：My Github、Hexo","categories":[{"name":"生活","slug":"生活","permalink":"https://kelecn.top/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://kelecn.top/tags/Hexo/"},{"name":"Kelecn","slug":"Kelecn","permalink":"https://kelecn.top/tags/Kelecn/"},{"name":"日记","slug":"日记","permalink":"https://kelecn.top/tags/%E6%97%A5%E8%AE%B0/"}]}],"categories":[{"name":"知识","slug":"知识","permalink":"https://kelecn.top/categories/%E7%9F%A5%E8%AF%86/"},{"name":"技术","slug":"技术","permalink":"https://kelecn.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"日记","slug":"日记","permalink":"https://kelecn.top/categories/%E6%97%A5%E8%AE%B0/"},{"name":"总结","slug":"总结","permalink":"https://kelecn.top/categories/%E6%80%BB%E7%BB%93/"},{"name":"生活","slug":"生活","permalink":"https://kelecn.top/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"Boost","slug":"Boost","permalink":"https://kelecn.top/tags/Boost/"},{"name":"Buck","slug":"Buck","permalink":"https://kelecn.top/tags/Buck/"},{"name":"DCDC","slug":"DCDC","permalink":"https://kelecn.top/tags/DCDC/"},{"name":"TCP","slug":"TCP","permalink":"https://kelecn.top/tags/TCP/"},{"name":"UDP","slug":"UDP","permalink":"https://kelecn.top/tags/UDP/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://kelecn.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"C++","slug":"C","permalink":"https://kelecn.top/tags/C/"},{"name":"编程","slug":"编程","permalink":"https://kelecn.top/tags/%E7%BC%96%E7%A8%8B/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://kelecn.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"C","slug":"C","permalink":"https://kelecn.top/tags/C/"},{"name":"ARM","slug":"ARM","permalink":"https://kelecn.top/tags/ARM/"},{"name":"单片机","slug":"单片机","permalink":"https://kelecn.top/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"Hexo","slug":"Hexo","permalink":"https://kelecn.top/tags/Hexo/"},{"name":"相册","slug":"相册","permalink":"https://kelecn.top/tags/%E7%9B%B8%E5%86%8C/"},{"name":"图床","slug":"图床","permalink":"https://kelecn.top/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"Github","slug":"Github","permalink":"https://kelecn.top/tags/Github/"},{"name":"PicGo","slug":"PicGo","permalink":"https://kelecn.top/tags/PicGo/"},{"name":"处理器","slug":"处理器","permalink":"https://kelecn.top/tags/%E5%A4%84%E7%90%86%E5%99%A8/"},{"name":"硬件","slug":"硬件","permalink":"https://kelecn.top/tags/%E7%A1%AC%E4%BB%B6/"},{"name":"Kelecn","slug":"Kelecn","permalink":"https://kelecn.top/tags/Kelecn/"},{"name":"面向对象","slug":"面向对象","permalink":"https://kelecn.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"代码","slug":"代码","permalink":"https://kelecn.top/tags/%E4%BB%A3%E7%A0%81/"},{"name":"Java","slug":"Java","permalink":"https://kelecn.top/tags/Java/"},{"name":"C语言","slug":"C语言","permalink":"https://kelecn.top/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"Matlab","slug":"Matlab","permalink":"https://kelecn.top/tags/Matlab/"},{"name":"Gui","slug":"Gui","permalink":"https://kelecn.top/tags/Gui/"},{"name":"日记","slug":"日记","permalink":"https://kelecn.top/tags/%E6%97%A5%E8%AE%B0/"}]}